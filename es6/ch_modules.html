<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>16. Modules</title>
    <link href="stylesheet.css" type="text/css" rel="stylesheet" />
    <link rel="icon" href="images/favicon-128.png" sizes="128x128">
    <link rel="icon" href="images/favicon-32.png" sizes="32x32">
    <link rel="icon" href="images/favicon-16.png" sizes="16x16">
</head>
<body>

<div id="top-bar">
</div>
<div id="top-bar">
    <div id="top-bar-content">
        <b>16. Modules</b><br>
        <a href="index.html#toc_ch_modules">Table of contents</a><br>
        Please support this book:
        <a href="https://leanpub.com/exploring-es6/">buy it (PDF, EPUB, MOBI)</a>
        or
        <a href="http://www.2ality.com/p/donate.html">donate</a>
    </div>
</div>

<div id="adbox">
<div id="adbox-explain">(Ad, please donâ€™t block.)</div>

    <script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=exploringjscom" id="_carbonads_js"></script>

</div>

<div id="page-content">


<h2 id="ch_modules">
<span class="section-number">16. </span>Modules <a class="header-anchor" href="ch_modules.html#ch_modules" aria-hidden="true">#</a></h2>

<hr class="scene-break">

<ul>
  <li>16.1. <a href="ch_modules.html#sec_overview-modules">Overview</a>
    <ul>
      <li>16.1.1. Multiple named exports</li>
      <li>16.1.2. Single default export</li>
      <li>16.1.3. Browsers: scripts versus modules</li>
    </ul>
  </li>
  <li>16.2. <a href="ch_modules.html#sec_modules-in-javascript">Modules in JavaScript</a>
    <ul>
      <li>16.2.1. ECMAScript 5 module systems</li>
      <li>16.2.2. ECMAScript 6 modules</li>
    </ul>
  </li>
  <li>16.3. <a href="ch_modules.html#sec_basics-of-es6-modules">The basics of ES6 modules</a>
    <ul>
      <li>16.3.1. Named exports (several per module)</li>
      <li>16.3.2. Default exports (one per module)</li>
      <li>16.3.3. Imports and exports must be at the top level</li>
      <li>16.3.4. Imports are hoisted</li>
      <li>16.3.5. Imports are read-only views on exports</li>
      <li>16.3.6. Support for cyclic dependencies</li>
    </ul>
  </li>
  <li>16.4. <a href="ch_modules.html#sec_importing-exporting-details">Importing and exporting in detail</a>
    <ul>
      <li>16.4.1. Importing styles</li>
      <li>16.4.2. Named exporting styles: inline versus clause</li>
      <li>16.4.3. Re-exporting</li>
      <li>16.4.4. All exporting styles</li>
      <li>16.4.5. Having both named exports and a default export in a module</li>
    </ul>
  </li>
  <li>16.5. <a href="ch_modules.html#sec_module-loader-api">The ECMAScript 6 module loader API</a>
    <ul>
      <li>16.5.1. Loaders</li>
      <li>16.5.2. Loader method: importing modules</li>
      <li>16.5.3. More loader methods</li>
      <li>16.5.4. Configuring module loading</li>
    </ul>
  </li>
  <li>16.6. <a href="ch_modules.html#sec_modules-in-browsers">Using ES6 modules in browsers</a>
    <ul>
      <li>16.6.1. Browsers: asynchronous modules versus synchronous scripts</li>
    </ul>
  </li>
  <li>16.7. <a href="ch_modules.html#sec_imports-as-views-on-exports">Details: imports as views on exports</a>
    <ul>
      <li>16.7.1. In CommonJS, imports are copies of exported values</li>
      <li>16.7.2. In ES6, imports are live read-only views on exported values</li>
      <li>16.7.3. Implementing views</li>
      <li>16.7.4. Imports as views in the spec</li>
    </ul>
  </li>
  <li>16.8. <a href="ch_modules.html#sec_design-goals-es6-modules">Design goals for ES6 modules</a>
    <ul>
      <li>16.8.1. Default exports are favored</li>
      <li>16.8.2. Static module structure</li>
      <li>16.8.3. Support for both synchronous and asynchronous loading</li>
      <li>16.8.4. Support for cyclic dependencies between modules</li>
    </ul>
  </li>
  <li>16.9. <a href="ch_modules.html#sec_faq-modules">FAQ: modules</a>
    <ul>
      <li>16.9.1. Can I use a variable to specify from which module I want to import?</li>
      <li>16.9.2. Can I import a module conditionally or on demand?</li>
      <li>16.9.3. Can I use variables in an <code>import</code> statement?</li>
      <li>16.9.4. Can I use destructuring in an <code>import</code> statement?</li>
      <li>16.9.5. Are named exports necessary? Why not default-export objects?</li>
      <li>16.9.6. Can I <code>eval()</code> the code of module?</li>
    </ul>
  </li>
  <li>16.10. <a href="ch_modules.html#sec_advantages-es6-modules">Advantages of ECMAScript 6 modules</a>
</li>
  <li>16.11. <a href="ch_modules.html#sec_further-reading-modules">Further reading</a>
</li>
</ul>

<hr class="scene-break">


<h3 id="sec_overview-modules">
<span class="section-number">16.1 </span>Overview <a class="header-anchor" href="ch_modules.html#sec_overview-modules" aria-hidden="true">#</a></h3>

<p>JavaScript has had modules for a long time. However, they were implemented via libraries, not built into the language. ES6 is the first time that JavaScript has built-in modules.</p>

<p>ES6 modules are stored in files. There is exactly one module per file and one file per module. You have two ways of exporting things from a module. <a href="ch_modules.html#sec_mixing-named-and-default-exports">These two ways can be mixed</a>, but it is usually better to use them separately.</p>

<h4 id="_multiple-named-exports">
<span class="section-number">16.1.1 </span>Multiple named exports <a class="header-anchor" href="ch_modules.html#_multiple-named-exports" aria-hidden="true">#</a></h4>

<p>There can be multiple <em>named exports</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">sqrt</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">diag</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">sqrt</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">+</code> <code class="nx">square</code><code class="p">(</code><code class="nx">y</code><code class="p">));</code>
<code class="p">}</code>

<code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">square</code><code class="p">,</code> <code class="nx">diag</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="mi">11</code><code class="p">));</code> <code class="c1">// 121</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">diag</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 5</code>
</pre></div>

</figure>

<p>You can also import the complete module:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">lib</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">square</code><code class="p">(</code><code class="mi">11</code><code class="p">));</code> <code class="c1">// 121</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">diag</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 5</code>
</pre></div>

</figure>

<h4 id="_single-default-export">
<span class="section-number">16.1.2 </span>Single default export <a class="header-anchor" href="ch_modules.html#_single-default-export" aria-hidden="true">#</a></h4>

<p>There can be a single <em>default export</em>. For example, a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ myFunc.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">}</code> <code class="c1">// no semicolon!</code>

<code class="c1">//------ main1.js ------</code>
<code class="kr">import</code> <code class="nx">myFunc</code> <code class="nx">from</code> <code class="s1">&apos;myFunc&apos;</code><code class="p">;</code>
<code class="nx">myFunc</code><code class="p">();</code>
</pre></div>

</figure>

<p>Or a class:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ MyClass.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">}</code> <code class="c1">// no semicolon!</code>

<code class="c1">//------ main2.js ------</code>
<code class="kr">import</code> <code class="nx">MyClass</code> <code class="nx">from</code> <code class="s1">&apos;MyClass&apos;</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">inst</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyClass</code><code class="p">();</code>
</pre></div>

</figure>

<p>Note that there is no semicolon at the end if you default-export a function or a class (which are anonymous declarations).</p>

<h4 id="_browsers-scripts-versus-modules">
<span class="section-number">16.1.3 </span>Browsers: scripts versus modules <a class="header-anchor" href="ch_modules.html#_browsers-scripts-versus-modules" aria-hidden="true">#</a></h4>

<table>
  <thead>
    <tr>
      <th>&#xA0;</th>
      <th>Scripts</th>
      <th>Modules</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTML element</td>
      <td><code>&lt;script&gt;</code></td>
      <td><code>&lt;script type=&quot;module&quot;&gt;</code></td>
    </tr>
    <tr>
      <td>Default mode</td>
      <td>non-strict</td>
      <td>strict</td>
    </tr>
    <tr>
      <td>Top-level variables are</td>
      <td>global</td>
      <td>local to module</td>
    </tr>
    <tr>
      <td>Value of <code>this</code> at top level</td>
      <td><code>window</code></td>
      <td><code>undefined</code></td>
    </tr>
    <tr>
      <td>Executed</td>
      <td>synchronously</td>
      <td>asynchronously</td>
    </tr>
    <tr>
      <td>Declarative imports (<code>import</code> statement)</td>
      <td>no</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>Programmatic imports (Promise-based API)</td>
      <td>yes</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>File extension</td>
      <td><code>.js</code></td>
      <td><code>.js</code></td>
    </tr>
  </tbody>

</table>



<h3 id="sec_modules-in-javascript">
<span class="section-number">16.2 </span>Modules in JavaScript <a class="header-anchor" href="ch_modules.html#sec_modules-in-javascript" aria-hidden="true">#</a></h3>

<p>Even though JavaScript never had built-in modules, the community has converged on a simple style of modules, which is supported by libraries in ES5 and earlier. This style has also been adopted by ES6:</p>

<ul>
  <li>Each module is a piece of code that is executed once it is loaded.</li>
  <li>In that code, there may be declarations (variable declarations, function declarations, etc.).
    <ul>
      <li>By default, these declarations stay local to the module.</li>
      <li>You can mark some of them as exports, then other modules can import them.</li>
    </ul>
  </li>
  <li>A module can import things from other modules. It refers to those modules via <em>module specifiers</em>, strings that are either:
    <ul>
      <li>Relative paths (<code>&apos;../model/user&apos;</code>): these paths are interpreted relatively to the location of the importing module. The file extension <code>.js</code> can usually be omitted.</li>
      <li>Absolute paths (<code>&apos;/lib/js/helpers&apos;</code>): point directly to the file of the module to be imported.</li>
      <li>Names (<code>&apos;util&apos;</code>): What modules names refer to has to be configured.</li>
    </ul>
  </li>
  <li>Modules are singletons. Even if a module is imported multiple times, only a single &#x201C;instance&#x201D; of it exists.</li>
</ul>

<p>This approach to modules avoids global variables, the only things that are global are module specifiers.</p>


<h4 id="_ecmascript-5-module-systems">
<span class="section-number">16.2.1 </span>ECMAScript 5 module systems <a class="header-anchor" href="ch_modules.html#_ecmascript-5-module-systems" aria-hidden="true">#</a></h4>

<p>It is impressive how well ES5 module systems work without explicit support from the language. The two most important (and unfortunately incompatible) standards are:</p>

<ul>
  <li>
<strong>CommonJS Modules:</strong> The dominant implementation of this standard is <a href="http://nodejs.org/api/modules.html">in Node.js</a> (Node.js modules have a few features that go beyond CommonJS). Characteristics:
    <ul>
      <li>Compact syntax</li>
      <li>Designed for synchronous loading and servers</li>
    </ul>
  </li>
  <li>
<strong>Asynchronous Module Definition (AMD):</strong> The most popular implementation of this standard is <a href="http://requirejs.org/">RequireJS</a>. Characteristics:
    <ul>
      <li>Slightly more complicated syntax, enabling AMD to work without eval() (or a compilation step)</li>
      <li>Designed for asynchronous loading and browsers</li>
    </ul>
  </li>
</ul>

<p>The above is but a simplified explanation of ES5 modules. If you want more in-depth material, take a look at &#x201C;<a href="http://addyosmani.com/writing-modular-js/">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a>&#x201D; by Addy Osmani.</p>


<h4 id="_ecmascript-6-modules">
<span class="section-number">16.2.2 </span>ECMAScript 6 modules <a class="header-anchor" href="ch_modules.html#_ecmascript-6-modules" aria-hidden="true">#</a></h4>

<p>The goal for ECMAScript 6 modules was to create a format that both users of CommonJS and of AMD are happy with:</p>

<ul>
  <li>Similarly to CommonJS, they have a compact syntax, a preference for single exports and support for cyclic dependencies.</li>
  <li>Similarly to AMD, they have direct support for asynchronous loading and configurable module loading.</li>
</ul>

<p>Being built into the language allows ES6 modules to go beyond CommonJS and AMD (details are explained later):</p>

<ul>
  <li>Their syntax is even more compact than CommonJS&#x2019;s.</li>
  <li>Their structure can be statically analyzed (for static checking, optimization, etc.).</li>
  <li>Their support for cyclic dependencies is better than CommonJS&#x2019;s.</li>
</ul>

<p>The ES6 module standard has two parts:</p>

<ul>
  <li>Declarative syntax (for importing and exporting)</li>
  <li>Programmatic loader API: to configure how modules are loaded and to conditionally load modules</li>
</ul>


<h3 id="sec_basics-of-es6-modules">
<span class="section-number">16.3 </span>The basics of ES6 modules <a class="header-anchor" href="ch_modules.html#sec_basics-of-es6-modules" aria-hidden="true">#</a></h3>

<p>There are two kinds of exports: named exports (several per module) and default exports (one per module). <a href="ch_modules.html#sec_mixing-named-and-default-exports">As explained later</a>, it is possible use both at the same time, but usually best to keep them separate.</p>


<h4 id="_named-exports-several-per-module">
<span class="section-number">16.3.1 </span>Named exports (several per module) <a class="header-anchor" href="ch_modules.html#_named-exports-several-per-module" aria-hidden="true">#</a></h4>

<p>A module can export multiple things by prefixing its declarations with the keyword <code>export</code>. These exports are distinguished by their names and are called <em>named exports</em>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">sqrt</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">diag</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">sqrt</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">+</code> <code class="nx">square</code><code class="p">(</code><code class="nx">y</code><code class="p">));</code>
<code class="p">}</code>

<code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">square</code><code class="p">,</code> <code class="nx">diag</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="mi">11</code><code class="p">));</code> <code class="c1">// 121</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">diag</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 5</code>
</pre></div>

</figure>

<p>There are other ways to specify named exports (which are explained later), but I find this one quite convenient: simply write your code as if there were no outside world, then label everything that you want to export with a keyword.</p>

<p>If you want to, you can also import the whole module and refer to its named exports via property notation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">lib</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">square</code><code class="p">(</code><code class="mi">11</code><code class="p">));</code> <code class="c1">// 121</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">diag</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 5</code>
</pre></div>

</figure>

<p><strong>The same code in CommonJS syntax:</strong> For a while, I tried several clever strategies to be less redundant with my module exports in Node.js. Now I prefer the following simple but slightly verbose style that is reminiscent of the <a href="http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/">revealing module pattern</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kd">var</code> <code class="nx">sqrt</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">diag</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">sqrt</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">+</code> <code class="nx">square</code><code class="p">(</code><code class="nx">y</code><code class="p">));</code>
<code class="p">}</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">sqrt</code><code class="o">:</code> <code class="nx">sqrt</code><code class="p">,</code>
    <code class="nx">square</code><code class="o">:</code> <code class="nx">square</code><code class="p">,</code>
    <code class="nx">diag</code><code class="o">:</code> <code class="nx">diag</code><code class="p">,</code>
<code class="p">};</code>

<code class="c1">//------ main.js ------</code>
<code class="kd">var</code> <code class="nx">square</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;lib&apos;</code><code class="p">).</code><code class="nx">square</code><code class="p">;</code>
<code class="kd">var</code> <code class="nx">diag</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;lib&apos;</code><code class="p">).</code><code class="nx">diag</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="mi">11</code><code class="p">));</code> <code class="c1">// 121</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">diag</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 5</code>
</pre></div>

</figure>


<h4 id="_default-exports-one-per-module">
<span class="section-number">16.3.2 </span>Default exports (one per module) <a class="header-anchor" href="ch_modules.html#_default-exports-one-per-module" aria-hidden="true">#</a></h4>

<p>Modules that only export single values are very popular in the Node.js community. But they are also common in frontend development where you often have classes for models and components, with one class per module. An ES6 module can pick a <em>default export</em>, the main exported value. Default exports are especially easy to import.</p>

<p>The following ECMAScript 6 module &#x201C;is&#x201D; a single function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ myFunc.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>

<code class="c1">//------ main1.js ------</code>
<code class="kr">import</code> <code class="nx">myFunc</code> <code class="nx">from</code> <code class="s1">&apos;myFunc&apos;</code><code class="p">;</code>
<code class="nx">myFunc</code><code class="p">();</code>
</pre></div>

</figure>

<p>An ECMAScript 6 module whose default export is a class looks as follows:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ MyClass.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>

<code class="c1">//------ main2.js ------</code>
<code class="kr">import</code> <code class="nx">MyClass</code> <code class="nx">from</code> <code class="s1">&apos;MyClass&apos;</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">inst</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyClass</code><code class="p">();</code>
</pre></div>

</figure>

<p>There are two styles of default exports:</p>

<ol class="numeric">
  <li>Labeling declarations</li>
  <li>Default-exporting values directly</li>
</ol>

<h5 id="_default-export-style-1-labeling-declarations">
<span class="section-number">16.3.2.1 </span>Default export style 1: labeling declarations <a class="header-anchor" href="ch_modules.html#_default-export-style-1-labeling-declarations" aria-hidden="true">#</a></h5>

<p>You can prefix any function declaration (or generator function declaration) or class declaration with the keywords <code>export default</code> to make it the default export:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">Bar</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>
</pre></div>

</figure>

<p>You can also omit the name in this case. That makes default exports the only place where JavaScript has anonymous function declarations and anonymous class declarations:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="p">{}</code> <code class="c1">// no semicolon!</code>
</pre></div>

</figure>

<h6 id="_why-anonymous-function-declarations-and-not-anonymous-function-expressions">
<span class="section-number">16.3.2.1.1 </span>Why anonymous function declarations and not anonymous function expressions? <a class="header-anchor" href="ch_modules.html#_why-anonymous-function-declarations-and-not-anonymous-function-expressions" aria-hidden="true">#</a></h6>

<p>When you look at the previous two lines of code, you&#x2019;d expect the operands of <code>export default</code> to be expressions. They are only declarations for reasons of consistency: operands can be named declarations, interpreting their anonymous versions as expressions would be confusing (even more so than introducing new kinds of declarations).</p>


<p>If you want the operands to be interpreted as expressions, you need to use parentheses:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{});</code>
<code class="kr">export</code> <code class="k">default</code> <code class="p">(</code><code class="kr">class</code> <code class="p">{});</code>
</pre></div>

</figure>

<h5 id="_default-export-style-2-default-exporting-values-directly">
<span class="section-number">16.3.2.2 </span>Default export style 2: default-exporting values directly <a class="header-anchor" href="ch_modules.html#_default-export-style-2-default-exporting-values-directly" aria-hidden="true">#</a></h5>

<p>The values are produced via expressions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="s1">&apos;abc&apos;</code><code class="p">;</code>
<code class="kr">export</code> <code class="k">default</code> <code class="nx">foo</code><code class="p">();</code>
<code class="kr">export</code> <code class="k">default</code> <code class="sr">/^xyz$/</code><code class="p">;</code>
<code class="kr">export</code> <code class="k">default</code> <code class="mi">5</code> <code class="o">*</code> <code class="mi">7</code><code class="p">;</code>
<code class="kr">export</code> <code class="k">default</code> <code class="p">{</code> <code class="nx">no</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">yes</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
</pre></div>

</figure>

<p>Each of these default exports has the following structure.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="err">&#xAB;</code><code class="nx">expression</code><code class="err">&#xBB;</code><code class="p">;</code>
</pre></div>

</figure>

<p>That is equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">__default__</code> <code class="o">=</code> <code class="err">&#xAB;</code><code class="nx">expression</code><code class="err">&#xBB;</code><code class="p">;</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">__default__</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code> <code class="c1">// (A)</code>
</pre></div>

</figure>

<p>The statement in line A is an <em>export clause</em> (which is explained in <a href="ch_modules.html#sec_all-exporting-styles">a later section</a>).</p>

<h6 id="_why-two-default-export-styles">
<span class="section-number">16.3.2.2.1 </span>Why two default export styles? <a class="header-anchor" href="ch_modules.html#_why-two-default-export-styles" aria-hidden="true">#</a></h6>

<p>The second default export style was introduced because variable declarations can&#x2019;t be meaningfully turned into default exports if they declare multiple variables:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">bar</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">baz</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code> <code class="c1">// not legal JavaScript!</code>
</pre></div>

</figure>

<p>Which one of the three variables <code>foo</code>, <code>bar</code> and <code>baz</code> would be the default export?</p>


<h4 id="_imports-and-exports-must-be-at-the-top-level">
<span class="section-number">16.3.3 </span>Imports and exports must be at the top level <a class="header-anchor" href="ch_modules.html#_imports-and-exports-must-be-at-the-top-level" aria-hidden="true">#</a></h4>

<p>As explained in more detail later, the structure of ES6 modules is <em>static</em>, you can&#x2019;t conditionally import or export things. That brings a variety of benefits.</p>

<p>This restriction is enforced syntactically by only allowing imports and exports at the top level of a module:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
    <code class="kr">import</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code> <code class="c1">// SyntaxError</code>
<code class="p">}</code>

<code class="c1">// You can&#x2019;t even nest `import` and `export`</code>
<code class="c1">// inside a simple block:</code>
<code class="p">{</code>
    <code class="kr">import</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code> <code class="c1">// SyntaxError</code>
<code class="p">}</code>
</pre></div>

</figure>


<h4 id="_imports-are-hoisted">
<span class="section-number">16.3.4 </span>Imports are hoisted <a class="header-anchor" href="ch_modules.html#_imports-are-hoisted" aria-hidden="true">#</a></h4>

<p>Module imports are hoisted (internally moved to the beginning of the current scope). Therefore, it doesn&#x2019;t matter where you mention them in a module and the following code works without any problems:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">foo</code><code class="p">();</code>

<code class="kr">import</code> <code class="p">{</code> <code class="nx">foo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;my_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>


<h4 id="_imports-are-read-only-views-on-exports">
<span class="section-number">16.3.5 </span>Imports are read-only views on exports <a class="header-anchor" href="ch_modules.html#_imports-are-read-only-views-on-exports" aria-hidden="true">#</a></h4>

<p>The imports of an ES6 module are read-only views on the exported entities. That means that the connections to variables declared inside module bodies remain live, as demonstrated in the following code.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">incCounter</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">counter</code><code class="p">,</code> <code class="nx">incCounter</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;./lib&apos;</code><code class="p">;</code>

<code class="c1">// The imported value `counter` is live</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="nx">incCounter</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</figure>

<p>How that works under the hood is explained <a href="ch_modules.html#sec_imports-as-views-on-exports">in a later section</a>.</p>

<p>Imports as views have the following advantages:</p>

<ul>
  <li>They enable cyclic dependencies, even for unqualified imports (as explained in the next section).</li>
  <li>Qualified and unqualified imports work the same way (they are both indirections).</li>
  <li>You can split code into multiple modules and it will continue to work (as long as you don&#x2019;t try to change the values of imports).</li>
</ul>


<h4 id="sec_cyclic-dependencies">
<span class="section-number">16.3.6 </span>Support for cyclic dependencies <a class="header-anchor" href="ch_modules.html#sec_cyclic-dependencies" aria-hidden="true">#</a></h4>

<p>Two modules A and B are <a href="http://en.wikipedia.org/wiki/Circular_dependency">cyclically dependent</a> on each other if both A (possibly indirectly/transitively) imports B and B imports A. If possible, cyclic dependencies should be avoided, they lead to A and B being <em>tightly coupled</em> &#x2013; they can only be used and evolved together.</p>

<p>Why support cyclic dependencies, then? Occasionally, you can&#x2019;t get around them, which is why support for them is an important feature. <a href="ch_modules.html#sec_rationale-cyclic-dependencies">A later section</a> has more information.</p>

<p>Let&#x2019;s see how CommonJS and ECMAScript 6 handle cyclic dependencies.</p>

<h5 id="sec_cyclic-dependencies-commonjs">
<span class="section-number">16.3.6.1 </span>Cyclic dependencies in CommonJS <a class="header-anchor" href="ch_modules.html#sec_cyclic-dependencies-commonjs" aria-hidden="true">#</a></h5>

<p>The following CommonJS code correctly handles two modules <code>a</code> and <code>b</code> cyclically depending on each other.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ a.js ------</code>
<code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;b&apos;</code><code class="p">);</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">b</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code>
<code class="p">}</code>
<code class="nx">exports</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">;</code>

<code class="c1">//------ b.js ------</code>
<code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">);</code> <code class="c1">// (i)</code>
<code class="kd">function</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code> <code class="c1">// (ii)</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="nx">exports</code><code class="p">.</code><code class="nx">bar</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">;</code>
</pre></div>

</figure>

<p>If module <code>a</code> is imported first then, in line i, module <code>b</code> gets <code>a</code>&#x2019;s exports object before the exports are added to it. Therefore, <code>b</code> cannot access <code>a.foo</code> in its top level, but that property exists once the execution of <code>a</code> is finished. If <code>bar()</code> is called afterwards then the method call in line ii works.</p>

<p>As a general rule, keep in mind that with cyclic dependencies, you can&#x2019;t access imports in the body of the module. That is inherent to the phenomenon and doesn&#x2019;t change with ECMAScript 6 modules.</p>

<p>The limitations of the CommonJS approach are:</p>

<ul>
  <li>Node.js-style single-value exports don&#x2019;t work. There, you export single values instead of objects:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">};</code>
</pre></div>

    </figure>

    <p>If module <code>a</code> did that then module <code>b</code>&#x2019;s variable <code>a</code> would not be updated once the assignment is made. It would continue to refer to the original exports object.</p>
  </li>
  <li>You can&#x2019;t use named exports directly. That is, module <code>b</code> can&#x2019;t import <code>foo</code> like this:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kd">var</code> <code class="nx">foo</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">).</code><code class="nx">foo</code><code class="p">;</code>
</pre></div>

    </figure>

    <p><code>foo</code> would simply be <code>undefined</code>. In other words, you have no choice but to refer to <code>foo</code> via <code>a.foo</code>.</p>
  </li>
</ul>

<p>These limitations mean that both exporter and importers must be aware of cyclic dependencies and support them explicitly.</p>

<h5 id="_cyclic-dependencies-in-ecmascript-6">
<span class="section-number">16.3.6.2 </span>Cyclic dependencies in ECMAScript 6 <a class="header-anchor" href="ch_modules.html#_cyclic-dependencies-in-ecmascript-6" aria-hidden="true">#</a></h5>

<p>ES6 modules support cyclic dependencies automatically. That is, they do not have the two limitations of CommonJS modules that were mentioned in the previous section: default exports work, as do unqualified named imports (lines i and iii in the following example). Therefore, you can implement modules that cyclically depend on each other as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ a.js ------</code>
<code class="kr">import</code> <code class="p">{</code><code class="nx">bar</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;b&apos;</code><code class="p">;</code> <code class="c1">// (i)</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">bar</code><code class="p">();</code> <code class="c1">// (ii)</code>
<code class="p">}</code>

<code class="c1">//------ b.js ------</code>
<code class="kr">import</code> <code class="p">{</code><code class="nx">foo</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code> <code class="c1">// (iii)</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
        <code class="nx">foo</code><code class="p">();</code> <code class="c1">// (iv)</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code works, because, as explained in the previous section, imports are views on exports. That means that even unqualified imports (such as <code>bar</code> in line ii and <code>foo</code> in line iv) are indirections that refer to the original data. Thus, in the face of cyclic dependencies, it doesn&#x2019;t matter whether you access a named export via an unqualified import or via its module: There is an indirection involved in either case and it always works.</p>


<h3 id="sec_importing-exporting-details">
<span class="section-number">16.4 </span>Importing and exporting in detail <a class="header-anchor" href="ch_modules.html#sec_importing-exporting-details" aria-hidden="true">#</a></h3>


<h4 id="_importing-styles">
<span class="section-number">16.4.1 </span>Importing styles <a class="header-anchor" href="ch_modules.html#_importing-styles" aria-hidden="true">#</a></h4>

<p>ECMAScript 6 provides several styles of importing<sup id="fnref-modules_1"><a href="leanpub-endnotes.html#fn-modules_1" rel="footnote">2</a></sup>:</p>

<ul>
  <li>Default import:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="nx">localName</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
  <li>Namespace import: imports the module as an object (with one property per named export).
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">my_lib</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
  <li>Named imports:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="p">{</code> <code class="nx">name1</code><code class="p">,</code> <code class="nx">name2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>

    <p>You can rename named imports:</p>

    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="c1">// Renaming: import `name1` as `localName1`</code>
  <code class="kr">import</code> <code class="p">{</code> <code class="nx">name1</code> <code class="nx">as</code> <code class="nx">localName1</code><code class="p">,</code> <code class="nx">name2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>

  <code class="c1">// Renaming: import the default export as `foo`</code>
  <code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">foo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
  <li>Empty import: only loads the module, doesn&#x2019;t import anything. The first such import in a program executes the body of the module.
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
</ul>

<p>There are only two ways to combine these styles and the order in which they appear is fixed; the default export always comes first.</p>

<ul>
  <li>Combining a default import with a namespace import:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="nx">theDefault</code><code class="p">,</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">my_lib</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
  <li>Combining a default import with named imports
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">import</code> <code class="nx">theDefault</code><code class="p">,</code> <code class="p">{</code> <code class="nx">name1</code><code class="p">,</code> <code class="nx">name2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/my_lib&apos;</code><code class="p">;</code>
</pre></div>

    </figure>
  </li>
</ul>


<h4 id="_named-exporting-styles-inline-versus-clause">
<span class="section-number">16.4.2 </span>Named exporting styles: inline versus clause <a class="header-anchor" href="ch_modules.html#_named-exporting-styles-inline-versus-clause" aria-hidden="true">#</a></h4>

<p>There are <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-exports">two ways</a> in which you can export named things inside modules.</p>

<p>On one hand, you can mark declarations with the keyword <code>export</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="kd">var</code> <code class="nx">myVar1</code> <code class="o">=</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">myVar2</code> <code class="o">=</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">;</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">MY_CONST</code> <code class="o">=</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">;</code>

<code class="kr">export</code> <code class="kd">function</code> <code class="nx">myFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">myGeneratorFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>On the other hand, you can list everything you want to export at the end of the module (which is similar in style to the revealing module pattern).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">MY_CONST</code> <code class="o">=</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">myFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">MY_CONST</code><code class="p">,</code> <code class="nx">myFunc</code> <code class="p">};</code>
</pre></div>

</figure>

<p>You can also export things under different names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="nx">MY_CONST</code> <code class="nx">as</code> <code class="nx">FOO</code><code class="p">,</code> <code class="nx">myFunc</code> <code class="p">};</code>
</pre></div>

</figure>


<h4 id="_re-exporting">
<span class="section-number">16.4.3 </span>Re-exporting <a class="header-anchor" href="ch_modules.html#_re-exporting" aria-hidden="true">#</a></h4>

<p>Re-exporting means adding another module&#x2019;s exports to those of the current module. You can either add all of the other module&#x2019;s exports:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="o">*</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<p>Default exports are ignored<sup id="fnref-modules_2"><a href="leanpub-endnotes.html#fn-modules_2" rel="footnote">3</a></sup> by <code>export *</code>.</p>

<p>Or you can be more selective (optionally while renaming):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>

<code class="c1">// Renaming: export other_module&#x2019;s foo as myFoo</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="nx">myFoo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<h5 id="_making-a-re-export-the-default-export">
<span class="section-number">16.4.3.1 </span>Making a re-export the default export <a class="header-anchor" href="ch_modules.html#_making-a-re-export-the-default-export" aria-hidden="true">#</a></h5>

<p>The following statement makes the default export of another module <code>foo</code> the default export of the current module:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<p>The following statement makes the named export <code>myFunc</code> of module <code>foo</code> the default export of the current module:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="nx">myFunc</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>
</pre></div>

</figure>


<h4 id="sec_all-exporting-styles">
<span class="section-number">16.4.4 </span>All exporting styles <a class="header-anchor" href="ch_modules.html#sec_all-exporting-styles" aria-hidden="true">#</a></h4>

<p>ECMAScript 6 provides several styles of exporting<sup id="fnref-modules_3"><a href="leanpub-endnotes.html#fn-modules_3" rel="footnote">4</a></sup>:</p>

<ul>
  <li>Re-exporting:
    <ul>
      <li>Re-export everything (except for the default export):
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="o">*</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
</pre></div>

        </figure>
      </li>
      <li>Re-export via a clause:
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="nx">myFoo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>

  <code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
  <code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">foo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
  <code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;src/other_module&apos;</code><code class="p">;</code>
</pre></div>

        </figure>
      </li>
    </ul>
  </li>
  <li>Named exporting via a clause:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="p">{</code> <code class="nx">MY_CONST</code> <code class="nx">as</code> <code class="nx">FOO</code><code class="p">,</code> <code class="nx">myFunc</code> <code class="p">};</code>
  <code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

    </figure>
  </li>
  <li>Inline named exports:
    <ul>
      <li>Variable declarations:
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="kd">var</code> <code class="nx">foo</code><code class="p">;</code>
  <code class="kr">export</code> <code class="kd">let</code> <code class="nx">foo</code><code class="p">;</code>
  <code class="kr">export</code> <code class="kr">const</code> <code class="nx">foo</code><code class="p">;</code>
</pre></div>

        </figure>
      </li>
      <li>Function declarations:
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">myFunc</code><code class="p">()</code> <code class="p">{}</code>
  <code class="kr">export</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">myGenFunc</code><code class="p">()</code> <code class="p">{}</code>
</pre></div>

        </figure>
      </li>
      <li>Class declarations:
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{}</code>
</pre></div>

        </figure>
      </li>
    </ul>
  </li>
  <li>Default export:
    <ul>
      <li>Function declarations (can be anonymous here):
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">myFunc</code><code class="p">()</code> <code class="p">{}</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{}</code>

  <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">myGenFunc</code><code class="p">()</code> <code class="p">{}</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{}</code>
</pre></div>

        </figure>
      </li>
      <li>Class declarations (can be anonymous here):
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{}</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="p">{}</code>
</pre></div>

        </figure>
      </li>
      <li>Expressions: export values. Note the semicolons at the end.
        <figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">export</code> <code class="k">default</code> <code class="nx">foo</code><code class="p">;</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="s1">&apos;Hello world!&apos;</code><code class="p">;</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="mi">3</code> <code class="o">*</code> <code class="mi">7</code><code class="p">;</code>
  <code class="kr">export</code> <code class="k">default</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{});</code>
</pre></div>

        </figure>
      </li>
    </ul>
  </li>
</ul>


<h4 id="sec_mixing-named-and-default-exports">
<span class="section-number">16.4.5 </span>Having both named exports and a default export in a module <a class="header-anchor" href="ch_modules.html#sec_mixing-named-and-default-exports" aria-hidden="true">#</a></h4>

<p>The following pattern is surprisingly common in JavaScript: A library is a single function, but additional services are provided via properties of that function. Examples include jQuery and Underscore.js. The following is a sketch of Underscore as a CommonJS module:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ underscore.js ------</code>
<code class="kd">var</code> <code class="nx">_</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">};</code>
<code class="kd">var</code> <code class="nx">each</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">each</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">forEach</code> <code class="o">=</code>
    <code class="kd">function</code> <code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>
        <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="p">};</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">_</code><code class="p">;</code>

<code class="c1">//------ main.js ------</code>
<code class="kd">var</code> <code class="nx">_</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;underscore&apos;</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">each</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">each</code><code class="p">;</code>
<code class="err">&#xB7;&#xB7;&#xB7;</code>
</pre></div>

</figure>

<p>With ES6 glasses, the function <code>_</code> is the default export, while <code>each</code> and <code>forEach</code> are named exports. As it turns out, you can actually have named exports and a default export at the same time. As an example, the previous CommonJS module, rewritten as an ES6 module, looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ underscore.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">each</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">each</code> <code class="nx">as</code> <code class="nx">forEach</code> <code class="p">};</code>

<code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="nx">_</code><code class="p">,</code> <code class="p">{</code> <code class="nx">each</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;underscore&apos;</code><code class="p">;</code>
<code class="err">&#xB7;&#xB7;&#xB7;</code>
</pre></div>

</figure>

<p>Note that the CommonJS version and the ECMAScript 6 version are only roughly similar. The latter has a flat structure, whereas the former is nested.</p>

<h5 id="_recommendation-avoid-mixing-default-exports-and-named-exports">
<span class="section-number">16.4.5.1 </span>Recommendation: avoid mixing default exports and named exports <a class="header-anchor" href="ch_modules.html#_recommendation-avoid-mixing-default-exports-and-named-exports" aria-hidden="true">#</a></h5>

<p>I generally recommend to keep the two kinds of exporting separate: per module, either only have a default export or only have named exports.</p>

<p>However, that is not a very strong recommendation; it occasionally may make sense to mix the two kinds. One example is a module that default-exports an entity. For unit tests, one could additionally make some of the internals available via named exports.</p>

<h5 id="_the-default-export-is-just-another-named-export">
<span class="section-number">16.4.5.2 </span>The default export is just another named export <a class="header-anchor" href="ch_modules.html#_the-default-export-is-just-another-named-export" aria-hidden="true">#</a></h5>

<p>The default export is actually just a named export with the special name <code>default</code>. That is, the following two statements are equivalent:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">foo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="kr">import</code> <code class="nx">foo</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<p>Similarly, the following two modules have the same default export:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ module1.js ------</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code> <code class="c1">// function declaration!</code>

<code class="c1">//------ module2.js ------</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<h5 id="_default-ok-as-export-name-but-not-as-variable-name">
<span class="section-number">16.4.5.3 </span><code>default</code>: OK as export name, but not as variable name <a class="header-anchor" href="ch_modules.html#_default-ok-as-export-name-but-not-as-variable-name" aria-hidden="true">#</a></h5>

<p>You can&#x2019;t use reserved words (such as <code>default</code> and <code>new</code>) as variable names, but you can use them as names for exports (you can also use them as property names in ECMAScript 5). If you want to directly import such named exports, you have to rename them to proper variables names.</p>

<p>That means that <code>default</code> can only appear on the left-hand side of a renaming import:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">foo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;some_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<p>And it can only appear on the right-hand side of a renaming export:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<p>In re-exporting, both sides of the <code>as</code> are export names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="p">{</code> <code class="nx">myFunc</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>
<code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">otherFunc</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>

<code class="c1">// The following two statements are equivalent:</code>
<code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>
<code class="kr">export</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;foo&apos;</code><code class="p">;</code>
</pre></div>

</figure>


<h3 id="sec_module-loader-api">
<span class="section-number">16.5 </span>The ECMAScript 6 module loader API <a class="header-anchor" href="ch_modules.html#sec_module-loader-api" aria-hidden="true">#</a></h3>

<p>In addition to the declarative syntax for working with modules, there is also a programmatic API. It allows you to:</p>

<ul>
  <li>Programmatically work with modules</li>
  <li>Configure module loading</li>
</ul>

<aside class="information blurb">
    <h3 id="_the-module-loader-api-is-not-part-of-the-es6-standard">The module loader API is not part of the ES6 standard <a class="header-anchor" href="ch_modules.html#_the-module-loader-api-is-not-part-of-the-es6-standard" aria-hidden="true">#</a></h3>

  <p>It will be specified in a separate document, the &#x201C;JavaScript Loader Standard&#x201D;, that will be evolved more dynamically than the language specification. <a href="https://github.com/whatwg/loader/">The repository for that document</a> states:</p>

  <blockquote>
    <p>[The JavaScript Loader Standard] consolidates work on the ECMAScript module loading semantics with the integration points of Web browsers, as well as Node.js.</p>
  </blockquote>

</aside>

<aside class="warning blurb">
    <h3 id="_the-module-loader-api-is-work-in-progress">The module loader API is work in progress <a class="header-anchor" href="ch_modules.html#_the-module-loader-api-is-work-in-progress" aria-hidden="true">#</a></h3>

  <p>As you can see in <a href="https://github.com/whatwg/loader/">the repository of the JavaScript Loader Standard</a>, the module loader API is still work in progress. Everything you read about it in this book is tentative. To get an impression of what the API may look like, you can take a look at <a href="https://github.com/ModuleLoader/es6-module-loader">the ES6 Module Loader Polyfill</a> on GitHub.</p>

</aside>

<h4 id="_loaders">
<span class="section-number">16.5.1 </span>Loaders <a class="header-anchor" href="ch_modules.html#_loaders" aria-hidden="true">#</a></h4>

<p>Loaders handle resolving <em>module specifiers</em> (the string IDs at the end of <code>import-from</code>), loading modules, etc. Their constructor is <code>Reflect.Loader</code>. Each platform keeps a default instance in the global variable <code>System</code> (the <em>system loader</em>), which implements its specific style of module loading.</p>

<h4 id="_loader-method-importing-modules">
<span class="section-number">16.5.2 </span>Loader method: importing modules <a class="header-anchor" href="ch_modules.html#_loader-method-importing-modules" aria-hidden="true">#</a></h4>

<p>You can programmatically import a module, via an API based on <a href="ch_promises.html#ch_promises">Promises</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">System</code><code class="p">.</code><code class="kr">import</code><code class="p">(</code><code class="s1">&apos;some_module&apos;</code><code class="p">)</code>
<code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">some_module</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// Use some_module</code>
<code class="p">})</code>
<code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p><code>System.import()</code> enables you to:</p>

<ul>
  <li>Use modules inside <code>&lt;script&gt;</code> elements (where module syntax is not supported, consult <a href="ch_modules.html#sec_modules-vs-scripts">the section on modules versus scripts</a> for details).</li>
  <li>Load modules conditionally.</li>
</ul>

<p><code>System.import()</code> retrieves a single module, you can use <code>Promise.all()</code> to import several modules:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code>
    <code class="p">[</code><code class="s1">&apos;module1&apos;</code><code class="p">,</code> <code class="s1">&apos;module2&apos;</code><code class="p">,</code> <code class="s1">&apos;module3&apos;</code><code class="p">]</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">System</code><code class="p">.</code><code class="kr">import</code><code class="p">(</code><code class="nx">x</code><code class="p">)))</code>
<code class="p">.</code><code class="nx">then</code><code class="p">(([</code><code class="nx">module1</code><code class="p">,</code> <code class="nx">module2</code><code class="p">,</code> <code class="nx">module3</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// Use module1, module2, module3</code>
<code class="p">});</code>
</pre></div>

</figure>

<h4 id="_more-loader-methods">
<span class="section-number">16.5.3 </span>More loader methods <a class="header-anchor" href="ch_modules.html#_more-loader-methods" aria-hidden="true">#</a></h4>

<p>Loaders have more methods. Three important ones are:</p>

<ul>
  <li>
<code>System.module(source, options?)</code><br>
evaluates the JavaScript code in <code>source</code> to a module (which is delivered asynchronously via a Promise).</li>
  <li>
<code>System.set(name, module)</code><br>
is for registering a module (e.g. one you have created via <code>System.module()</code>).</li>
  <li>
<code>System.define(name, source, options?)</code><br>
both evaluates the module code in <code>source</code> and registers the result.</li>
</ul>

<h4 id="_configuring-module-loading">
<span class="section-number">16.5.4 </span>Configuring module loading <a class="header-anchor" href="ch_modules.html#_configuring-module-loading" aria-hidden="true">#</a></h4>

<p>The module loader API will have various hooks for configuring the loading process. Use cases include:</p>

<ol class="numeric">
  <li>Lint modules on import (e.g. via JSLint or JSHint).</li>
  <li>Automatically translate modules on import (they could contain CoffeeScript or TypeScript code).</li>
  <li>Use legacy modules (AMD, Node.js).</li>
</ol>

<p>Configurable module loading is an area where Node.js and CommonJS are limited.</p>


<h3 id="sec_modules-in-browsers">
<span class="section-number">16.6 </span>Using ES6 modules in browsers <a class="header-anchor" href="ch_modules.html#sec_modules-in-browsers" aria-hidden="true">#</a></h3>

<p>Let&#x2019;s look at how ES6 modules are supported in browsers.</p>

<aside class="warning blurb">
    <h3 id="_support-for-es6-modules-in-browsers-is-work-in-progress">Support for ES6 modules in browsers is work in progress <a class="header-anchor" href="ch_modules.html#_support-for-es6-modules-in-browsers-is-work-in-progress" aria-hidden="true">#</a></h3>

  <p>Similarly to module loading, other aspects of support for modules in browsers are still being worked on. Everything you read here may change.</p>

</aside>


<h4 id="sec_modules-vs-scripts">
<span class="section-number">16.6.1 </span>Browsers: asynchronous modules versus synchronous scripts <a class="header-anchor" href="ch_modules.html#sec_modules-vs-scripts" aria-hidden="true">#</a></h4>

<p>In browsers, there are two different kinds of entities: scripts and modules. They have slightly different syntax and work differently.</p>

<p>This is an overview of the differences, details are explained later:</p>

<table>
  <thead>
    <tr>
      <th>&#xA0;</th>
      <th>Scripts</th>
      <th>Modules</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTML element</td>
      <td><code>&lt;script&gt;</code></td>
      <td><code>&lt;script type=&quot;module&quot;&gt;</code></td>
    </tr>
    <tr>
      <td>Default mode</td>
      <td>non-strict</td>
      <td>strict</td>
    </tr>
    <tr>
      <td>Top-level variables are</td>
      <td>global</td>
      <td>local to module</td>
    </tr>
    <tr>
      <td>Value of <code>this</code> at top level</td>
      <td><code>window</code></td>
      <td><code>undefined</code></td>
    </tr>
    <tr>
      <td>Executed</td>
      <td>synchronously</td>
      <td>asynchronously</td>
    </tr>
    <tr>
      <td>Declarative imports (<code>import</code> statement)</td>
      <td>no</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>Programmatic imports (Promise-based API)</td>
      <td>yes</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>File extension</td>
      <td><code>.js</code></td>
      <td><code>.js</code></td>
    </tr>
  </tbody>

</table>


<h5 id="_scripts">
<span class="section-number">16.6.1.1 </span>Scripts <a class="header-anchor" href="ch_modules.html#_scripts" aria-hidden="true">#</a></h5>

<p>Scripts are the traditional browser way to embed JavaScript and to refer to external JavaScript files. Scripts have an <a href="http://en.wikipedia.org/wiki/Internet_media_type">internet media type</a> that is used as:</p>

<ul>
  <li>The content type of JavaScript files delivered via a web server.</li>
  <li>The value of the attribute <code>type</code> of <code>&lt;script&gt;</code> elements. Note that for HTML5, the recommendation is to omit the <code>type</code> attribute in <code>&lt;script&gt;</code> elements if they contain or refer to JavaScript.</li>
</ul>

<p>The following are the most important values:</p>

<ul>
  <li>
<code>text/javascript</code>: is a legacy value and used as the default if you omit the <code>type</code> attribute in a script tag. It is <a href="http://stackoverflow.com/questions/359895/what-are-the-most-likely-causes-of-javascript-errors-in-ie8/703590#703590">the safest choice</a> for Internet Explorer 8 and earlier.</li>
  <li>
<code>application/javascript</code>: is <a href="http://tools.ietf.org/html/rfc4329#section-7">recommended</a> for current browsers.</li>
</ul>

<p>Scripts are normally loaded or executed synchronously. The JavaScript thread stops until the code has been loaded or executed.</p>

<h5 id="_modules">
<span class="section-number">16.6.1.2 </span>Modules <a class="header-anchor" href="ch_modules.html#_modules" aria-hidden="true">#</a></h5>

<p>To be in line with JavaScript&#x2019;s usual run-to-completion semantics, the body of a module must be executed without interruption. That leaves two options for importing modules:</p>

<ol class="numeric">
  <li>Load modules synchronously, while the body is executed. That is what Node.js does.</li>
  <li>Load all modules asynchronously, before the body is executed. That is how AMD modules are handled. It is the best option for browsers, because modules are loaded over the internet and execution doesn&#x2019;t have to pause while they are. As an added benefit, this approach allows one to load multiple modules in parallel.</li>
</ol>

<p>ECMAScript 6 gives you the best of both worlds: The synchronous syntax of Node.js plus the asynchronous loading of AMD. To make both possible, ES6 modules are syntactically less flexible than Node.js modules: Imports and exports must happen at the top level. That means that they can&#x2019;t be conditional, either. This restriction allows an ES6 module loader to analyze statically what modules are imported by a module and load them before executing its body.</p>

<p>The synchronous nature of scripts prevents them from becoming modules. Scripts cannot even import modules declaratively (you have to use the programmatic module loader API if you want to do so).</p>

<p>Modules can be used from browsers via a new variant of the <code>&lt;script&gt;</code> element that is completely asynchronous:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">&lt;</code><code class="nt">script</code> <code class="na">type</code><code class="o">=</code><code class="s">&quot;module&quot;</code><code class="p">&gt;</code>
    <code class="kr">import</code> <code class="nx">$</code> <code class="nx">from</code> <code class="s1">&apos;lib/jquery&apos;</code><code class="p">;</code>
    <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>

    <code class="c1">// The current scope is not global</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;$&apos;</code> <code class="k">in</code> <code class="nb">window</code><code class="p">);</code> <code class="c1">// false</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;x&apos;</code> <code class="k">in</code> <code class="nb">window</code><code class="p">);</code> <code class="c1">// false</code>

    <code class="c1">// `this` still refers to the global object</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code> <code class="o">===</code> <code class="nb">window</code><code class="p">);</code> <code class="c1">// true</code>
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>
</pre></div>

</figure>

<p>As you can see, the element has its own scope and variables &#x201C;inside&#x201D; it are local to that scope. Note that module code is implicitly in strict mode. This is great news &#x2013; no more <code>&apos;use strict&apos;</code>.</p>

<p>Similar to normal <code>&lt;script&gt;</code> elements, <code>&lt;script type=&quot;module&quot;&gt;</code> can also be used to load external modules. For example, the following tag starts a web application via a <code>main</code> module (the attribute name <code>import</code> is my invention, it isn&#x2019;t yet clear what name will be used).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">&lt;</code><code class="nt">script</code> <code class="na">type</code><code class="o">=</code><code class="s">&quot;module&quot;</code> <code class="na">import</code><code class="o">=</code><code class="s">&quot;impl/main&quot;</code><code class="p">&gt;&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>
</pre></div>

</figure>

<p>The advantage of supporting modules in HTML via a custom <code>&lt;script&gt;</code> type is that it is easy to bring that support to older engines via a polyfill (a library). There may or may not eventually be a dedicated element for modules (e.g. <code>&lt;module&gt;</code>).</p>

<h5 id="_module-or-script--a-matter-of-context">
<span class="section-number">16.6.1.3 </span>Module or script &#x2013; a matter of context <a class="header-anchor" href="ch_modules.html#_module-or-script--a-matter-of-context" aria-hidden="true">#</a></h5>

<p>Whether a file is a module or a script is only determined by how it is imported or loaded. Most modules have either imports or exports and can thus be detected. But if a module has neither then it is indistinguishable from a script. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
</pre></div>

</figure>

<p>The semantics of this piece of code differs depending on whether it is interpreted as a module or as a script:</p>

<ul>
  <li>As a module, the variable <code>x</code> is created in module scope.</li>
  <li>As a script, the variable <code>x</code> becomes a global variable and a property of the global object (<code>window</code> in browsers).</li>
</ul>

<p>More realistic example is a module that installs something, e.g. a polyfill in global variables or a global event listener. Such a module neither imports nor exports anything and is activated via an empty import:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="s1">&apos;./my_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<aside class="generic_inbar blurb external-link icon-external-link">
    <h3 id="_sources-of-this-section-1">Sources of this section <a class="header-anchor" href="ch_modules.html#_sources-of-this-section-1" aria-hidden="true">#</a></h3>

  <ul>
    <li>&#x201C;<a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/modules.pdf">Modules: Status Update</a>&#x201D;, slides by David Herman.</li>
    <li>&#x201C;<a href="https://mail.mozilla.org/pipermail/es-discuss/2013-November/034869.html">Modules vs Scripts</a>&#x201D;, an email by David Herman.</li>
  </ul>

</aside>


<h3 id="sec_imports-as-views-on-exports">
<span class="section-number">16.7 </span>Details: imports as views on exports <a class="header-anchor" href="ch_modules.html#sec_imports-as-views-on-exports" aria-hidden="true">#</a></h3>

<aside class="generic_inbar blurb github-alt icon-github-alt">
    <p>The code in this section is available <a href="https://github.com/rauschma/imports-are-views-demo">on GitHub</a>.</p>

</aside>

<p>Imports work differently in CommonJS and ES6:</p>

<ul>
  <li>In CommonJS, imports are copies of exported values.</li>
  <li>In ES6, imports are live read-only views on exported values.</li>
</ul>

<p>The following sections explain what that means.</p>

<h4 id="_in-commonjs-imports-are-copies-of-exported-values">
<span class="section-number">16.7.1 </span>In CommonJS, imports are copies of exported values <a class="header-anchor" href="ch_modules.html#_in-commonjs-imports-are-copies-of-exported-values" aria-hidden="true">#</a></h4>

<p>With CommonJS (Node.js) modules, things work in relatively familiar ways.</p>

<p>If you import a value into a variable, the value is copied twice: once when it is exported (line A) and once it is imported (line B).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kd">var</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">incCounter</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">counter</code><code class="o">:</code> <code class="nx">counter</code><code class="p">,</code> <code class="c1">// (A)</code>
    <code class="nx">incCounter</code><code class="o">:</code> <code class="nx">incCounter</code><code class="p">,</code>
<code class="p">};</code>

<code class="c1">//------ main1.js ------</code>
<code class="kd">var</code> <code class="nx">counter</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;./lib&apos;</code><code class="p">).</code><code class="nx">counter</code><code class="p">;</code> <code class="c1">// (B)</code>
<code class="kd">var</code> <code class="nx">incCounter</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;./lib&apos;</code><code class="p">).</code><code class="nx">incCounter</code><code class="p">;</code>

<code class="c1">// The imported value is a (disconnected) copy of a copy</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="nx">incCounter</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>

<code class="c1">// The imported value can be changed</code>
<code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</figure>

<p>If you access the value via the exports object, it is still copied once, on export:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ main2.js ------</code>
<code class="kd">var</code> <code class="nx">lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;./lib&apos;</code><code class="p">);</code>

<code class="c1">// The imported value is a (disconnected) copy</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">incCounter</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>

<code class="c1">// The imported value can be changed</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</figure>

<h4 id="_in-es6-imports-are-live-read-only-views-on-exported-values">
<span class="section-number">16.7.2 </span>In ES6, imports are live read-only views on exported values <a class="header-anchor" href="ch_modules.html#_in-es6-imports-are-live-read-only-views-on-exported-values" aria-hidden="true">#</a></h4>

<p>In contrast to CommonJS, imports are views on exported values. In other words, every import is a live connection to the exported data. Imports are read-only:</p>

<ul>
  <li>Unqualified imports (<code>import x from &apos;foo&apos;</code>) are like <code>const</code>-declared variables.</li>
  <li>The properties of a module object <code>foo</code> (<code>import * as foo from &apos;foo&apos;</code>) are like the properties of a <a href="http://speakingjs.com/es5/ch17.html#freezing_objects">frozen object</a>.</li>
</ul>

<p>The following code demonstrates how imports are like views:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">incCounter</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">//------ main1.js ------</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">counter</code><code class="p">,</code> <code class="nx">incCounter</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;./lib&apos;</code><code class="p">;</code>

<code class="c1">// The imported value `counter` is live</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="nx">incCounter</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 4</code>

<code class="c1">// The imported value can&#x2019;t be changed</code>
<code class="nx">counter</code><code class="o">++</code><code class="p">;</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<p>If you import the module object via the asterisk (<code>*</code>), you get the same results:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ main2.js ------</code>
<code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">lib</code> <code class="nx">from</code> <code class="s1">&apos;./lib&apos;</code><code class="p">;</code>

<code class="c1">// The imported value `counter` is live</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">incCounter</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="p">);</code> <code class="c1">// 4</code>

<code class="c1">// The imported value can&#x2019;t be changed</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">counter</code><code class="o">++</code><code class="p">;</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<p>Note that while you can&#x2019;t change the values of imports, you can change the objects that they are referring to. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//------ lib.js ------</code>
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>

<code class="c1">//------ main.js ------</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">obj</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;./lib&apos;</code><code class="p">;</code>

<code class="nx">obj</code><code class="p">.</code><code class="nx">prop</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// OK</code>
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<h5 id="_why-a-new-approach-to-importing">
<span class="section-number">16.7.2.1 </span>Why a new approach to importing? <a class="header-anchor" href="ch_modules.html#_why-a-new-approach-to-importing" aria-hidden="true">#</a></h5>

<p>Why introduce such a relatively complicated mechanism for importing that deviates from established practices?</p>

<ul>
  <li>Cyclic dependencies: The main advantage is that it supports <a href="ch_modules.html#sec_cyclic-dependencies">cyclic dependencies</a> even for unqualified imports.</li>
  <li>Qualified and unqualified imports work the same. In CommonJS, they don&#x2019;t: a qualified import provides direct access to a property of a module&#x2019;s export object, an unqualified import is a copy of it.</li>
  <li>You can split code into multiple modules and it will continue to work (as long as you don&#x2019;t try to change the values of imports).</li>
  <li>On the flip side, <em>module folding</em>, combining multiple modules into a single module becomes simpler, too.</li>
</ul>

<p>In my experience, ES6 imports just work, you rarely have to think about what&#x2019;s going on under the hood.</p>


<h4 id="_implementing-views">
<span class="section-number">16.7.3 </span>Implementing views <a class="header-anchor" href="ch_modules.html#_implementing-views" aria-hidden="true">#</a></h4>

<p>How do imports work as views of exports under the hood? Exports are managed via the data structure <em>export entry</em>. All export entries (except those for re-exports) have the following two names:</p>

<ul>
  <li>Local name: is the name under which the export is stored inside the module.</li>
  <li>Export name: is the name that importing modules need to use to access the export.</li>
</ul>

<p>After you have imported an entity, that entity is always accessed via a pointer that has the two components <em>module</em> and <em>local name</em>. In other words, that pointer refers to a <em>binding</em> (the storage space of a variable) inside a module.</p>

<p>Let&#x2019;s examine the export names and local names created by various kinds of exporting. The following table (<a href="http://www.ecma-international.org/ecma-262/6.0/#table-42">adapted from the ES6 spec</a>) gives an overview, subsequent sections have more details.</p>

<table>
  <thead>
    <tr>
      <th>Statement</th>
      <th>Local name</th>
      <th>Export name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>export {v};</code></td>
      <td><code>&apos;v&apos;</code></td>
      <td><code>&apos;v&apos;</code></td>
    </tr>
    <tr>
      <td><code>export {v as x};</code></td>
      <td><code>&apos;v&apos;</code></td>
      <td><code>&apos;x&apos;</code></td>
    </tr>
    <tr>
      <td><code>export const v = 123;</code></td>
      <td><code>&apos;v&apos;</code></td>
      <td><code>&apos;v&apos;</code></td>
    </tr>
    <tr>
      <td><code>export function f() {}</code></td>
      <td><code>&apos;f&apos;</code></td>
      <td><code>&apos;f&apos;</code></td>
    </tr>
    <tr>
      <td><code>export default function f() {}</code></td>
      <td><code>&apos;f&apos;</code></td>
      <td><code>&apos;default&apos;</code></td>
    </tr>
    <tr>
      <td><code>export default function () {}</code></td>
      <td><code>&apos;*default*&apos;</code></td>
      <td><code>&apos;default&apos;</code></td>
    </tr>
    <tr>
      <td><code>export default 123;</code></td>
      <td><code>&apos;*default*&apos;</code></td>
      <td><code>&apos;default&apos;</code></td>
    </tr>
  </tbody>

</table>

<h5 id="_export-clause">
<span class="section-number">16.7.3.1 </span>Export clause <a class="header-anchor" href="ch_modules.html#_export-clause" aria-hidden="true">#</a></h5>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="p">};</code>
</pre></div>

</figure>

<ul>
  <li>Local name: <code>foo</code>
</li>
  <li>Export name: <code>foo</code>
</li>
</ul>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="nx">bar</code> <code class="p">};</code>
</pre></div>

</figure>

<ul>
  <li>Local name: <code>foo</code>
</li>
  <li>Export name: <code>bar</code>
</li>
</ul>

<h5 id="_inline-exports">
<span class="section-number">16.7.3.2 </span>Inline exports <a class="header-anchor" href="ch_modules.html#_inline-exports" aria-hidden="true">#</a></h5>

<p>This is an inline export:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>It is equivalent to the following code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="p">};</code>
</pre></div>

</figure>

<p>Therefore, we have the following names:</p>

<ul>
  <li>Local name: <code>foo</code>
</li>
  <li>Export name: <code>foo</code>
</li>
</ul>

<h5 id="_default-exports-1">
<span class="section-number">16.7.3.3 </span>Default exports <a class="header-anchor" href="ch_modules.html#_default-exports-1" aria-hidden="true">#</a></h5>

<p>There are two kinds of default exports:</p>

<ul>
  <li>Default exports of <em>hoistable declarations</em> (function declarations, generator function declarations) and class declarations are similar to normal inline exports in that named local entities are created and tagged.</li>
  <li>All other default exports are about exporting the results of expressions.</li>
</ul>

<h6 id="_default-exporting-expressions">
<span class="section-number">16.7.3.3.1 </span>Default-exporting expressions <a class="header-anchor" href="ch_modules.html#_default-exporting-expressions" aria-hidden="true">#</a></h6>

<p>The following code default-exports the result of the expression <code>123</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="mi">123</code><code class="p">;</code>
</pre></div>

</figure>

<p>It is equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="o">*</code><code class="k">default</code><code class="o">*</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// *not* legal JavaScript</code>
<code class="kr">export</code> <code class="p">{</code> <code class="o">*</code><code class="k">default</code><code class="o">*</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<p>If you default-export an expression, you get:</p>

<ul>
  <li>Local name: <code>*default*</code>
</li>
  <li>Export name: <code>default</code>
</li>
</ul>

<p>The local name was chosen so that it wouldn&#x2019;t clash with any other local name.</p>

<p>Note that a default export still leads to a binding being created. But, due to <code>*default*</code> not being a legal identifier, you can&#x2019;t access that binding from inside the module.</p>

<h6 id="_default-exporting-hoistable-declarations-and-class-declarations">
<span class="section-number">16.7.3.3.2 </span>Default-exporting hoistable declarations and class declarations <a class="header-anchor" href="ch_modules.html#_default-exporting-hoistable-declarations-and-class-declarations" aria-hidden="true">#</a></h6>

<p>The following code default-exports a function declaration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>It is equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<p>The names are:</p>

<ul>
  <li>Local name: <code>foo</code>
</li>
  <li>Export name: <code>default</code>
</li>
</ul>

<p>That means that you can change the value of the default export from within the module, by assigning a different value to <code>foo</code>.</p>

<p>(Only) for default exports, you can also omit the name of a function declaration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>That is equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code><code class="k">default</code><code class="o">*</code><code class="p">()</code> <code class="p">{}</code> <code class="c1">// *not* legal JavaScript</code>
<code class="kr">export</code> <code class="p">{</code> <code class="o">*</code><code class="k">default</code><code class="o">*</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<p>The names are:</p>

<ul>
  <li>Local name: <code>*default*</code>
</li>
  <li>Export name: <code>default</code>
</li>
</ul>

<p>Default-exporting generator declarations and class declarations works similarly to default-exporting function declarations.</p>


<h4 id="_imports-as-views-in-the-spec">
<span class="section-number">16.7.4 </span>Imports as views in the spec <a class="header-anchor" href="ch_modules.html#_imports-as-views-in-the-spec" aria-hidden="true">#</a></h4>

<p>This section gives pointers into the ECMAScript 2015 (ES6) language specification.</p>

<p>Managing imports:</p>

<ul>
  <li>
<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-createimportbinding">CreateImportBinding()</a> creates local bindings for imports.</li>
  <li>
<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getbindingvalue-n-s">GetBindingValue()</a> is used to access them.</li>
  <li>
<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation">ModuleDeclarationInstantiation()</a> sets up the environment of a module (compare: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-functiondeclarationinstantiation">FunctionDeclarationInstantiation()</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-blockdeclarationinstantiation">BlockDeclarationInstantiation()</a>).</li>
</ul>

<p>The export names and local names created by the various kinds of exports are shown in <a href="http://www.ecma-international.org/ecma-262/6.0/#table-42">table 42</a> in the section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-source-text-module-records">Source Text Module Records</a>&#x201D;. The section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-exports-static-semantics-exportentries">Static Semantics: ExportEntries</a>&#x201D; has more details. You can see that export entries are set up statically (before evaluating the module), evaluating export statements is described in the section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-exports-runtime-semantics-evaluation">Runtime Semantics: Evaluation</a>&#x201D;.</p>


<h3 id="sec_design-goals-es6-modules">
<span class="section-number">16.8 </span>Design goals for ES6 modules <a class="header-anchor" href="ch_modules.html#sec_design-goals-es6-modules" aria-hidden="true">#</a></h3>

<p>If you want to make sense of ECMAScript 6 modules, it helps to understand what goals influenced their design. The major ones are:</p>

<ul>
  <li>Default exports are favored</li>
  <li>Static module structure</li>
  <li>Support for both synchronous and asynchronous loading</li>
  <li>Support for cyclic dependencies between modules</li>
</ul>

<p>The following subsections explain these goals.</p>


<h4 id="_default-exports-are-favored">
<span class="section-number">16.8.1 </span>Default exports are favored <a class="header-anchor" href="ch_modules.html#_default-exports-are-favored" aria-hidden="true">#</a></h4>

<p>The module syntax suggesting that the default export &#x201C;is&#x201D; the module may seem a bit strange, but it makes sense if you consider that one major design goal was to make default exports as convenient as possible. Quoting <a href="http://esdiscuss.org/topic/moduleimport#content-0">David Herman</a>:</p>

<blockquote>
  <p>ECMAScript 6 favors the single/default export style, and gives the sweetest syntax to importing the default. Importing named exports can and even should be slightly less concise.</p>
</blockquote>


<h4 id="static-module-structure">
<span class="section-number">16.8.2 </span>Static module structure <a class="header-anchor" href="ch_modules.html#static-module-structure" aria-hidden="true">#</a></h4>

<p>Current JavaScript module formats have a dynamic structure: What is imported and exported can change at runtime. One reason why ES6 introduced its own module format is to enable a static structure, which has several benefits. But before we go into those, let&#x2019;s examine what the structure being static means.</p>

<p>It means that you can determine imports and exports at compile time (statically) &#x2013; you only need to look at the source code, you don&#x2019;t have to execute it. ES6 enforces this syntactically: You can only import and export at the top level (never nested inside a conditional statement). And import and export statements have no dynamic parts (no variables etc. are allowed).</p>

<p>The following are two examples of CommonJS modules that don&#x2019;t have a static structure. In the first example, you have to run the code to find out what it imports:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">my_lib</code><code class="p">;</code>
<code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">my_lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;foo&apos;</code><code class="p">);</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">my_lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;bar&apos;</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In the second example, you have to run the code to find out what it exports:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">exports</code><code class="p">.</code><code class="nx">baz</code> <code class="o">=</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>ECMAScript 6 modules are less flexible and force you to be static. As a result, you get several benefits, which are described next.</p>

<h5 id="_benefit-dead-code-elimination-during-bundling">
<span class="section-number">16.8.2.1 </span>Benefit: dead code elimination during bundling <a class="header-anchor" href="ch_modules.html#_benefit-dead-code-elimination-during-bundling" aria-hidden="true">#</a></h5>

<p>In frontend development, modules are usually handled as follows:</p>

<ul>
  <li>During development, code exists as many, often small, modules.</li>
  <li>For deployment, these modules are <em>bundled</em> into a few, relatively large, files.</li>
</ul>

<p>The reasons for bundling are:</p>

<ol class="numeric">
  <li>Fewer files need to be retrieved in order to load all modules.</li>
  <li>Compressing the bundled file is slightly more efficient than compressing separate files.</li>
  <li>During bundling, unused exports can be removed, potentially resulting in significant space savings.</li>
</ol>

<p>Reason #1 is important for HTTP/1, where the cost for requesting a file is relatively high. That will change with HTTP/2, which is why this reason doesn&#x2019;t matter there.</p>

<p>Reason #3 will remain compelling. It can only be achieved with a module format that has a static structure.</p>

<h5 id="_benefit-compact-bundling-no-custom-bundle-format">
<span class="section-number">16.8.2.2 </span>Benefit: compact bundling, no custom bundle format <a class="header-anchor" href="ch_modules.html#_benefit-compact-bundling-no-custom-bundle-format" aria-hidden="true">#</a></h5>

<p><a href="https://github.com/rollup/rollup">The module bundler Rollup</a> proved that ES6 modules can be combined efficiently, because they all fit into a single scope (after renaming variables to eliminate name clashes). This is possible due to two characteristics of ES6 modules:</p>

<ul>
  <li>Their static structure means that the bundle format does not have to account for conditionally loaded modules (a common technique for doing so is putting module code in functions).</li>
  <li>Imports being read-only views on exports means that you don&#x2019;t have to copy exports, you can refer to them directly.</li>
</ul>

<p>As an example, consider the following two ES6 modules.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// lib.js</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{}</code>

<code class="c1">// main.js</code>
<code class="kr">import</code> <code class="p">{</code><code class="nx">foo</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;./lib.js&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">());</code>
</pre></div>

</figure>

<p>Rollup can bundle these two ES6 modules into the following single ES6 module (note the eliminated unused export <code>bar</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">());</code>
</pre></div>

</figure>

<p>Another benefit of Rollup&#x2019;s approach is that the bundle does not have a custom format, it is just an ES6 module.</p>

<h5 id="_benefit-faster-lookup-of-imports">
<span class="section-number">16.8.2.3 </span>Benefit: faster lookup of imports <a class="header-anchor" href="ch_modules.html#_benefit-faster-lookup-of-imports" aria-hidden="true">#</a></h5>

<p>If you require a library in CommonJS, you get back an object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;lib&apos;</code><code class="p">);</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">someFunc</code><code class="p">();</code> <code class="c1">// property lookup</code>
</pre></div>

</figure>

<p>Thus, accessing a named export via <code>lib.someFunc</code> means you have to do a property lookup, which is slow, because it is dynamic.</p>

<p>In contrast, if you import a library in ES6, you statically know its contents and can optimize accesses:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">lib</code> <code class="nx">from</code> <code class="s1">&apos;lib&apos;</code><code class="p">;</code>
<code class="nx">lib</code><code class="p">.</code><code class="nx">someFunc</code><code class="p">();</code> <code class="c1">// statically resolved</code>
</pre></div>

</figure>

<h5 id="_benefit-variable-checking">
<span class="section-number">16.8.2.4 </span>Benefit: variable checking <a class="header-anchor" href="ch_modules.html#_benefit-variable-checking" aria-hidden="true">#</a></h5>

<p>With a static module structure, you always statically know which variables are visible at any location inside the module:</p>

<ul>
  <li>Global variables: increasingly, the only completely global variables will come from the language proper. Everything else will come from modules (including functionality from the standard library and the browser). That is, you statically know all global variables.</li>
  <li>Module imports: You statically know those, too.</li>
  <li>Module-local variables: can be determined by statically examining the module.</li>
</ul>

<p>This helps tremendously with checking whether a given identifier has been spelled properly. This kind of check is a popular feature of linters such as JSLint and JSHint; in ECMAScript 6, most of it can be performed by JavaScript engines.</p>

<p>Additionally, any access of named imports (such as <code>lib.foo</code>) can also be checked statically.</p>

<h5 id="_benefit-ready-for-macros">
<span class="section-number">16.8.2.5 </span>Benefit: ready for macros <a class="header-anchor" href="ch_modules.html#_benefit-ready-for-macros" aria-hidden="true">#</a></h5>

<p>Macros are still on the roadmap for JavaScript&#x2019;s future. If a JavaScript engine supports macros, you can add new syntax to it via a library. <a href="http://sweetjs.org">Sweet.js</a> is an experimental macro system for JavaScript. The following is an example from the Sweet.js website: a macro for classes.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Define the macro</code>
<code class="nx">macro</code> <code class="kr">class</code> <code class="p">{</code>
    <code class="nx">rule</code> <code class="p">{</code>
        <code class="nx">$className</code> <code class="p">{</code>
                <code class="nx">constructor</code> <code class="nx">$cparams</code> <code class="nx">$cbody</code>
                <code class="nx">$</code><code class="p">(</code><code class="nx">$mname</code> <code class="nx">$mparams</code> <code class="nx">$mbody</code><code class="p">)</code> <code class="p">...</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kd">function</code> <code class="nx">$className</code> <code class="nx">$cparams</code> <code class="nx">$cbody</code>
        <code class="nx">$</code><code class="p">(</code><code class="nx">$className</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">$mname</code>
            <code class="o">=</code> <code class="kd">function</code> <code class="nx">$mname</code> <code class="nx">$mparams</code> <code class="nx">$mbody</code><code class="p">;</code> <code class="p">)</code> <code class="p">...</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Use the macro</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">say</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">+</code> <code class="s2">&quot; says: &quot;</code> <code class="o">+</code> <code class="nx">msg</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="kd">var</code> <code class="nx">bob</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">&quot;Bob&quot;</code><code class="p">);</code>
<code class="nx">bob</code><code class="p">.</code><code class="nx">say</code><code class="p">(</code><code class="s2">&quot;Macros are sweet!&quot;</code><code class="p">);</code>
</pre></div>

</figure>

<p>For macros, a JavaScript engine performs a preprocessing step before compilation: If a sequence of tokens in the token stream produced by the parser matches the pattern part of the macro, it is replaced by tokens generated via the body of macro. The preprocessing step only works if you are able to statically find macro definitions. Therefore, if you want to import macros via modules then they must have a static structure.</p>

<h5 id="_benefit-ready-for-types">
<span class="section-number">16.8.2.6 </span>Benefit: ready for types <a class="header-anchor" href="ch_modules.html#_benefit-ready-for-types" aria-hidden="true">#</a></h5>

<p>Static type checking imposes constraints similar to macros: it can only be done if type definitions can be found statically. Again, types can only be imported from modules if they have a static structure.</p>

<p>Types are appealing because they enable statically typed fast dialects of JavaScript in which performance-critical code can be written. One such dialect is <a href="http://lljs.org">Low-Level JavaScript</a> (LLJS).</p>

<h5 id="_benefit-supporting-other-languages">
<span class="section-number">16.8.2.7 </span>Benefit: supporting other languages <a class="header-anchor" href="ch_modules.html#_benefit-supporting-other-languages" aria-hidden="true">#</a></h5>

<p>If you want to support compiling languages with macros and static types to JavaScript then JavaScript&#x2019;s modules should have a static structure, for the reasons mentioned in the previous two sections.</p>

<h5 id="_source-of-this-section-1">
<span class="section-number">16.8.2.8 </span>Source of this section <a class="header-anchor" href="ch_modules.html#_source-of-this-section-1" aria-hidden="true">#</a></h5>

<ul>
  <li>&#x201C;<a href="http://calculist.org/blog/2012/06/29/static-module-resolution/">Static module resolution</a>&#x201D; by David Herman</li>
</ul>


<h4 id="_support-for-both-synchronous-and-asynchronous-loading">
<span class="section-number">16.8.3 </span>Support for both synchronous and asynchronous loading <a class="header-anchor" href="ch_modules.html#_support-for-both-synchronous-and-asynchronous-loading" aria-hidden="true">#</a></h4>

<p>ECMAScript 6 modules must work independently of whether the engine loads modules synchronously (e.g. on servers) or asynchronously (e.g. in browsers). Its syntax is well suited for synchronous loading, asynchronous loading is enabled by its static structure: Because you can statically determine all imports, you can load them before evaluating the body of the module (in a manner reminiscent of AMD modules).</p>


<h4 id="sec_rationale-cyclic-dependencies">
<span class="section-number">16.8.4 </span>Support for cyclic dependencies between modules <a class="header-anchor" href="ch_modules.html#sec_rationale-cyclic-dependencies" aria-hidden="true">#</a></h4>

<p>Support for cyclic dependencies was a key goal for ES6 modules. Here is why:</p>

<p>Cyclic dependencies are not inherently evil. Especially for objects, you sometimes even want this kind of dependency. For example, in some trees (such as DOM documents), parents refer to children and children refer back to parents. In libraries, you can usually avoid cyclic dependencies via careful design. In a large system, though, they can happen, especially during refactoring. Then it is very useful if a module system supports them, because the system doesn&#x2019;t break while you are refactoring.</p>

<p><a href="http://nodejs.org/api/modules.html#modules_cycles">The Node.js documentation acknowledges the importance of cyclic dependencies</a> and <a href="https://mail.mozilla.org/pipermail/es-discuss/2014-July/038250.html">Rob Sayre provides additional evidence</a>:</p>

<blockquote>
  <p>Data point: I once implemented a system like [ECMAScript 6 modules] for Firefox. I got <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=384168#c7">asked</a> for cyclic dependency support 3 weeks after shipping.</p>

  <p>That system that Alex Fritze invented and I worked on is not perfect, and the syntax isn&#x2019;t very pretty. But <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Using">it&#x2019;s still getting used</a> 7 years later, so it must have gotten something right.</p>
</blockquote>


<h3 id="sec_faq-modules">
<span class="section-number">16.9 </span>FAQ: modules <a class="header-anchor" href="ch_modules.html#sec_faq-modules" aria-hidden="true">#</a></h3>

<h4 id="_can-i-use-a-variable-to-specify-from-which-module-i-want-to-import">
<span class="section-number">16.9.1 </span>Can I use a variable to specify from which module I want to import? <a class="header-anchor" href="ch_modules.html#_can-i-use-a-variable-to-specify-from-which-module-i-want-to-import" aria-hidden="true">#</a></h4>

<p>The <code>import</code> statement is completely static: its module specifier is always fixed. If you want to dynamically determine what module to load, you need to use <a href="ch_modules.html#sec_module-loader-api">the programmatic loader API</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">moduleSpecifier</code> <code class="o">=</code> <code class="s1">&apos;module_&apos;</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">();</code>
<code class="nx">System</code><code class="p">.</code><code class="kr">import</code><code class="p">(</code><code class="nx">moduleSpecifier</code><code class="p">)</code>
<code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">the_module</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// Use the_module</code>
<code class="p">})</code>
</pre></div>

</figure>

<h4 id="_can-i-import-a-module-conditionally-or-on-demand">
<span class="section-number">16.9.2 </span>Can I import a module conditionally or on demand? <a class="header-anchor" href="ch_modules.html#_can-i-import-a-module-conditionally-or-on-demand" aria-hidden="true">#</a></h4>

<p>Import statements must always be at the top level of modules. That means that you can&#x2019;t nest them inside <code>if</code> statements, functions, etc. Therefore, you have to use <a href="ch_modules.html#sec_module-loader-api">the programmatic loader API</a> if you want to load a module conditionally or on demand:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">System</code><code class="p">.</code><code class="kr">import</code><code class="p">(</code><code class="s1">&apos;some_module&apos;</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">some_module</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// Use some_module</code>
    <code class="p">})</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_can-i-use-variables-in-an-import-statement">
<span class="section-number">16.9.3 </span>Can I use variables in an <code>import</code> statement? <a class="header-anchor" href="ch_modules.html#_can-i-use-variables-in-an-import-statement" aria-hidden="true">#</a></h4>

<p>No, you can&#x2019;t. Remember &#x2013; what is imported must not depend on anything that is computed at runtime. Therefore:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Illegal syntax:</code>
<code class="kr">import</code> <code class="nx">foo</code> <code class="nx">from</code> <code class="s1">&apos;some_module&apos;</code><code class="o">+</code><code class="nx">SUFFIX</code><code class="p">;</code>
</pre></div>

</figure>

<h4 id="_can-i-use-destructuring-in-an-import-statement">
<span class="section-number">16.9.4 </span>Can I use destructuring in an <code>import</code> statement? <a class="header-anchor" href="ch_modules.html#_can-i-use-destructuring-in-an-import-statement" aria-hidden="true">#</a></h4>

<p>No you can&#x2019;t. The <code>import</code> statement only looks like destructuring, but is completely different (static, imports are views, etc.).</p>

<p>Therefore, you can&#x2019;t do something like this in ES6:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Illegal syntax:</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">foo</code><code class="o">:</code> <code class="p">{</code> <code class="nx">bar</code> <code class="p">}</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;some_module&apos;</code><code class="p">;</code>
</pre></div>

</figure>

<h4 id="_are-named-exports-necessary-why-not-default-export-objects">
<span class="section-number">16.9.5 </span>Are named exports necessary? Why not default-export objects? <a class="header-anchor" href="ch_modules.html#_are-named-exports-necessary-why-not-default-export-objects" aria-hidden="true">#</a></h4>

<p>You may be wondering &#x2013; why do we need named exports if we could simply default-export objects (like in CommonJS)? The answer is that you can&#x2019;t enforce a static structure via objects and lose all of the associated advantages (which are explained <a href="ch_modules.html#static-module-structure">in this chapter</a>).</p>

<h4 id="_can-i-eval-the-code-of-module">
<span class="section-number">16.9.6 </span>Can I <code>eval()</code> the code of module? <a class="header-anchor" href="ch_modules.html#_can-i-eval-the-code-of-module" aria-hidden="true">#</a></h4>

<p>No, you can&#x2019;t. Modules are too high-level a construct for <code>eval()</code>. The <a href="ch_modules.html#sec_module-loader-api">module loader API</a> provides the means for creating modules from strings. Syntactically, <code>eval()</code> accepts scripts (which don&#x2019;t allow <code>import</code> and <code>export</code>), not modules.</p>


<h3 id="sec_advantages-es6-modules">
<span class="section-number">16.10 </span>Advantages of ECMAScript 6 modules <a class="header-anchor" href="ch_modules.html#sec_advantages-es6-modules" aria-hidden="true">#</a></h3>

<p>At first glance, having modules built into ECMAScript 6 may seem like a boring feature &#x2013; after all, we already have several good module systems. But ECMAScript 6 modules have several new features:</p>

<ul>
  <li>More compact syntax</li>
  <li>Static module structure (helping with dead code elimination, optimizations, static checking and more)</li>
  <li>Automatic support for cyclic dependencies</li>
</ul>

<p>ES6 modules will also &#x2013; hopefully &#x2013; end the fragmentation between the currently dominant standards CommonJS and AMD. Having a single, native standard for modules means:</p>

<ul>
  <li>No more UMD (<a href="https://github.com/umdjs/umd">Universal Module Definition</a>): UMD is a name for patterns that enable the same file to be used by several module systems (e.g. both CommonJS and AMD). Once ES6 is the only module standard, UMD becomes obsolete.</li>
  <li>New browser APIs become modules instead of global variables or properties of <code>navigator</code>.</li>
  <li>No more objects-as-namespaces: Objects such as <code>Math</code> and <code>JSON</code> serve as namespaces for functions in ECMAScript 5. In the future, such functionality can be provided via modules.</li>
</ul>


<h3 id="sec_further-reading-modules">
<span class="section-number">16.11 </span>Further reading <a class="header-anchor" href="ch_modules.html#sec_further-reading-modules" aria-hidden="true">#</a></h3>

<ul>
  <li>
<strong>CommonJS versus ES6:</strong> &#x201C;<a href="http://jsmodules.io/">JavaScript Modules</a>&#x201D; (by <a href="https://github.com/wycats/jsmodules">Yehuda Katz</a>) is a quick intro to ECMAScript 6 modules. Especially interesting is a <a href="http://jsmodules.io/cjs.html">second page</a> where CommonJS modules are shown side by side with their ECMAScript 6 versions.</li>
</ul>






<div class="next-chapter">
    Next: <a href="pt_collections.html">IV Collections</a>
</div>


</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59555947-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
