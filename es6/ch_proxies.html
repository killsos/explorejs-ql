<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>28. Metaprogramming with proxies</title>
    <link href="stylesheet.css" type="text/css" rel="stylesheet" />
    <link rel="icon" href="images/favicon-128.png" sizes="128x128">
    <link rel="icon" href="images/favicon-32.png" sizes="32x32">
    <link rel="icon" href="images/favicon-16.png" sizes="16x16">
</head>
<body>

<div id="top-bar">
</div>
<div id="top-bar">
    <div id="top-bar-content">
        <b>28. Metaprogramming with proxies</b><br>
        <a href="index.html#toc_ch_proxies">Table of contents</a><br>
        Please support this book:
        <a href="https://leanpub.com/exploring-es6/">buy it (PDF, EPUB, MOBI)</a>
        or
        <a href="http://www.2ality.com/p/donate.html">donate</a>
    </div>
</div>

<div id="adbox">
<div id="adbox-explain">(Ad, please donâ€™t block.)</div>

    <script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=exploringjscom" id="_carbonads_js"></script>

</div>

<div id="page-content">


<h2 id="ch_proxies">
<span class="section-number">28. </span>Metaprogramming with proxies <a class="header-anchor" href="ch_proxies.html#ch_proxies" aria-hidden="true">#</a></h2>

<hr class="scene-break">

<ul>
  <li>28.1. <a href="ch_proxies.html#sec_overview-proxies">Overview</a>
</li>
  <li>28.2. <a href="ch_proxies.html#sec_programming-vs-metaprogramming">Programming versus metaprogramming</a>
    <ul>
      <li>28.2.1. Kinds of metaprogramming</li>
    </ul>
  </li>
  <li>28.3. <a href="ch_proxies.html#sec_proxies-explained">Proxies explained</a>
    <ul>
      <li>28.3.1. Function-specific traps</li>
      <li>28.3.2. Intercepting method calls</li>
      <li>28.3.3. Revocable proxies</li>
      <li>28.3.4. Proxies as prototypes</li>
      <li>28.3.5. Forwarding intercepted operations</li>
      <li>28.3.6. Pitfall: not all objects can be wrapped transparently by proxies</li>
    </ul>
  </li>
  <li>28.4. <a href="ch_proxies.html#sec_proxy-use-cases">Use cases for proxies</a>
    <ul>
      <li>28.4.1. Tracing property accesses (<code>get</code>, <code>set</code>)</li>
      <li>28.4.2. Warning about unknown properties (<code>get</code>, <code>set</code>)</li>
      <li>28.4.3. Negative Array indices (<code>get</code>)</li>
      <li>28.4.4. Data binding (<code>set</code>)</li>
      <li>28.4.5. Accessing a restful web service (method calls)</li>
      <li>28.4.6. Revocable references</li>
      <li>28.4.7. Implementing the DOM in JavaScript</li>
      <li>28.4.8. Other use cases</li>
    </ul>
  </li>
  <li>28.5. <a href="ch_proxies.html#sec_design-proxy-api">The design of the proxy API</a>
    <ul>
      <li>28.5.1. Stratification: keeping base level and meta level separate</li>
      <li>28.5.2. Virtual objects versus wrappers</li>
      <li>28.5.3. Transparent virtualization and handler encapsulation</li>
      <li>28.5.4. The meta object protocol and proxy traps</li>
      <li>28.5.5. Enforcing invariants for proxies</li>
    </ul>
  </li>
  <li>28.6. <a href="ch_proxies.html#sec_faq-proxies">FAQ: proxies</a>
    <ul>
      <li>28.6.1. Where is the <code>enumerate</code> trap?</li>
      <li>28.6.2. Operations that affect the prototype chain</li>
      <li>28.6.3. Reflect</li>
    </ul>
  </li>
  <li>28.7. <a href="ch_proxies.html#sec_reference-proxy-api">Reference: the proxy API</a>
    <ul>
      <li>28.7.1. Creating proxies</li>
      <li>28.7.2. Handler methods</li>
      <li>28.7.3. Invariants of handler methods</li>
      <li>28.7.4. Operations that affect the prototype chain</li>
      <li>28.7.5. Reflect</li>
    </ul>
  </li>
  <li>28.8. <a href="ch_proxies.html#sec_conclusion-proxies">Conclusion</a>
</li>
  <li>28.9. <a href="ch_proxies.html#sec_further-reading-proxies">Further reading</a>
</li>
</ul>

<hr class="scene-break">


<h3 id="sec_overview-proxies">
<span class="section-number">28.1 </span>Overview <a class="header-anchor" href="ch_proxies.html#sec_overview-proxies" aria-hidden="true">#</a></h3>

<p>Proxies enable you to intercept and customize operations performed on objects (such as getting properties). They are a <em>metaprogramming</em> feature.</p>

<p>In the following example, <code>proxy</code> is the object whose operations we are intercepting and <code>handler</code> is the object that handles the interceptions. In this case, we are only intercepting a single operation, <code>get</code> (getting properties).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;get &apos;</code> <code class="o">+</code> <code class="nx">propKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="mi">123</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
</pre></div>

</figure>

<p>When we get the property <code>proxy.foo</code>, the handler intercepts that operation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.foo
get foo
123
</pre></div>

</figure>

<p>Consult <a href="ch_proxies.html#sec_reference-proxy-api">the reference for the complete API</a> for a list of operations that can be intercepted.</p>


<h3 id="sec_programming-vs-metaprogramming">
<span class="section-number">28.2 </span>Programming versus metaprogramming <a class="header-anchor" href="ch_proxies.html#sec_programming-vs-metaprogramming" aria-hidden="true">#</a></h3>

<p>Before we can get into what proxies are and why they are useful, we first need to understand what <em>metaprogramming</em> is.</p>

<p>In programming, there are levels:</p>

<ul>
  <li>At the <em>base level</em> (also called: <em>application level</em>), code processes user input.</li>
  <li>At the <em>meta level</em>, code processes base level code.</li>
</ul>

<p>Base and meta level can be different languages. In the following meta program, the metaprogramming language is JavaScript and the base programming language is Java.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">&apos;Hello&apos;</code> <code class="o">+</code> <code class="s1">&apos;!&apos;</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;System.out.println(&quot;&apos;</code><code class="o">+</code><code class="nx">str</code><code class="o">+</code><code class="s1">&apos;&quot;)&apos;</code><code class="p">);</code>
</pre></div>

</figure>

<p>Metaprogramming can take different forms. In the previous example, we have printed Java code to the console. Let&#x2019;s use JavaScript as both metaprogramming language and base programming language. The classic example for this is the <a href="http://speakingjs.com/es5/ch23.html#_dynamically_evaluating_javascript_code_via_eval_and_new_function"><code>eval()</code> function</a>, which lets you evaluate/compile JavaScript code on the fly. There are <a href="http://speakingjs.com/es5/ch23.html#_legitimate_use_cases">not that many actual use cases</a> for <code>eval()</code>. In the interaction below, we use it to evaluate the expression <code>5 + 2</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; eval(&apos;5 + 2&apos;)
7
</pre></div>

</figure>

<p>Other JavaScript operations may not look like metaprogramming, but actually are, if you look closer:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Base level</code>
<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">hello</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Hello!&apos;</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// Meta level</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">key</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">obj</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The program is examining its own structure while running. This doesn&#x2019;t look like metaprogramming, because the separation between programming constructs and data structures is fuzzy in JavaScript. All of the <a href="http://speakingjs.com/es5/ch17.html#oop_cheat_sheet"><code>Object.*</code> methods</a> can be considered metaprogramming functionality.</p>


<h4 id="_kinds-of-metaprogramming">
<span class="section-number">28.2.1 </span>Kinds of metaprogramming <a class="header-anchor" href="ch_proxies.html#_kinds-of-metaprogramming" aria-hidden="true">#</a></h4>

<p>Reflective metaprogramming means that a program processes itself.
<a href="ch_proxies.html#ch_proxies_ref_2">Kiczales et al. [2]</a> distinguish three kinds of reflective metaprogramming:</p>

<ul>
  <li>
<strong>Introspection:</strong> you have read-only access to the structure of a program.</li>
  <li>
<strong>Self-modification:</strong> you can change that structure.</li>
  <li>
<strong>Intercession:</strong> you can redefine the semantics of some language operations.</li>
</ul>

<p>Let&#x2019;s look at examples.</p>

<p><strong>Example: introspection.</strong> <code>Object.keys()</code> performs introspection (see previous example).</p>

<p><strong>Example: self-modification.</strong> The following function <code>moveProperty</code> moves a property from a source to a target. It performs self-modification via the bracket operator for property access, the assignment operator and the <code>delete</code> operator. (In production code, you&#x2019;d probably use <a href="http://speakingjs.com/es5/ch17.html#property_attributes">property descriptors</a> for this task.)</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">moveProperty</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="nx">propertyName</code><code class="p">,</code> <code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">target</code><code class="p">[</code><code class="nx">propertyName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">source</code><code class="p">[</code><code class="nx">propertyName</code><code class="p">];</code>
    <code class="k">delete</code> <code class="nx">source</code><code class="p">[</code><code class="nx">propertyName</code><code class="p">];</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Using <code>moveProperty()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="kr">const</code> <code class="nx">obj1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">prop</code><code class="o">:</code> <code class="s1">&apos;abc&apos;</code> <code class="p">};</code>
<code class="o">&gt;</code> <code class="kr">const</code> <code class="nx">obj2</code> <code class="o">=</code> <code class="p">{};</code>
<code class="o">&gt;</code> <code class="nx">moveProperty</code><code class="p">(</code><code class="nx">obj1</code><code class="p">,</code> <code class="s1">&apos;prop&apos;</code><code class="p">,</code> <code class="nx">obj2</code><code class="p">);</code>

<code class="o">&gt;</code> <code class="nx">obj1</code>
<code class="p">{}</code>
<code class="o">&gt;</code> <code class="nx">obj2</code>
<code class="p">{</code> <code class="nx">prop</code><code class="o">:</code> <code class="s1">&apos;abc&apos;</code> <code class="p">}</code>
</pre></div>

</figure>

<p>ECMAScript 5 doesn&#x2019;t support intercession; proxies were created to fill that gap.</p>


<h3 id="sec_proxies-explained">
<span class="section-number">28.3 </span>Proxies explained <a class="header-anchor" href="ch_proxies.html#sec_proxies-explained" aria-hidden="true">#</a></h3>

<p>ECMAScript 6 proxies bring intercession to JavaScript. They work as follows. There are many operations that you can perform on an object <code>obj</code>. For example:</p>

<ul>
  <li>Getting the property <code>prop</code> of an object <code>obj</code> (<code>obj.prop</code>)</li>
  <li>Checking whether an object <code>obj</code> has a property <code>prop</code> (<code>&apos;prop&apos; in obj</code>)</li>
</ul>

<p>Proxies are special objects that allow you customize some of these operations. A proxy is created with two parameters:</p>

<ul>
  <li>
<code>handler</code>: For each operation, there is a corresponding handler method that &#x2013; if present &#x2013; performs that operation. Such a method <em>intercepts</em> the operation (on its way to the target) and is called a <em>trap</em> (a term borrowed from the domain of operating systems).</li>
  <li>
<code>target</code>: If the handler doesn&#x2019;t intercept an operation then it is performed on the target. That is, it acts as a fallback for the handler. In a way, the proxy wraps the target.</li>
</ul>

<p>In the following example, the handler intercepts the operations <code>get</code> and <code>has</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="cm">/** Intercepts: getting properties */</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`GET </code><code class="si">${</code><code class="nx">propKey</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="k">return</code> <code class="mi">123</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="cm">/** Intercepts: checking whether properties exist */</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`HAS </code><code class="si">${</code><code class="nx">propKey</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
</pre></div>

</figure>

<p>When we get property <code>foo</code>, the handler intercepts that operation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.foo
GET foo
123
</pre></div>

</figure>

<p>Similarly, the <code>in</code> operator triggers <code>has</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; &apos;hello&apos; in proxy
HAS hello
true
</pre></div>

</figure>

<p>The handler doesn&#x2019;t implement the trap <code>set</code> (setting properties). Therefore, setting <code>proxy.bar</code> is forwarded to <code>target</code> and leads to <code>target.bar</code> being set.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.bar = &apos;abc&apos;;
&gt; target.bar
&apos;abc&apos;
</pre></div>

</figure>


<h4 id="_function-specific-traps">
<span class="section-number">28.3.1 </span>Function-specific traps <a class="header-anchor" href="ch_proxies.html#_function-specific-traps" aria-hidden="true">#</a></h4>

<p>If the target is a function, two additional operations can be intercepted:</p>

<ul>
  <li>
<code>apply</code>: Making a function call, triggered via
    <ul>
      <li><code>proxy(&#xB7;&#xB7;&#xB7;)</code></li>
      <li><code>proxy.call(&#xB7;&#xB7;&#xB7;)</code></li>
      <li><code>proxy.apply(&#xB7;&#xB7;&#xB7;)</code></li>
    </ul>
  </li>
  <li>
<code>construct</code>: Making a constructor call, triggered via
    <ul>
      <li><code>new proxy(&#xB7;&#xB7;&#xB7;)</code></li>
    </ul>
  </li>
</ul>

<p>The reason for only enabling these traps for function targets is simple: You wouldn&#x2019;t be able to forward the operations <code>apply</code> and <code>construct</code>, otherwise.</p>


<h4 id="_intercepting-method-calls">
<span class="section-number">28.3.2 </span>Intercepting method calls <a class="header-anchor" href="ch_proxies.html#_intercepting-method-calls" aria-hidden="true">#</a></h4>

<p>If you want to intercept method calls via a proxy, there is one challenge: you can intercept the operation <code>get</code> (getting property values) and you can intercept the operation <code>apply</code> (calling a function), but there is no single operation for method calls that you could intercept. That&#x2019;s because method calls are viewed as two separate operations: First a <code>get</code> to retrieve a function, then an <code>apply</code> to call that function.</p>

<p>Therefore, you must intercept <code>get</code> and return a function that intercepts the function call. The following code demonstrates how that is done.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">traceMethodCalls</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">origMethod</code> <code class="o">=</code> <code class="nx">target</code><code class="p">[</code><code class="nx">propKey</code><code class="p">];</code>
            <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">origMethod</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">propKey</code> <code class="o">+</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">args</code><code class="p">)</code>
                    <code class="o">+</code> <code class="s1">&apos; -&gt; &apos;</code> <code class="o">+</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">result</code><code class="p">));</code>
                <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
            <code class="p">};</code>
        <code class="p">}</code>
    <code class="p">};</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>I&#x2019;m not using a Proxy for the latter task, I&#x2019;m simply wrapping the original method with a function.</p>

<p>Let&#x2019;s use the following object to try out <code>traceMethodCalls()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">multiply</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">squared</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">multiply</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>
    <code class="p">},</code>
<code class="p">};</code>
</pre></div>

</figure>

<p><code>tracedObj</code> is a traced version of <code>obj</code>. The first line after each method call is the output of <code>console.log()</code>, the second line is the result of the method call.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const tracedObj = traceMethodCalls(obj);
&gt; tracedObj.multiply(2,7)
multiply[2,7] -&gt; 14
14
&gt; tracedObj.squared(9)
multiply[9,9] -&gt; 81
squared[9] -&gt; 81
81
</pre></div>

</figure>

<p>The nice thing is that even the call <code>this.multiply()</code> that is made inside <code>obj.squared()</code> is traced. That&#x2019;s because <code>this</code> keeps referring to the proxy.</p>

<p>This is not the most efficient solution. One could, for example, cache methods. Furthermore, Proxies themselves have an impact on performance.</p>


<h4 id="_revocable-proxies">
<span class="section-number">28.3.3 </span>Revocable proxies <a class="header-anchor" href="ch_proxies.html#_revocable-proxies" aria-hidden="true">#</a></h4>

<p>ECMAScript 6 lets you create proxies that can be <em>revoked</em> (switched off):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">{</code><code class="nx">proxy</code><code class="p">,</code> <code class="nx">revoke</code><code class="p">}</code> <code class="o">=</code> <code class="nb">Proxy</code><code class="p">.</code><code class="nx">revocable</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
</pre></div>

</figure>

<p>On the left hand side of the assignment operator (<code>=</code>), we are using destructuring to access the properties <code>proxy</code> and <code>revoke</code> of the object returned by <code>Proxy.revocable()</code>.</p>

<p>After you call the function <code>revoke</code> for the first time, any operation you apply to <code>proxy</code> causes a <code>TypeError</code>. Subsequent calls of <code>revoke</code> have no further effect.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// Start with an empty object</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// Don&#x2019;t intercept anything</code>
<code class="kr">const</code> <code class="p">{</code><code class="nx">proxy</code><code class="p">,</code> <code class="nx">revoke</code><code class="p">}</code> <code class="o">=</code> <code class="nb">Proxy</code><code class="p">.</code><code class="nx">revocable</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>

<code class="nx">proxy</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">proxy</code><code class="p">.</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// 123</code>

<code class="nx">revoke</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">proxy</code><code class="p">.</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// TypeError: Revoked</code>
</pre></div>

</figure>


<h4 id="_proxies-as-prototypes">
<span class="section-number">28.3.4 </span>Proxies as prototypes <a class="header-anchor" href="ch_proxies.html#_proxies-as-prototypes" aria-hidden="true">#</a></h4>

<p>A proxy <code>proto</code> can become the prototype of an object <code>obj</code>. Some operations that begin in <code>obj</code> may continue in <code>proto</code>. One such operation is <code>get</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">proto</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propertyKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;GET &apos;</code><code class="o">+</code><code class="nx">propertyKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">target</code><code class="p">[</code><code class="nx">propertyKey</code><code class="p">];</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">proto</code><code class="p">);</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">bla</code><code class="p">;</code>

<code class="c1">// Output:</code>
<code class="c1">// GET bla</code>
</pre></div>

</figure>

<p>The property <code>bla</code> can&#x2019;t be found in <code>obj</code>, which is why the search continues in <code>proto</code> and the trap <code>get</code> is triggered there. There are more operations that affect prototypes; they are listed at the end of this chapter.</p>


<h4 id="sec_forwarding-intercepted-operations">
<span class="section-number">28.3.5 </span>Forwarding intercepted operations <a class="header-anchor" href="ch_proxies.html#sec_forwarding-intercepted-operations" aria-hidden="true">#</a></h4>

<p>Operations whose traps the handler doesn&#x2019;t implement are automatically forwarded to the target. Sometimes there is some task you want to perform in addition to forwarding the operation. For example, a handler that intercepts all operations and logs them, but doesn&#x2019;t prevent them from reaching the target:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">deleteProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;DELETE &apos;</code> <code class="o">+</code> <code class="nx">propKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="k">delete</code> <code class="nx">target</code><code class="p">[</code><code class="nx">propKey</code><code class="p">];</code>
    <code class="p">},</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;HAS &apos;</code> <code class="o">+</code> <code class="nx">propKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">propKey</code> <code class="k">in</code> <code class="nx">target</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="c1">// Other traps: similar</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>For each trap, we first log the name of the operation and then forward it by performing it manually. ECMAScript 6 has the module-like object <code>Reflect</code> that helps with forwarding: for each trap</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">handler</code><code class="p">.</code><code class="nx">trap</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">arg_1</code><code class="p">,</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">,</code> <code class="nx">arg_n</code><code class="p">)</code>
</pre></div>

</figure>

<p><code>Reflect</code> has a method</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Reflect</code><code class="p">.</code><code class="nx">trap</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">arg_1</code><code class="p">,</code> <code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">,</code> <code class="nx">arg_n</code><code class="p">)</code>
</pre></div>

</figure>

<p>If we use <code>Reflect</code>, the previous example looks as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">deleteProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;DELETE &apos;</code> <code class="o">+</code> <code class="nx">propKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">deleteProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;HAS &apos;</code> <code class="o">+</code> <code class="nx">propKey</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="c1">// Other traps: similar</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Now what each of the traps does is so similar that we can implement the handler via a proxy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">trapName</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Return the handler method named trapName</code>
        <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Don&#x2019;t log args[0]</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">trapName</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="o">+</code><code class="s1">&apos; &apos;</code><code class="o">+</code><code class="nx">args</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>
            <code class="c1">// Forward the operation</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">[</code><code class="nx">trapName</code><code class="p">](...</code><code class="nx">args</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>For each trap, the proxy asks for a handler method via the <code>get</code> operation and we give it one. That is, all of the handler methods can be implemented via the single meta method <code>get</code>. It was one of the goals for the proxy API to make this kind of virtualization simple.</p>

<p>Let&#x2019;s use this proxy-based handler:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="k">const</code> <code class="n">target</code> <code class="o">=</code> <code class="p">{};</code>
<code class="o">&gt;</code> <code class="k">const</code> <code class="n">proxy</code> <code class="o">=</code> <code class="n">new</code> <code class="n">Proxy</code><code class="p">(</code><code class="n">target</code><code class="p">,</code> <code class="n">handler</code><code class="p">);</code>
<code class="o">&gt;</code> <code class="n">proxy</code><code class="p">.</code><code class="n">foo</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="n">SET</code> <code class="n">foo</code><code class="p">,</code><code class="mi">123</code><code class="p">,[</code><code class="n">object</code> <code class="n">Object</code><code class="p">]</code>
<code class="o">&gt;</code> <code class="n">proxy</code><code class="p">.</code><code class="n">foo</code>
<code class="n">GET</code> <code class="n">foo</code><code class="p">,[</code><code class="n">object</code> <code class="n">Object</code><code class="p">]</code>
<code class="mi">123</code>
</pre></div>

</figure>

<p>The following interaction confirms that the <code>set</code> operation was correctly forwarded to the target:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; target.foo
123
</pre></div>

</figure>


<h4 id="_pitfall-not-all-objects-can-be-wrapped-transparently-by-proxies">
<span class="section-number">28.3.6 </span>Pitfall: not all objects can be wrapped transparently by proxies <a class="header-anchor" href="ch_proxies.html#_pitfall-not-all-objects-can-be-wrapped-transparently-by-proxies" aria-hidden="true">#</a></h4>

<p>A proxy object can be seen as intercepting operations performed on its target object &#x2013; the proxy wraps the target. The proxy&#x2019;s handler object is like an observer or listener for the proxy. It specifies which operations should be intercepted by implementing corresponding methods (<code>get</code> for reading a property, etc.). If the handler method for an operation is missing then that operation is not intercepted. It is simply forwarded to the target.</p>

<p>Therefore, if the handler is the empty object, the proxy should transparently wrap the target. Alas, that doesn&#x2019;t always work.</p>

<h5 id="_wrapping-an-object-affects-this">
<span class="section-number">28.3.6.1 </span>Wrapping an object affects <code>this</code>
 <a class="header-anchor" href="ch_proxies.html#_wrapping-an-object-affects-this" aria-hidden="true">#</a></h5>

<p>Before we dig deeper, let&#x2019;s quickly review how wrapping a target affects <code>this</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="p">{</code>
            <code class="nx">thisIsTarget</code><code class="o">:</code> <code class="k">this</code> <code class="o">===</code> <code class="nx">target</code><code class="p">,</code>
            <code class="nx">thisIsProxy</code><code class="o">:</code> <code class="k">this</code> <code class="o">===</code> <code class="nx">proxy</code><code class="p">,</code>
        <code class="p">};</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
</pre></div>

</figure>

<p>If you call <code>target.foo()</code> directly, <code>this</code> points to <code>target</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; target.foo()
{ thisIsTarget: true, thisIsProxy: false }
</pre></div>

</figure>

<p>If you invoke that method via the proxy, <code>this</code> points to <code>proxy</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.foo()
{ thisIsTarget: false, thisIsProxy: true }
</pre></div>

</figure>

<p>That&#x2019;s done so that the proxy continues to be in the loop if, e.g., the target invokes methods on <code>this</code>.</p>

<h5 id="_objects-that-cant-be-wrapped-transparently">
<span class="section-number">28.3.6.2 </span>Objects that can&#x2019;t be wrapped transparently <a class="header-anchor" href="ch_proxies.html#_objects-that-cant-be-wrapped-transparently" aria-hidden="true">#</a></h5>

<p>Normally, proxies with an empty handler wrap targets transparently: you don&#x2019;t notice that they are there and they don&#x2019;t change the behavior of the targets.</p>

<p>If, however, a target associates information with <code>this</code> via a mechanism that is not controlled by proxies, you have a problem: things fail, because different information is associated depending on whether the target is wrapped or not.</p>

<p>For example, the following class <code>Person</code> stores private information in the WeakMap <code>_name</code> (more information on this technique is given in <a href="ch_classes.html#sec_private-data-via-weakmaps">the chapter on classes</a>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">_name</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakMap</code><code class="p">();</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">_name</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">_name</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Instances of <code>Person</code> can&#x2019;t be wrapped transparently:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const jane = new Person(&apos;Jane&apos;);
&gt; jane.name
&apos;Jane&apos;

&gt; const proxy = new Proxy(jane, {});
&gt; proxy.name
undefined
</pre></div>

</figure>

<p><code>jane.name</code> is different from the wrapped <code>proxy.name</code>. The following implementation does not have this problem:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person2</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">_name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_name</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">jane</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person2</code><code class="p">(</code><code class="s1">&apos;Jane&apos;</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">jane</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Jane</code>

<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">jane</code><code class="p">,</code> <code class="p">{});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">proxy</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Jane</code>
</pre></div>

</figure>

<h5 id="_wrapping-instances-of-built-in-constructors">
<span class="section-number">28.3.6.3 </span>Wrapping instances of built-in constructors <a class="header-anchor" href="ch_proxies.html#_wrapping-instances-of-built-in-constructors" aria-hidden="true">#</a></h5>

<p>Instances of most built-in constructors also have a mechanism that is not intercepted by proxies. They therefore can&#x2019;t be wrapped transparently, either. I&#x2019;ll demonstrate the problem for an instance of <code>Date</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>

<code class="nx">proxy</code><code class="p">.</code><code class="nx">getDate</code><code class="p">();</code>
    <code class="c1">// TypeError: this is not a Date object.</code>
</pre></div>

</figure>

<p>The mechanism that is unaffected by proxies is called <em>internal slots</em>. These slots are property-like storage associated with instances. The specification handles these slots as if they were properties with names in square brackets. For example, the following method is internal and can be invoked on all objects <code>O</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">O</code><code class="p">.[[</code><code class="nx">GetPrototypeOf</code><code class="p">]]()</code>
</pre></div>

</figure>

<p>However, access to internal slots does not happen via normal &#x201C;get&#x201D; and &#x201C;set&#x201D; operations. If <code>getDate()</code> is invoked via a proxy, it can&#x2019;t find the internal slot it needs on <code>this</code> and complains via a <code>TypeError</code>.</p>

<p>For <code>Date</code> methods, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-number-prototype-object">the language specification states</a>:</p>

<blockquote>
  <p>Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the <code>this</code> value passed to them must be either a Number value or an object that has a <code>[[NumberData]]</code> internal slot that has been initialized to a Number value.</p>
</blockquote>

<h5 id="_arrays-can-be-wrapped-transparently">
<span class="section-number">28.3.6.4 </span>Arrays can be wrapped transparently <a class="header-anchor" href="ch_proxies.html#_arrays-can-be-wrapped-transparently" aria-hidden="true">#</a></h5>

<p>In contrast to other built-ins, Arrays can be wrapped transparently:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const p = new Proxy(new Array(), {});
&gt; p.push(&apos;a&apos;);
&gt; p.length
1
&gt; p.length = 0;
&gt; p.length
0
</pre></div>

</figure>

<p>The reason for Arrays being wrappable is that, even though property access is customized to make <code>length</code> work, Array methods don&#x2019;t rely on internal slots &#x2013; they are generic.</p>

<h5 id="_a-work-around">
<span class="section-number">28.3.6.5 </span>A work-around <a class="header-anchor" href="ch_proxies.html#_a-work-around" aria-hidden="true">#</a></h5>

<p>As a work-around, you can change how the handler forwards method calls and selectively set <code>this</code> to the target and not the proxy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">propKey</code> <code class="o">===</code> <code class="s1">&apos;getDate&apos;</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">target</code><code class="p">.</code><code class="nx">getDate</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">target</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
    <code class="p">},</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s1">&apos;2020-12-24&apos;</code><code class="p">),</code> <code class="nx">handler</code><code class="p">);</code>
<code class="nx">proxy</code><code class="p">.</code><code class="nx">getDate</code><code class="p">();</code> <code class="c1">// 24</code>
</pre></div>

</figure>

<p>The drawback of this approach is that none of the operations that the method performs on <code>this</code> go through the proxy.</p>

<p><strong>Acknowlegement:</strong> Thanks to Allen Wirfs-Brock for pointing out the pitfall explained in this section.</p>


<h3 id="sec_proxy-use-cases">
<span class="section-number">28.4 </span>Use cases for proxies <a class="header-anchor" href="ch_proxies.html#sec_proxy-use-cases" aria-hidden="true">#</a></h3>

<p>This section demonstrates what proxies can be used for. That will give you the opportunity to see the API in action.</p>


<h4 id="_tracing-property-accesses-get-set">
<span class="section-number">28.4.1 </span>Tracing property accesses (<code>get</code>, <code>set</code>) <a class="header-anchor" href="ch_proxies.html#_tracing-property-accesses-get-set" aria-hidden="true">#</a></h4>

<p>Let&#x2019;s assume we have a function <code>tracePropAccess(obj, propKeys)</code> that logs whenever a property of <code>obj</code>, whose key is in the Array <code>propKeys</code>, is set or got. In the following code, we apply that function to an instance of the class <code>Point</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Point</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="sb">`Point(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="c1">// Trace accesses to properties `x` and `y`</code>
<code class="kr">const</code> <code class="nx">p</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">);</code>
<code class="nx">p</code> <code class="o">=</code> <code class="nx">tracePropAccess</code><code class="p">(</code><code class="nx">p</code><code class="p">,</code> <code class="p">[</code><code class="s1">&apos;x&apos;</code><code class="p">,</code> <code class="s1">&apos;y&apos;</code><code class="p">]);</code>
</pre></div>

</figure>

<p>Getting and setting properties of the traced object <code>p</code> has the following effects:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; p.x
GET x
5
&gt; p.x = 21
SET x=21
21
</pre></div>

</figure>

<p>Intriguingly, tracing also works whenever <code>Point</code> accesses the properties, because <code>this</code> now refers to the traced object, not to an instance of <code>Point</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; p.toString()
GET x
GET y
&apos;Point(21, 7)&apos;
</pre></div>

</figure>

<p>In ECMAScript 5, you&#x2019;d implement <code>tracePropAccess()</code> as follows. We replace each property with a getter and a setter that traces accesses. The setters and getters use an extra object, <code>propData</code>, to store the data of the properties. Note that we are destructively changing the original implementation, which means that we are metaprogramming.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">tracePropAccess</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">propKeys</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Store the property data here</code>
    <code class="kr">const</code> <code class="nx">propData</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>
    <code class="c1">// Replace each property with a getter and a setter</code>
    <code class="nx">propKeys</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">propData</code><code class="p">[</code><code class="nx">propKey</code><code class="p">]</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">propKey</code><code class="p">];</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">get</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;GET &apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="p">);</code>
                <code class="k">return</code> <code class="nx">propData</code><code class="p">[</code><code class="nx">propKey</code><code class="p">];</code>
            <code class="p">},</code>
            <code class="nx">set</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;SET &apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="o">+</code><code class="s1">&apos;=&apos;</code><code class="o">+</code><code class="nx">value</code><code class="p">);</code>
                <code class="nx">propData</code><code class="p">[</code><code class="nx">propKey</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
            <code class="p">},</code>
        <code class="p">});</code>
    <code class="p">});</code>
    <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In ECMAScript 6, we can use a simpler, proxy-based solution. We intercept property getting and setting and don&#x2019;t have to change the implementation.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">tracePropAccess</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">propKeys</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">propKeySet</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">(</code><code class="nx">propKeys</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">propKeySet</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">propKey</code><code class="p">))</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;GET &apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
        <code class="p">},</code>
        <code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">propKeySet</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">propKey</code><code class="p">))</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;SET &apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="o">+</code><code class="s1">&apos;=&apos;</code><code class="o">+</code><code class="nx">value</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
        <code class="p">},</code>
    <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>


<h4 id="_warning-about-unknown-properties-get-set">
<span class="section-number">28.4.2 </span>Warning about unknown properties (<code>get</code>, <code>set</code>) <a class="header-anchor" href="ch_proxies.html#_warning-about-unknown-properties-get-set" aria-hidden="true">#</a></h4>

<p>When it comes to accessing properties, JavaScript is very forgiving. For example, if you try to read a property and misspell its name, you don&#x2019;t get an exception, you get the result <code>undefined</code>. You can use proxies to get an exception in such a case. This works as follows. We make the proxy a prototype of an object.</p>

<p>If a property isn&#x2019;t found in the object, the <code>get</code> trap of the proxy is triggered. If the property doesn&#x2019;t even exist in the prototype chain after the proxy, it really is missing and we throw an exception. Otherwise, we return the value of the inherited property. We do so by forwarding the <code>get</code> operation to the target (the prototype of the target is also the prototype of the proxy).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">PropertyChecker</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">propKey</code> <code class="k">in</code> <code class="nx">target</code><code class="p">))</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">ReferenceError</code><code class="p">(</code><code class="s1">&apos;Unknown property: &apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Let&#x2019;s use <code>PropertyChecker</code> for an object that we create:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="k">const</code> <code class="n">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nl">__proto__</code><code class="p">:</code> <code class="n">PropertyChecker</code><code class="p">,</code> <code class="nl">foo</code><code class="p">:</code> <code class="mi">123</code> <code class="p">};</code>
<code class="o">&gt;</code> <code class="n">obj</code><code class="p">.</code><code class="n">foo</code>  <code class="c1">// own</code>
<code class="mi">123</code>
<code class="o">&gt;</code> <code class="n">obj</code><code class="p">.</code><code class="n">fo</code>
<code class="nl">ReferenceError</code><code class="p">:</code> <code class="n">Unknown</code> <code class="nl">property</code><code class="p">:</code> <code class="n">fo</code>
<code class="o">&gt;</code> <code class="n">obj</code><code class="p">.</code><code class="n">toString</code><code class="p">()</code>  <code class="c1">// inherited</code>
<code class="err">&apos;</code><code class="p">[</code><code class="n">object</code> <code class="n">Object</code><code class="p">]</code><code class="err">&apos;</code>
</pre></div>

</figure>

<p>If we turn <code>PropertyChecker</code> into a constructor, we can use it for ECMAScript 6 classes via <code>extends</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">PropertyChecker</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
<code class="nx">PropertyChecker</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Point</code> <code class="kr">extends</code> <code class="nx">PropertyChecker</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">p</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">x</code><code class="p">);</code> <code class="c1">// 5</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">z</code><code class="p">);</code> <code class="c1">// ReferenceError</code>
</pre></div>

</figure>

<p>If you are worried about accidentally <em>creating</em> properties, you have two options: You can either wrap a proxy around objects that traps <code>set</code>. Or you can make an object <code>obj</code> non-extensible via <a href="http://speakingjs.com/es5/ch17.html#_preventing_extensions"><code>Object.preventExtensions(obj)</code></a>, which means that JavaScript doesn&#x2019;t let you add new (own) properties to <code>obj</code>.</p>


<h4 id="_negative-array-indices-get">
<span class="section-number">28.4.3 </span>Negative Array indices (<code>get</code>) <a class="header-anchor" href="ch_proxies.html#_negative-array-indices-get" aria-hidden="true">#</a></h4>

<p>Some Array methods let you refer to the last element via <code>-1</code>, to the second-to-last element via <code>-2</code>, etc. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].slice(-1)
[ &apos;c&apos; ]
</pre></div>

</figure>

<p>Alas, that doesn&#x2019;t work when accessing elements via the bracket operator (<code>[]</code>). We can, however, use proxies to add that capability. The following function <code>createArray()</code> creates Arrays that support negative indices. It does so by wrapping proxies around Array instances. The proxies intercept the <code>get</code> operation that is triggered by the bracket operator.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createArray</code><code class="p">(...</code><code class="nx">elements</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Sloppy way of checking for negative indices</code>
            <code class="kr">const</code> <code class="nx">index</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">propKey</code><code class="p">);</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">propKey</code> <code class="o">=</code> <code class="nb">String</code><code class="p">(</code><code class="nx">target</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="nx">index</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">};</code>
    <code class="c1">// Wrap a proxy around an Array</code>
    <code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="nx">target</code><code class="p">.</code><code class="nx">push</code><code class="p">(...</code><code class="nx">elements</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
<code class="p">}</code>
<code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="nx">createArray</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">,</code> <code class="s1">&apos;c&apos;</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">arr</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">]);</code> <code class="c1">// c</code>
</pre></div>

</figure>

<p>Acknowledgement: The idea for this example comes from a <a href="http://h3manth.com/new/blog/2013/negative-array-index-in-javascript/">blog post</a> by hemanth.hm.</p>


<h4 id="_data-binding-set">
<span class="section-number">28.4.4 </span>Data binding (<code>set</code>) <a class="header-anchor" href="ch_proxies.html#_data-binding-set" aria-hidden="true">#</a></h4>

<p>Data binding is about syncing data between objects. One popular use case are widgets based on the MVC (Model View Controler) pattern: With data binding, the <em>view</em> (the widget) stays up-to-date if you change the <em>model</em> (the data visualized by the widget).</p>

<p>To implement data binding, you have to observe and react to changes made to an object. In the following code snippet, I sketch how observing changes could work for an Array.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createObservedArray</code><code class="p">(</code><code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propertyKey</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">callback</code><code class="p">(</code><code class="nx">propertyKey</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propertyKey</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code>    
<code class="p">}</code>
<code class="kr">const</code> <code class="nx">observedArray</code> <code class="o">=</code> <code class="nx">createObservedArray</code><code class="p">(</code>
    <code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">=</code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">));</code>
<code class="nx">observedArray</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">);</code>
</pre></div>

</figure>

<p>Output:</p>

<figure class="code">
<div class="highlight"><pre><code></code>0=a
length=1
</pre></div>

</figure>


<h4 id="_accessing-a-restful-web-service-method-calls">
<span class="section-number">28.4.5 </span>Accessing a restful web service (method calls) <a class="header-anchor" href="ch_proxies.html#_accessing-a-restful-web-service-method-calls" aria-hidden="true">#</a></h4>

<p>A proxy can be used to create an object on which arbitrary methods can be invoked. In the following example, the function <code>createWebService</code> creates one such object, <code>service</code>. Invoking a method on <code>service</code> retrieves the contents of the web service resource with the same name. Retrieval is handled via an ECMAScript 6 Promise.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">service</code> <code class="o">=</code> <code class="nx">createWebService</code><code class="p">(</code><code class="s1">&apos;http://example.com/data&apos;</code><code class="p">);</code>
<code class="c1">// Read JSON data in http://example.com/data/employees</code>
<code class="nx">service</code><code class="p">.</code><code class="nx">employees</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">json</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">employees</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">json</code><code class="p">);</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The following code is a quick and dirty implementation of <code>createWebService</code> in ECMAScript 5. Because we don&#x2019;t have proxies, we need to know beforehand what methods will be invoked on <code>service</code>. The parameter <code>propKeys</code> provides us with that information, it holds an Array with method names.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createWebService</code><code class="p">(</code><code class="nx">baseUrl</code><code class="p">,</code> <code class="nx">propKeys</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">service</code> <code class="o">=</code> <code class="p">{};</code>
    <code class="nx">propKeys</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">service</code><code class="p">[</code><code class="nx">propKey</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">httpGet</code><code class="p">(</code><code class="nx">baseUrl</code><code class="o">+</code><code class="s1">&apos;/&apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="p">);</code>
        <code class="p">};</code>
    <code class="p">});</code>
    <code class="k">return</code> <code class="nx">service</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The ECMAScript 6 implementation of <code>createWebService</code> can use proxies and is simpler:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createWebService</code><code class="p">(</code><code class="nx">baseUrl</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
        <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Return the method to be called</code>
            <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">httpGet</code><code class="p">(</code><code class="nx">baseUrl</code><code class="o">+</code><code class="s1">&apos;/&apos;</code><code class="o">+</code><code class="nx">propKey</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Both implementations use the following function to make HTTP GET requests (how it works is explained in <a href="ch_promises.html#ch_promises">the chapter on Promises</a>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">httpGet</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code>
        <code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">request</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">XMLHttpRequest</code><code class="p">();</code>
            <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">request</code><code class="p">,</code> <code class="p">{</code>
                <code class="nx">onload</code><code class="p">()</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">status</code> <code class="o">===</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// Success</code>
                        <code class="nx">resolve</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">response</code><code class="p">);</code>
                    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                        <code class="c1">// Something went wrong (404 etc.)</code>
                        <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">statusText</code><code class="p">));</code>
                    <code class="p">}</code>
                <code class="p">},</code>
                <code class="nx">onerror</code><code class="p">()</code> <code class="p">{</code>
                    <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code>
                        <code class="s1">&apos;XMLHttpRequest Error: &apos;</code><code class="o">+</code><code class="k">this</code><code class="p">.</code><code class="nx">statusText</code><code class="p">));</code>
                <code class="p">}</code>
            <code class="p">});</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">open</code><code class="p">(</code><code class="s1">&apos;GET&apos;</code><code class="p">,</code> <code class="nx">url</code><code class="p">);</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">send</code><code class="p">();</code>
        <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>


<h4 id="_revocable-references">
<span class="section-number">28.4.6 </span>Revocable references <a class="header-anchor" href="ch_proxies.html#_revocable-references" aria-hidden="true">#</a></h4>

<p><em>Revocable references</em> work as follows: A client is not allowed to access an important resource (an object) directly, only via a reference (an intermediate object, a wrapper around the resource). Normally, every operation applied to the reference is forwarded to the resource. After the client is done, the resource is protected by <em>revoking</em> the reference, by switching it off. Henceforth, applying operations to the reference throws exceptions and nothing is forwarded, anymore.</p>

<p>In the following example, we create a revocable reference for a resource. We then read one of the resource&#x2019;s properties via the reference. That works, because the reference grants us access. Next, we revoke the reference. Now the reference doesn&#x2019;t let us read the property, anymore.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">resource</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">11</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">8</code> <code class="p">};</code>
<code class="kr">const</code> <code class="p">{</code><code class="nx">reference</code><code class="p">,</code> <code class="nx">revoke</code><code class="p">}</code> <code class="o">=</code> <code class="nx">createRevocableReference</code><code class="p">(</code><code class="nx">resource</code><code class="p">);</code>

<code class="c1">// Access granted</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reference</code><code class="p">.</code><code class="nx">x</code><code class="p">);</code> <code class="c1">// 11</code>

<code class="nx">revoke</code><code class="p">();</code>

<code class="c1">// Access denied</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reference</code><code class="p">.</code><code class="nx">x</code><code class="p">);</code> <code class="c1">// TypeError: Revoked</code>
</pre></div>

</figure>

<p>Proxies are ideally suited for implementing revocable references, because they can intercept and forward operations. This is a simple proxy-based implementation of <code>createRevocableReference</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createRevocableReference</code><code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">enabled</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">reference</code><code class="o">:</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">enabled</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">&apos;Revoked&apos;</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
            <code class="p">},</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">enabled</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">&apos;Revoked&apos;</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">);</code>
            <code class="p">},</code>
            <code class="err">&#xB7;&#xB7;&#xB7;</code>
        <code class="p">}),</code>
        <code class="nx">revoke</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">enabled</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
        <code class="p">},</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The code can be simplified via the proxy-as-handler technique from the previous section. This time, the handler basically is the <code>Reflect</code> object. Thus, the <code>get</code> trap normally returns the appropriate <code>Reflect</code> method. If the reference has been revoked, a <code>TypeError</code> is thrown, instead.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createRevocableReference</code><code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">enabled</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
        <code class="nx">get</code><code class="p">(</code><code class="nx">dummyTarget</code><code class="p">,</code> <code class="nx">trapName</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">enabled</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">&apos;Revoked&apos;</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">Reflect</code><code class="p">[</code><code class="nx">trapName</code><code class="p">];</code>
        <code class="p">}</code>
    <code class="p">});</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">reference</code><code class="o">:</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">),</code>
        <code class="nx">revoke</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">enabled</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
        <code class="p">},</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>However, you don&#x2019;t have to implement revocable references yourself, because ECMAScript 6 lets you create proxies that can be revoked. This time, the revoking happens in the proxy, not in the handler. All the handler has to do is forward every operation to the target. As we have seen that happens automatically if the handler doesn&#x2019;t implement any traps.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">createRevocableReference</code><code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// forward everything</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">proxy</code><code class="p">,</code> <code class="nx">revoke</code> <code class="p">}</code> <code class="o">=</code> <code class="nb">Proxy</code><code class="p">.</code><code class="nx">revocable</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
    <code class="k">return</code> <code class="p">{</code> <code class="nx">reference</code><code class="o">:</code> <code class="nx">proxy</code><code class="p">,</code> <code class="nx">revoke</code> <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<h5 id="sec_membranes">
<span class="section-number">28.4.6.1 </span>Membranes <a class="header-anchor" href="ch_proxies.html#sec_membranes" aria-hidden="true">#</a></h5>

<p><em>Membranes</em> build on the idea of revocable references: Environments that are designed to run untrusted code, wrap a membrane around that code to isolate it and keep the rest of the system safe. Objects pass the membrane in two directions:</p>

<ul>
  <li>The code may receive objects (&#x201C;dry objects&#x201D;) from the outside.</li>
  <li>Or it may hand objects (&#x201C;wet objects&#x201D;) to the outside.</li>
</ul>

<p>In both cases, revocable references are wrapped around the objects. Objects returned by wrapped functions or methods are also wrapped. Additionally, if a wrapped wet object is passed back into a membrane, it is unwrapped.</p>

<p>Once the untrusted code is done, all of the revocable references are revoked. As a result, none of its code on the outside can be executed anymore and outside objects that it has cease to work, as well. The <a href="https://developers.google.com/caja/">Caja Compiler</a> is &#x201C;a tool for making third party HTML, CSS and JavaScript safe to embed in your website&#x201D;. It uses membranes to achieve this task.</p>


<h4 id="_implementing-the-dom-in-javascript">
<span class="section-number">28.4.7 </span>Implementing the DOM in JavaScript <a class="header-anchor" href="ch_proxies.html#_implementing-the-dom-in-javascript" aria-hidden="true">#</a></h4>

<p>The browser Document Object Model (DOM) is usually implemented as a mix of JavaScript and C++. Implementing it in pure JavaScript is useful for:</p>

<ul>
  <li>Emulating a browser environment, e.g. to manipulate HTML in Node.js. <a href="https://github.com/tmpvar/jsdom">jsdom</a> is one library that does that.</li>
  <li>Speeding the DOM up (switching between JavaScript and C++ costs time).</li>
</ul>

<p>Alas, the standard DOM can do things that are not easy to replicate in JavaScript. For example, most DOM collections are live views on the current state of the DOM that change dynamically whenever the DOM changes. As a result, pure JavaScript implementations of the DOM are not very efficient. One of the reasons for adding proxies to JavaScript was to help write more efficient DOM implementations.</p>


<h4 id="_other-use-cases">
<span class="section-number">28.4.8 </span>Other use cases <a class="header-anchor" href="ch_proxies.html#_other-use-cases" aria-hidden="true">#</a></h4>

<p>There are more use cases for proxies. For example:</p>

<ul>
  <li>Remoting: Local placeholder objects forward method invocations to remote objects. This use case is similar to the web service example.</li>
  <li>Data access objects for databases: Reading and writing to the object reads and writes to the database. This use case is similar to the web service example.</li>
  <li>Profiling: Intercept method invocations to track how much time is spent in each method. This use case is similar to the tracing example.</li>
  <li>Type checking: Nicholas Zakas has used proxies to <a href="http://www.nczonline.net/blog/2014/04/29/creating-type-safe-properties-with-ecmascript-6-proxies/">type-check objects</a>.</li>
</ul>


<h3 id="sec_design-proxy-api">
<span class="section-number">28.5 </span>The design of the proxy API <a class="header-anchor" href="ch_proxies.html#sec_design-proxy-api" aria-hidden="true">#</a></h3>

<p>In this section, we go deeper into how proxies work and why they work that way.</p>

<h4 id="_stratification-keeping-base-level-and-meta-level-separate">
<span class="section-number">28.5.1 </span>Stratification: keeping base level and meta level separate <a class="header-anchor" href="ch_proxies.html#_stratification-keeping-base-level-and-meta-level-separate" aria-hidden="true">#</a></h4>

<p>Firefox has allowed you to do some interceptive metaprogramming for a while: If you define a method whose name is <code>__noSuchMethod__</code>, it is notified whenever a method is called that doesn&#x2019;t exist. The following is an example of using <code>__noSuchMethod__</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__noSuchMethod__</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="o">+</code><code class="s1">&apos;: &apos;</code><code class="o">+</code><code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="c1">// Neither of the following two methods exist,</code>
<code class="c1">// but we can make it look like they do</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>    <code class="c1">// Output: foo: 1</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">bar</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code> <code class="c1">// Output: bar: 1,2</code>
</pre></div>

</figure>

<p>Thus, <code>__noSuchMethod__</code> works similarly to a proxy trap. In contrast to proxies, the trap is an own or inherited method of the object whose operations we want to intercept. The problem with that approach is that base level (normal methods) and meta level (<code>__noSuchMethod__</code>) are mixed. Base-level code may accidentally invoke or see a meta level method and there is the possibility of accidentally defining a meta level method.</p>

<p>Even in standard ECMAScript 5, base level and meta level are sometimes mixed. For example, the following metaprogramming mechanisms can fail, because they exist at the base level:</p>

<ul>
  <li>
<code>obj.hasOwnProperty(propKey)</code>: This call can fail if a property in the prototype chain overrides the built-in implementation. For example, it fails if <code>obj</code> is:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="p">{</code> <code class="nx">hasOwnProperty</code><code class="o">:</code> <code class="kc">null</code> <code class="p">}</code>
</pre></div>

    </figure>

    <p>A safe way to call this method is:</p>

    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code>

  <code class="c1">// Abbreviated version:</code>
  <code class="p">{}.</code><code class="nx">hasOwnProperty</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code>
</pre></div>

    </figure>
  </li>
  <li>
<code>func.call(&#xB7;&#xB7;&#xB7;)</code>, <code>func.apply(&#xB7;&#xB7;&#xB7;)</code>: For each of these two methods, problem and solution are the same as with <code>hasOwnProperty</code>.</li>
  <li>
<code>obj.__proto__</code>: In most JavaScript engines, <code>__proto__</code> is a special property that lets you get and set the prototype of <code>obj</code>. Hence, when you use objects as dictionaries, you must be careful to <a href="http://speakingjs.com/es5/ch17.html#_pitfall_3_the_special_property___proto">avoid <code>__proto__</code> as a property key</a>.</li>
</ul>

<p>By now, it should be obvious that making (base level) property keys special is problematic. Therefore, proxies are <em>stratified</em> &#x2013; base level (the proxy object) and meta level (the handler object) are separate.</p>

<h4 id="_virtual-objects-versus-wrappers">
<span class="section-number">28.5.2 </span>Virtual objects versus wrappers <a class="header-anchor" href="ch_proxies.html#_virtual-objects-versus-wrappers" aria-hidden="true">#</a></h4>

<p>Proxies are used in two roles:</p>

<ul>
  <li>As <em>wrappers</em>, they <em>wrap</em> their targets, they control access to them. Examples of wrappers are: revocable resources and tracing proxies.</li>
  <li>As <em>virtual objects</em>, they are simply objects with special behavior and their targets don&#x2019;t matter. An example is a proxy that forwards method calls to a remote object.</li>
</ul>

<p>An earlier design of the proxy API conceived proxies as purely virtual objects. However, it turned out that even in that role, a target was useful, to enforce invariants (which is explained later) and as a fallback for traps that the handler doesn&#x2019;t implement.</p>

<h4 id="sec_detect-proxies">
<span class="section-number">28.5.3 </span>Transparent virtualization and handler encapsulation <a class="header-anchor" href="ch_proxies.html#sec_detect-proxies" aria-hidden="true">#</a></h4>

<p>Proxies are shielded in two ways:</p>

<ul>
  <li>It is impossible to determine whether an object is a proxy or not (<em>transparent virtualization</em>).</li>
  <li>You can&#x2019;t access a handler via its proxy (<em>handler encapsulation</em>).</li>
</ul>

<p>Both principles give proxies considerable power for impersonating other objects. One reason for enforcing <em>invariants</em> (as explained later) is to keep that power in check.</p>

<p>If you do need a way to tell proxies apart from non-proxies, you have to implement it yourself. The following code is a module <code>lib.js</code> that exports two functions: one of them creates proxies, the other one determines whether an object is one of those proxies.</p>


<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// lib.js</code>
<code class="kr">const</code> <code class="nx">proxies</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">();</code>

<code class="kr">export</code> <code class="kd">function</code> <code class="nx">createProxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{};</code>
    <code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
    <code class="nx">proxies</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">proxy</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">proxy</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">export</code> <code class="kd">function</code> <code class="nx">isProxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">proxies</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This module uses the ECMAScript 6 data structure <code>WeakSet</code> for keeping track of proxies. <code>WeakSet</code> is ideally suited for this purpose, because it doesn&#x2019;t prevent its elements from being garbage-collected.</p>

<p>The next example shows how <code>lib.js</code> can be used.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// main.js</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createProxy</code><code class="p">,</code> <code class="nx">isProxy</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;./lib.js&apos;</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">p</code> <code class="o">=</code> <code class="nx">createProxy</code><code class="p">({});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isProxy</code><code class="p">(</code><code class="nx">p</code><code class="p">));</code> <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isProxy</code><code class="p">({}));</code> <code class="c1">// false</code>
</pre></div>

</figure>

<h4 id="sec_meta-object-protocol">
<span class="section-number">28.5.4 </span>The meta object protocol and proxy traps <a class="header-anchor" href="ch_proxies.html#sec_meta-object-protocol" aria-hidden="true">#</a></h4>

<p>This section examines how JavaScript is structured internally and how the set of proxy traps was chosen.</p>

<p>In the context of programming languages and API design, <a href="ch_about-book.html#sec_protocol">a <em>protocol</em></a> is a set of interfaces plus rules for using them. The ECMAScript specification describes how to execute JavaScript code. It includes a <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-and-exotic-objects-behaviours">protocol for handling objects</a>. This protocol operates at a meta level and is sometimes called the meta object protocol (MOP). The JavaScript MOP consists of own internal methods that all objects have. &#x201C;Internal&#x201D; means that they exist only in the specification (JavaScript engines may or may not have them) and are not accessible from JavaScript. The names of internal methods are written in double square brackets.</p>

<p>The internal method for getting properties is called <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver"><code>[[Get]]</code></a>. If we pretend that property names with square brackets are legal, this method would roughly be implemented as follows in JavaScript.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Method definition</code>
<code class="p">[[</code><code class="nx">Get</code><code class="p">]](</code><code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">desc</code> <code class="o">=</code> <code class="k">this</code><code class="p">.[[</code><code class="nx">GetOwnProperty</code><code class="p">]](</code><code class="nx">propKey</code><code class="p">);</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">desc</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">parent</code> <code class="o">=</code> <code class="k">this</code><code class="p">.[[</code><code class="nx">GetPrototypeOf</code><code class="p">]]();</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">parent</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">parent</code><code class="p">.[[</code><code class="nx">Get</code><code class="p">]](</code><code class="nx">propKey</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code> <code class="c1">// (A)</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(</code><code class="s1">&apos;value&apos;</code> <code class="k">in</code> <code class="nx">desc</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">desc</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kr">const</code> <code class="nx">getter</code> <code class="o">=</code> <code class="nx">desc</code><code class="p">.</code><code class="nx">get</code><code class="p">;</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">getter</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">getter</code><code class="p">.[[</code><code class="nx">Call</code><code class="p">]](</code><code class="nx">receiver</code><code class="p">,</code> <code class="p">[]);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The MOP methods called in this code are:</p>

<ul>
  <li>
<code>[[GetOwnProperty]]</code> (trap <code>getOwnPropertyDescriptor</code>)</li>
  <li>
<code>[[GetPrototypeOf]]</code> (trap <code>getPrototypeOf</code>)</li>
  <li>
<code>[[Get]]</code> (trap <code>get</code>)</li>
  <li>
<code>[[Call]]</code> (trap <code>apply</code>)</li>
</ul>

<p>In line A you can see why proxies in a prototype chain find out about <code>get</code> if a property isn&#x2019;t found in an &#x201C;earlier&#x201D; object: If there is no own property whose key is <code>propKey</code>, the search continues in the prototype <code>parent</code> of <code>this</code>.</p>

<p><strong>Fundamental versus derived operations.</strong> You can see that <code>[[Get]]</code> calls other MOP operations. Operations that do that are called <em>derived</em>. Operations that don&#x2019;t depend on other operations are called <em>fundamental</em>.</p>

<h5 id="_the-mop-of-proxies">
<span class="section-number">28.5.4.1 </span>The MOP of proxies <a class="header-anchor" href="ch_proxies.html#_the-mop-of-proxies" aria-hidden="true">#</a></h5>

<p>The <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-proxy-object-internal-methods-and-internal-slots">meta object protocol of proxies</a> is different from that of normal objects. For normal objects, derived operations call other operations. For proxies, each operation (regardless of whether it is fundamental or derived) is either intercepted by a handler method or forwarded to the target.</p>

<p>What operations should be interceptable via proxies? One possibility is to only provide traps for fundamental operations. The alternative is to include some derived operations. The advantage of doing so is that it increases performance and is more convenient. For example, if there weren&#x2019;t a trap for <code>get</code>, you&#x2019;d have to implement its functionality via <code>getOwnPropertyDescriptor</code>. One problem with derived traps is that they can lead to proxies behaving inconsistently. For example, <code>get</code> may return a value that is different from the value in the descriptor returned by <code>getOwnPropertyDescriptor</code>.</p>

<h5 id="_selective-intercession-what-operations-should-be-interceptable">
<span class="section-number">28.5.4.2 </span>Selective intercession: what operations should be interceptable? <a class="header-anchor" href="ch_proxies.html#_selective-intercession-what-operations-should-be-interceptable" aria-hidden="true">#</a></h5>

<p>Intercession by proxies is <em>selective</em>: you can&#x2019;t intercept every language operation. Why were some operations excluded? Let&#x2019;s look at two reasons.</p>

<p>First, stable operations are not well suited for intercession. An operation is <em>stable</em> if it always produces the same results for the same arguments. If a proxy can trap a stable operation, it can become unstable and thus unreliable. <a href="http://speakingjs.com/es5/ch09.html#_strict_equality">Strict equality</a> (<code>===</code>) is one such stable operation. It can&#x2019;t be trapped and its result is computed by treating the proxy itself as just another object. Another way of maintaining stability is by applying an operation to the target instead of the proxy. As explained later, when we look at how invariants are enfored for proxies, this happens when <code>Object.getPrototypeOf()</code> is applied to a proxy whose target is non-extensible.</p>

<p>A second reason for not making more operations interceptable is that intercession means executing custom code in situations where that normally isn&#x2019;t possible. The more this interleaving of code happens, the harder it is to understand and debug a program. It also affects performance negatively.</p>

<h5 id="_traps-get-versus-invoke">
<span class="section-number">28.5.4.3 </span>Traps: <code>get</code> versus <code>invoke</code>
 <a class="header-anchor" href="ch_proxies.html#_traps-get-versus-invoke" aria-hidden="true">#</a></h5>

<p>If you want to create virtual methods via ECMAScript 6 proxies, you have to return functions from a <code>get</code> trap. That raises the question: why not introduce an extra trap for method invocations (e.g. <code>invoke</code>)? That would enable us to distinguish between:</p>

<ul>
  <li>Getting properties via <code>obj.prop</code> (trap <code>get</code>)</li>
  <li>Invoking methods via <code>obj.prop()</code> (trap <code>invoke</code>)</li>
</ul>

<p>There are two reasons for not doing so.</p>

<p>First, not all implementations distinguish between <code>get</code> and <code>invoke</code>. For example, <a href="https://mail.mozilla.org/pipermail/es-discuss/2010-May/011062.html">Apple&#x2019;s JavaScriptCore doesn&#x2019;t</a>.</p>

<p>Second, extracting a method and invoking it later via <code>call()</code> or <code>apply()</code> should have the same effect as invoking the method via dispatch. In other words, the following two variants should work equivalently. If there was an extra trap <code>invoke</code> then that equivalence would be harder to maintain.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Variant 1: call via dynamic dispatch</code>
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">m</code><code class="p">();</code>

<code class="c1">// Variant 2: extract and call directly</code>
<code class="kr">const</code> <code class="nx">m</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">m</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">m</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>
</pre></div>

</figure>

<h6 id="_use-cases-for-invoke">
<span class="section-number">28.5.4.3.1 </span>Use cases for <code>invoke</code>
 <a class="header-anchor" href="ch_proxies.html#_use-cases-for-invoke" aria-hidden="true">#</a></h6>

<p>Some things can only be done if you are able to distinguish between <code>get</code> and <code>invoke</code>. Those things are therefore impossible with the current proxy API. Two examples are: auto-binding and intercepting missing methods. Let&#x2019;s examine how one would implement them if proxies supported <code>invoke</code>.</p>

<p><strong>Auto-binding.</strong> By making a proxy the prototype of an object <code>obj</code>, you can automatically bind methods:</p>

<ul>
  <li>Retrieving the value of a method <code>m</code> via <code>obj.m</code> returns a function whose <code>this</code> is bound to <code>obj</code>.</li>
  <li>
<code>obj.m()</code> performs a method call.</li>
</ul>

<p>Auto-binding helps with using methods as callbacks. For example, variant 2 from the previous example becomes simpler:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">boundMethod</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">m</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">boundMethod</code><code class="p">();</code>
</pre></div>

</figure>

<p><strong>Intercepting missing methods.</strong> <code>invoke</code> lets a proxy emulate the previously mentioned <code>__noSuchMethod__</code> mechanism that Firefox supports. The proxy would again become the prototype of an object <code>obj</code>. It would react differently depending on how an unknown property <code>foo</code> is accessed:</p>

<ul>
  <li>If you read that property via <code>obj.foo</code>, no intercession happens and <code>undefined</code> is returned.</li>
  <li>If you make the method call <code>obj.foo()</code> then the proxy intercepts and, e.g., notifies a callback.</li>
</ul>

<h4 id="_enforcing-invariants-for-proxies">
<span class="section-number">28.5.5 </span>Enforcing invariants for proxies <a class="header-anchor" href="ch_proxies.html#_enforcing-invariants-for-proxies" aria-hidden="true">#</a></h4>

<p>Before we look at what invariants are and how they are enforced for proxies, let&#x2019;s review how objects can be protected via non-extensibility and non-configurability.</p>

<h5 id="_protecting-objects">
<span class="section-number">28.5.5.1 </span>Protecting objects <a class="header-anchor" href="ch_proxies.html#_protecting-objects" aria-hidden="true">#</a></h5>

<p>There are two ways of protecting objects:</p>

<ul>
  <li>Non-extensibility protects objects</li>
  <li>Non-configurability protects properties (or rather, their attributes)</li>
</ul>

<p><strong>Non-extensibility.</strong> If an object is non-extensible, you can&#x2019;t add properties and you can&#x2019;t change its prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">&apos;use strict&apos;</code><code class="p">;</code> <code class="c1">// switch on strict mode to get TypeErrors</code>

<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">preventExtensions</code><code class="p">({});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">isExtensible</code><code class="p">(</code><code class="nx">obj</code><code class="p">));</code> <code class="c1">// false</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// TypeError: object is not extensible</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code> <code class="c1">// TypeError: object is not extensible</code>
</pre></div>

</figure>

<p><strong>Non-configurability.</strong> All the data of a property is stored in <em>attributes</em>. A property is like a record and attributes are like the fields of that record. Examples of attributes:</p>

<ul>
  <li>The attribute <code>value</code> holds the value of a property.</li>
  <li>The boolean attribute <code>writable</code> controls whether a property&#x2019;s value can be changed.</li>
  <li>The boolean attribute <code>configurable</code> controls whether a property&#x2019;s attributes can be changed.</li>
</ul>

<p>Thus, if a property is both non-writable and non-configurable, it is read-only and remains that way:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">&apos;use strict&apos;</code><code class="p">;</code> <code class="c1">// switch on strict mode to get TypeErrors</code>

<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="s1">&apos;foo&apos;</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">value</code><code class="o">:</code> <code class="mi">123</code><code class="p">,</code>
    <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
    <code class="nx">configurable</code><code class="o">:</code> <code class="kc">false</code>
<code class="p">});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// 123</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code> <code class="c1">// TypeError: Cannot assign to read only property</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="s1">&apos;foo&apos;</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
<code class="p">});</code> <code class="c1">// TypeError: Cannot redefine property</code>
</pre></div>

</figure>

<p>For more details on these topics (including how <code>Object.defineProperty()</code> works) consult the following sections in &#x201C;Speaking JavaScript&#x201D;:</p>

<ul>
  <li><a href="http://speakingjs.com/es5/ch17.html#property_attributes">Property Attributes and Property Descriptors</a></li>
  <li><a href="http://speakingjs.com/es5/ch17.html#protecting_objects">Protecting Objects</a></li>
</ul>

<h5 id="_enforcing-invariants">
<span class="section-number">28.5.5.2 </span>Enforcing invariants <a class="header-anchor" href="ch_proxies.html#_enforcing-invariants" aria-hidden="true">#</a></h5>

<p>Traditionally, non-extensibility and non-configurability are:</p>

<ul>
  <li>Universal: they work for all objects.</li>
  <li>Monotonic: once switched on, they can&#x2019;t be switched off again.</li>
</ul>

<p>These and other characteristics that remain unchanged in the face of language operations are called <em>invariants</em>. With proxies, it is easy to violate invariants, as they are not intrinsically bound by non-extensibility etc.</p>

<p>The proxy API prevents proxies from violating invariants by checking the parameters and results of handler methods. The following are four examples of invariants (for an arbitrary object <code>obj</code>) and how they are enforced for proxies (an exhaustive list is given at the end of this chapter).</p>

<p>The first two invariants involve non-extensibility and non-configurability. These are enforced by using the target object for bookkeeping: results returned by handler methods have to be mostly in sync with the target object.</p>

<ul>
  <li>Invariant: If <code>Object.preventExtensions(obj)</code> returns <code>true</code> then all future calls must return <code>false</code> and <code>obj</code> must now be non-extensible.
    <ul>
      <li>Enforced for proxies by throwing a <code>TypeError</code> if the handler returns <code>true</code>, but the target object is not extensible.</li>
    </ul>
  </li>
  <li>Invariant: Once an object has been made non-extensible, <code>Object.isExtensible(obj)</code> must always return <code>false</code>.
    <ul>
      <li>Enforced for proxies by throwing a <code>TypeError</code> if the result returned by the handler is not the same (after coercion) as <code>Object.isExtensible(target)</code>.</li>
    </ul>
  </li>
</ul>

<p>The remaining two invariants are enforced by checking return values:</p>

<ul>
  <li>Invariant: <code>Object.isExtensible(obj)</code> must return a boolean.
    <ul>
      <li>Enforced for proxies by coercing the value returned by the handler to a boolean.</li>
    </ul>
  </li>
  <li>Invariant: <code>Object.getOwnPropertyDescriptor(obj, &#xB7;&#xB7;&#xB7;)</code> must return an object or <code>undefined</code>.
    <ul>
      <li>Enforced for proxies by throwing a <code>TypeError</code> if the handler doesn&#x2019;t return an appropriate value.</li>
    </ul>
  </li>
</ul>

<p>Enforcing invariants has the following benefits:</p>

<ul>
  <li>Proxies work like all other objects with regard to extensibility and configurability. Therefore, universality is maintained. This is achieved without preventing proxies from virtualizing (impersonating) protected objects.</li>
  <li>A protected object can&#x2019;t be misrepresented by wrapping a proxy around it. Misrepresentation can be caused by bugs or by malicious code.</li>
</ul>

<p>The next two sections give examples of invariants being enforced.</p>

<h5 id="_example-the-prototype-of-a-non-extensible-target-must-be-represented-faithfully">
<span class="section-number">28.5.5.3 </span>Example: the prototype of a non-extensible target must be represented faithfully <a class="header-anchor" href="ch_proxies.html#_example-the-prototype-of-a-non-extensible-target-must-be-represented-faithfully" aria-hidden="true">#</a></h5>

<p>In response to the <code>getPrototypeOf</code> trap, the proxy must return the target&#x2019;s prototype if the target is non-extensible.</p>

<p>To demonstrate this invariant, let&#x2019;s create a handler that returns a prototype that is different from the target&#x2019;s prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fakeProto</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">t</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">fakeProto</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Faking the prototype works if the target is extensible:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">extensibleTarget</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">ext</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">extensibleTarget</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">ext</code><code class="p">)</code> <code class="o">===</code> <code class="nx">fakeProto</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</figure>

<p>We do, however, get an error if we fake the prototype for a non-extensible object.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">nonExtensibleTarget</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">preventExtensions</code><code class="p">(</code><code class="nx">nonExtensibleTarget</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">nonExt</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">nonExtensibleTarget</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">nonExt</code><code class="p">);</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<h5 id="_example-non-writable-non-configurable-target-properties-must-be-represented-faithfully">
<span class="section-number">28.5.5.4 </span>Example: non-writable non-configurable target properties must be represented faithfully <a class="header-anchor" href="ch_proxies.html#_example-non-writable-non-configurable-target-properties-must-be-represented-faithfully" aria-hidden="true">#</a></h5>

<p>If the target has a non-writable non-configurable property then the handler must return that property&#x2019;s value in response to a <code>get</code> trap. To demonstrate this invariant, let&#x2019;s create a handler that always returns the same value for properties.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">handler</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">propKey</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s1">&apos;abc&apos;</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperties</code><code class="p">(</code>
    <code class="p">{},</code> <code class="p">{</code>
        <code class="nx">foo</code><code class="o">:</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">123</code><code class="p">,</code>
            <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
            <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">},</code>
        <code class="nx">bar</code><code class="o">:</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">456</code><code class="p">,</code>
            <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
            <code class="nx">configurable</code><code class="o">:</code> <code class="kc">false</code>
        <code class="p">},</code>
    <code class="p">});</code>
<code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>
</pre></div>

</figure>

<p>Property <code>target.foo</code> is not both non-writable and non-configurable, which means that the handler is allowed to pretend that it has a different value:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.foo
&apos;abc&apos;
</pre></div>

</figure>

<p>However, property <code>target.bar</code> is both non-writable and non-configurable. Therefore, we can&#x2019;t fake its value:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; proxy.bar
TypeError: Invariant check failed
</pre></div>

</figure>


<h3 id="sec_faq-proxies">
<span class="section-number">28.6 </span>FAQ: proxies <a class="header-anchor" href="ch_proxies.html#sec_faq-proxies" aria-hidden="true">#</a></h3>

<h4 id="_where-is-the-enumerate-trap">
<span class="section-number">28.6.1 </span>Where is the <code>enumerate</code> trap? <a class="header-anchor" href="ch_proxies.html#_where-is-the-enumerate-trap" aria-hidden="true">#</a></h4>

<p>ES6 originally had a trap <code>enumerate</code> that was triggered by <code>for-in</code> loops. But it was recently removed, to simplify proxies. <code>Reflect.enumerate()</code> was removed, as well. (<a href="https://github.com/tc39/tc39-notes/blob/master/es7/2016-01/2016-01-28.md">Source: TC39 notes</a>)</p>



<h3 id="sec_reference-proxy-api">
<span class="section-number">28.7 </span>Reference: the proxy API <a class="header-anchor" href="ch_proxies.html#sec_reference-proxy-api" aria-hidden="true">#</a></h3>

<p>This section serves as a quick reference for the proxy API: the global objects <code>Proxy</code> and <code>Reflect</code>.</p>

<h4 id="_creating-proxies">
<span class="section-number">28.7.1 </span>Creating proxies <a class="header-anchor" href="ch_proxies.html#_creating-proxies" aria-hidden="true">#</a></h4>

<p>There are two ways to create proxies:</p>

<ul>
  <li>
<code>const proxy = new Proxy(target, handler)</code><br>
Creates a new proxy object with the given target and the given handler.</li>
  <li>
<code>const {proxy, revoke} = Proxy.revocable(target, handler)</code><br>
Creates a proxy that can be revoked via the function <code>revoke</code>. <code>revoke</code> can be called multiple times, but only the first call has an effect and switches <code>proxy</code> off. Afterwards, any operation performed on <code>proxy</code> leads to a <code>TypeError</code> being thrown.</li>
</ul>

<h4 id="_handler-methods">
<span class="section-number">28.7.2 </span>Handler methods <a class="header-anchor" href="ch_proxies.html#_handler-methods" aria-hidden="true">#</a></h4>

<p>This subsection explains what traps can be implemented by handlers and what operations trigger them. Several traps return boolean values. For the traps <code>has</code> and <code>isExtensible</code>, the boolean is the result of the operation. For all other traps, the boolean indicates whether the operation succeeded or not.</p>

<p>Traps for all objects:</p>

<ul>
  <li>
<code>defineProperty(target, propKey, propDesc) : boolean</code>
    <ul>
      <li><code>Object.defineProperty(proxy, propKey, propDesc)</code></li>
    </ul>
  </li>
  <li>
<code>deleteProperty(target, propKey) : boolean</code>
    <ul>
      <li><code>delete proxy[propKey]</code></li>
      <li><code>delete proxy.foo // propKey = &apos;foo&apos;</code></li>
    </ul>
  </li>
  <li>
<code>get(target, propKey, receiver) : any</code>
    <ul>
      <li><code>receiver[propKey]</code></li>
      <li><code>receiver.foo // propKey = &apos;foo&apos;</code></li>
    </ul>
  </li>
  <li>
<code>getOwnPropertyDescriptor(target, propKey) : PropDesc|Undefined</code>
    <ul>
      <li><code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li>
    </ul>
  </li>
  <li>
<code>getPrototypeOf(target) : Object|Null</code>
    <ul>
      <li><code>Object.getPrototypeOf(proxy)</code></li>
    </ul>
  </li>
  <li>
<code>has(target, propKey) : boolean</code>
    <ul>
      <li><code>propKey in proxy</code></li>
    </ul>
  </li>
  <li>
<code>isExtensible(target) : boolean</code>
    <ul>
      <li><code>Object.isExtensible(proxy)</code></li>
    </ul>
  </li>
  <li>
<code>ownKeys(target) : Array&lt;PropertyKey&gt;</code>
    <ul>
      <li>
<code>Object.getOwnPropertyPropertyNames(proxy)</code> (only uses string keys)</li>
      <li>
<code>Object.getOwnPropertyPropertySymbols(proxy)</code> (only uses symbol keys)</li>
      <li>
<code>Object.keys(proxy)</code> (only uses enumerable string keys; enumerability is checked via <code>Object.getOwnPropertyDescriptor</code>)</li>
    </ul>
  </li>
  <li>
<code>preventExtensions(target) : boolean</code>
    <ul>
      <li><code>Object.preventExtensions(proxy)</code></li>
    </ul>
  </li>
  <li>
<code>set(target, propKey, value, receiver) : boolean</code>
    <ul>
      <li><code>receiver[propKey] = value</code></li>
      <li><code>receiver.foo = value // propKey = &apos;foo&apos;</code></li>
    </ul>
  </li>
  <li>
<code>setPrototypeOf(target, proto) : boolean</code>
    <ul>
      <li><code>Object.setPrototypeOf(proxy, proto)</code></li>
    </ul>
  </li>
</ul>

<p>Traps for functions (available if target is a function):</p>

<ul>
  <li>
<code>apply(target, thisArgument, argumentsList) : any</code>
    <ul>
      <li><code>proxy.apply(thisArgument, argumentsList)</code></li>
      <li><code>proxy.call(thisArgument, ...argumentsList)</code></li>
      <li><code>proxy(...argumentsList)</code></li>
    </ul>
  </li>
  <li>
<code>construct(target, argumentsList, newTarget) : Object</code>
    <ul>
      <li><code>new proxy(..argumentsList)</code></li>
    </ul>
  </li>
</ul>

<h5 id="_fundamental-operations-versus-derived-operations">
<span class="section-number">28.7.2.1 </span>Fundamental operations versus derived operations <a class="header-anchor" href="ch_proxies.html#_fundamental-operations-versus-derived-operations" aria-hidden="true">#</a></h5>

<p>The following operations are <em>fundamental</em>, they don&#x2019;t use other operations to do their work: <code>apply</code>, <code>defineProperty</code>, <code>deleteProperty</code>, <code>getOwnPropertyDescriptor</code>, <code>getPrototypeOf</code>, <code>isExtensible</code>, <code>ownKeys</code>, <code>preventExtensions</code>, <code>setPrototypeOf</code></p>

<p>All other operations are <em>derived</em>, they can be implemented via fundamental operations. For example, for data properties, <code>get</code> can be implemented by iterating over the prototype chain via <code>getPrototypeOf</code> and calling <code>getOwnPropertyDescriptor</code> for each chain member until either an own property is found or the chain ends.</p>

<h4 id="_invariants-of-handler-methods">
<span class="section-number">28.7.3 </span>Invariants of handler methods <a class="header-anchor" href="ch_proxies.html#_invariants-of-handler-methods" aria-hidden="true">#</a></h4>

<p>Invariants are safety constraints for handlers. This subsection documents what invariants are enforced by the proxy API and how. Whenever you read &#x201C;the handler must do X&#x201D; below, it means that a <code>TypeError</code> is thrown if it doesn&#x2019;t. Some invariants restrict return values, others restrict parameters. The correctness of a trap&#x2019;s return value is ensured in two ways: Normally, an illegal value means that a <code>TypeError</code> is thrown. But whenever a boolean is expected, coercion is used to convert non-booleans to legal values.</p>

<p>This is the complete list of invariants that are enforced:</p>

<ul>
  <li>
<code>apply(target, thisArgument, argumentsList)</code>
    <ul>
      <li>No invariants are enforced.</li>
    </ul>
  </li>
  <li>
<code>construct(target, argumentsList, newTarget)</code>
    <ul>
      <li>The result returned by the handler must be an object (not <code>null</code> or a primitive value).</li>
    </ul>
  </li>
  <li>
<code>defineProperty(target, propKey, propDesc)</code>
    <ul>
      <li>If the target is not extensible then you can&#x2019;t add properties and <code>propKey</code> must be one of the own keys of the target.</li>
      <li>If <code>propDesc</code> sets the attribute <code>configurable</code> to <code>false</code> then the target must have a non-configurable own property whose key is <code>propKey</code>.</li>
      <li>If <code>propDesc</code> were to be used to (re)define an own property for the target then that must not cause an exception. An exception is thrown if a change is forbidden by the attributes <code>writable</code> and <code>configurable</code> (non-extensibility is handled by the first rule).</li>
    </ul>
  </li>
  <li>
<code>deleteProperty(target, propKey)</code>
    <ul>
      <li>Non-configurable own properties of the target can&#x2019;t be deleted.</li>
    </ul>
  </li>
  <li>
<code>get(target, propKey, receiver)</code>
    <ul>
      <li>If the target has an own, non-writable, non-configurable data property whose key is <code>propKey</code> then the handler must return that property&#x2019;s value.</li>
      <li>If the target has an own, non-configurable, getter-less accessor property then the handler must return <code>undefined</code>.</li>
    </ul>
  </li>
  <li>
<code>getOwnPropertyDescriptor(target, propKey)</code>
    <ul>
      <li>The handler must return either an object or <code>undefined</code>.</li>
      <li>Non-configurable own properties of the target can&#x2019;t be reported as non-existent by the handler.</li>
      <li>If the target is non-extensible then exactly the target&#x2019;s own properties must be reported by the handler as existing.</li>
      <li>If the handler reports a property as non-configurable then that property must be a non-configurable own property of the target.</li>
      <li>If the result returned by the handler were used to (re)define an own property for the target then that must not cause an exception. An exception is thrown if the change is not allowed by the attributes <code>writable</code> and <code>configurable</code> (non-extensibility is handled by the third rule). Therefore, the handler can&#x2019;t report a non-configurable property as configurable and it can&#x2019;t report a different value for a non-configurable non-writable property.</li>
    </ul>
  </li>
  <li>
<code>getPrototypeOf(target)</code>
    <ul>
      <li>The result must be either an object or <code>null</code>.</li>
      <li>If the target object is not extensible then the handler must return the prototype of the target object.</li>
    </ul>
  </li>
  <li>
<code>has(target, propKey)</code>
    <ul>
      <li>A handler must not hide (report as non-existent) a non-configurable own property of the target.</li>
      <li>If the target is non-extensible then no own property of the target may be hidden.</li>
    </ul>
  </li>
  <li>
<code>isExtensible(target)</code>
    <ul>
      <li>The result returned by the handler is coerced to boolean.</li>
      <li>After coercion to boolean, the value returned by the handler must be the same as <code>target.isExtensible()</code>.</li>
    </ul>
  </li>
  <li>
<code>ownKeys(target)</code>
    <ul>
      <li>The handler must return an object, which treated as Array-like and converted into an Array.</li>
      <li>Each element of the result must be either a string or a symbol.</li>
      <li>The result must contain the keys of all non-configurable own properties of the target.</li>
      <li>If the target is not extensible then the result must contain exactly the keys of the own properties of the target (and no other values).</li>
    </ul>
  </li>
  <li>
<code>preventExtensions(target)</code>
    <ul>
      <li>The result returned by the handler is coerced to boolean.</li>
      <li>If the handler returns a truthy value (indicating a successful change) then <code>target.isExtensible()</code> must be <code>false</code> afterwards.</li>
    </ul>
  </li>
  <li>
<code>set(target, propKey, value, receiver)</code>
    <ul>
      <li>If the target has an own, non-writable, non-configurable data property whose key is <code>propKey</code> then <code>value</code> must be the same as the value of that property (i.e., the property can&#x2019;t be changed).</li>
      <li>If the target has an own, non-configurable, setter-less accessor property then a <code>TypeError</code> is thrown (i.e., such a property can&#x2019;t be set).</li>
    </ul>
  </li>
  <li>
<code>setPrototypeOf(target, proto)</code>
    <ul>
      <li>The result returned by the handler is coerced to boolean.</li>
      <li>If the target is not extensible, the prototype can&#x2019;t be changed. This is enforced as follows: If the target is not extensible and the handler returns a truthy value (indicating a successful change) then <code>proto</code> must be the same as the prototype of the target. Otherwise, a <code>TypeError</code> is thrown.</li>
    </ul>
  </li>
</ul>

<aside class="generic_inbar blurb gears icon-gears">
    <p>In the spec, the invariants are listed in the section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-proxy-object-internal-methods-and-internal-slots">Proxy Object Internal Methods and Internal Slots</a>&#x201D;.</p>

</aside>

<h4 id="_operations-that-affect-the-prototype-chain">
<span class="section-number">28.7.4 </span>Operations that affect the prototype chain <a class="header-anchor" href="ch_proxies.html#_operations-that-affect-the-prototype-chain" aria-hidden="true">#</a></h4>

<p>The following operations of normal objects perform operations on objects in the prototype chain. Therefore, if one of the objects in that chain is a proxy, its traps are triggered. The specification implements the operations as internal own methods (that are not visible to JavaScript code). But in this section, we pretend that they are normal methods that have the same names as the traps. The parameter <code>target</code> becomes the receiver of the method call.</p>

<ul>
  <li>
<code>target.get(propertyKey, receiver)</code><br>
  If <code>target</code> has no own property with the given key, <code>get</code> is invoked on the prototype of <code>target</code>.</li>
  <li>
<code>target.has(propertyKey)</code><br>
  Similarly to <code>get</code>, <code>has</code> is invoked on the prototype of <code>target</code> if <code>target</code> has no own property with the given key.</li>
  <li>
<code>target.set(propertyKey, value, receiver)</code><br>
  Similarly to <code>get</code>, <code>set</code> is invoked on the prototype of <code>target</code> if <code>target</code> has no own property with the given key.</li>
</ul>

<p>All other operations only affect own properties, they have no effect on the prototype chain.</p>

<aside class="generic_inbar blurb gears icon-gears">
    <p>In the spec, these (and other) operations are described in the section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots">Ordinary Object Internal Methods and Internal Slots</a>&#x201D;.</p>

</aside>

<h4 id="_reflect">
<span class="section-number">28.7.5 </span>Reflect <a class="header-anchor" href="ch_proxies.html#_reflect" aria-hidden="true">#</a></h4>

<p>The global object <code>Reflect</code> implements all interceptable operations of the JavaScript meta object protocol as methods. The names of those methods are the same as those of the handler methods, which, <a href="ch_proxies.html#sec_forwarding-intercepted-operations">as we have seen</a>, helps with forwarding operations from the handler to the target.</p>

<ul>
  <li>
<code>Reflect.apply(target, thisArgument, argumentsList) : any</code><br>
  Same as <code>Function.prototype.apply()</code>.</li>
  <li>
<code>Reflect.construct(target, argumentsList, newTarget=target) : Object</code><br>
  The <code>new</code> operator as a function. <code>target</code> is the constructor to invoke, the optional parameter <code>newTarget</code> points to the constructor that started the current chain of constructor calls. More information on how constructor calls are chained in ES6 is given in <a href="ch_classes.html#sec_allocating-and-initializing-instances">the chapter on classes</a>.</li>
  <li>
<code>Reflect.defineProperty(target, propertyKey, propDesc) : boolean</code><br>
  Similar to <code>Object.defineProperty()</code>.</li>
  <li>
<code>Reflect.deleteProperty(target, propertyKey) : boolean</code><br>
  The <code>delete</code> operator as a function. It works slightly differently, though: It returns <code>true</code> if it successfully deleted the property or if the property never existed. It returns <code>false</code> if the property could not be deleted and still exists. The only way to protect properties from deletion is by making them non-configurable. In sloppy mode, the <code>delete</code> operator returns the same results. But in strict mode, it throws a <code>TypeError</code> instead of returning <code>false</code>.</li>
  <li>
<code>Reflect.get(target, propertyKey, receiver=target) : any</code><br>
  A function that gets properties. The optional parameter <code>receiver</code> is needed when <code>get</code> reaches a getter later in the prototype chain. Then it provides the value for <code>this</code>.</li>
  <li>
<code>Reflect.getOwnPropertyDescriptor(target, propertyKey) : PropDesc|Undefined</code><br>
  Same as <code>Object.getOwnPropertyDescriptor()</code>.</li>
  <li>
<code>Reflect.getPrototypeOf(target) : Object|Null</code><br>
  Same as <code>Object.getPrototypeOf()</code>.</li>
  <li>
<code>Reflect.has(target, propertyKey) : boolean</code><br>
  The <code>in</code> operator as a function.</li>
  <li>
<code>Reflect.isExtensible(target) : boolean</code><br>
  Same as <code>Object.isExtensible()</code>.</li>
  <li>
<code>Reflect.ownKeys(target) : Array&lt;PropertyKey&gt;</code><br>
  Returns all own property keys (strings and symbols!) in an Array.</li>
  <li>
<code>Reflect.preventExtensions(target) : boolean</code><br>
  Similar to <code>Object.preventExtensions()</code>.</li>
  <li>
<code>Reflect.set(target, propertyKey, value, receiver=target) : boolean</code><br>
  A function that sets properties.</li>
  <li>
<code>Reflect.setPrototypeOf(target, proto) : boolean</code><br>
  The new standard way of setting the prototype of an object. The current non-standard way, that works in most engines, is to set the special property <code>__proto__</code>.</li>
</ul>

<p>Several methods have boolean results. For <code>has</code> and <code>isExtensible</code>, they are the results of the operation. For the remaining methods, they indicate whether the operation succeeded.</p>

<h5 id="_use-cases-for-reflect-besides-forwarding">
<span class="section-number">28.7.5.1 </span>Use cases for <code>Reflect</code> besides forwarding <a class="header-anchor" href="ch_proxies.html#_use-cases-for-reflect-besides-forwarding" aria-hidden="true">#</a></h5>

<p>Apart from forwarding operations, <a href="ch_proxies.html#ch_proxies_ref_4">why is <code>Reflect</code> useful [4]</a>?</p>

<ul>
  <li>Different return values: <code>Reflect</code> duplicates the following methods of <code>Object</code>, but its methods return booleans indicating whether the operation succeeded (where the <code>Object</code> methods return the object that was modified).
    <ul>
      <li><code>Object.defineProperty(obj, propKey, propDesc) : Object</code></li>
      <li><code>Object.preventExtensions(obj) : Object</code></li>
      <li><code>Object.setPrototypeOf(obj, proto) : Object</code></li>
    </ul>
  </li>
  <li>Operators as functions: The following <code>Reflect</code> methods implement functionality that is otherwise only available via operators:
    <ul>
      <li><code>Reflect.construct(target, argumentsList, newTarget=target) : Object</code></li>
      <li><code>Reflect.deleteProperty(target, propertyKey) : boolean</code></li>
      <li><code>Reflect.get(target, propertyKey, receiver=target) : any</code></li>
      <li><code>Reflect.has(target, propertyKey) : boolean</code></li>
      <li><code>Reflect.set(target, propertyKey, value, receiver=target) : boolean</code></li>
    </ul>
  </li>
  <li>Shorter version of <code>apply()</code>: If you want to be completely safe about invoking the method <code>apply()</code> on a function, you can&#x2019;t do so via dynamic dispatch, because the function may have an own property with the key <code>&apos;apply&apos;</code>:
    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="nx">func</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">thisArg</code><code class="p">,</code> <code class="nx">argArray</code><code class="p">)</code> <code class="c1">// not safe</code>
  <code class="nb">Function</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">apply</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">func</code><code class="p">,</code> <code class="nx">thisArg</code><code class="p">,</code> <code class="nx">argArray</code><code class="p">)</code> <code class="c1">// safe</code>
</pre></div>

    </figure>

    <p>Using <code>Reflect.apply()</code> is shorter:</p>

    <figure class="code">
<div class="highlight"><pre><code></code>  <code class="nx">Reflect</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">func</code><code class="p">,</code> <code class="nx">thisArg</code><code class="p">,</code> <code class="nx">argArray</code><code class="p">)</code>
</pre></div>

    </figure>
  </li>
  <li>No exceptions when deleting properties: the <code>delete</code> operator throws in strict mode if you try to delete a non-configurable own property. <code>Reflect.deleteProperty()</code> returns <code>false</code> in that case.</li>
</ul>

<h5 id="_object-versus-reflect">
<span class="section-number">28.7.5.2 </span><code>Object.*</code> versus <code>Reflect.*</code>
 <a class="header-anchor" href="ch_proxies.html#_object-versus-reflect" aria-hidden="true">#</a></h5>

<p>Going forward, <code>Object</code> will host operations that are of interest to normal applications, while <code>Reflect</code> will host operations that are more low-level.</p>


<h3 id="sec_conclusion-proxies">
<span class="section-number">28.8 </span>Conclusion <a class="header-anchor" href="ch_proxies.html#sec_conclusion-proxies" aria-hidden="true">#</a></h3>

<p>This concludes our in-depth look at the proxy API. For each application, you have to take performance into consideration and &#x2013; if necessary &#x2013; measure. Proxies may not always be fast enough. On the other hand, performance is often not crucial and it is nice to have the metaprogramming power that proxies give us. As we have seen, there are numerous use cases they can help with.</p>


<h3 id="sec_further-reading-proxies">
<span class="section-number">28.9 </span>Further reading <a class="header-anchor" href="ch_proxies.html#sec_further-reading-proxies" aria-hidden="true">#</a></h3>

<p id="ch_proxies_ref_1">[1] &#x201C;<a href="http://soft.vub.ac.be/Publications/2012/vub-soft-tr-12-03.pdf">On the design of the ECMAScript Reflection API</a>&#x201D; by Tom Van Cutsem and Mark Miller. Technical report, 2012. [Important source of this chapter.]</p>

<p id="ch_proxies_ref_2">[2] &#x201C;<a href="http://mitpress.mit.edu/books/art-metaobject-protocol">The Art of the Metaobject Protocol</a>&#x201D; by Gregor Kiczales, Jim des Rivieres and Daniel G. Bobrow. Book, 1991.</p>

<p id="ch_proxies_ref_3">[3] &#x201C;<a href="http://www.pearsonhighered.com/educator/product/Putting-Metaclasses-to-Work-A-New-Dimension-in-ObjectOriented-Programming/9780201433050.page">Putting Metaclasses to Work: A New Dimension in Object-Oriented Programming</a>&#x201D; by Ira R. Forman and Scott H. Danforth. Book, 1999.</p>

<p id="ch_proxies_ref_4">[4] &#x201C;<a href="https://github.com/tvcutsem/harmony-reflect/wiki">Harmony-reflect: Why should I use this library?</a>&#x201D; by Tom Van Cutsem. [Explains why <code>Reflect</code> is useful.]</p>






<div class="next-chapter">
    Next: <a href="ch_coding-style.html">29. Coding style tips for ECMAScript 6</a>
</div>


</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59555947-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
