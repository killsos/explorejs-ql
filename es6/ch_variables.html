<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>9. Variables and scoping</title>
    <link href="stylesheet.css" type="text/css" rel="stylesheet" />
    <link rel="icon" href="images/favicon-128.png" sizes="128x128">
    <link rel="icon" href="images/favicon-32.png" sizes="32x32">
    <link rel="icon" href="images/favicon-16.png" sizes="16x16">
</head>
<body>

<div id="top-bar">
</div>
<div id="top-bar">
    <div id="top-bar-content">
        <b>9. Variables and scoping</b><br>
        <a href="index.html#toc_ch_variables">Table of contents</a><br>
        Please support this book:
        <a href="https://leanpub.com/exploring-es6/">buy it (PDF, EPUB, MOBI)</a>
        or
        <a href="http://www.2ality.com/p/donate.html">donate</a>
    </div>
</div>

<div id="adbox">
<div id="adbox-explain">(Ad, please donâ€™t block.)</div>

    <script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=exploringjscom" id="_carbonads_js"></script>

</div>

<div id="page-content">


<h2 id="ch_variables">
<span class="section-number">9. </span>Variables and scoping <a class="header-anchor" href="ch_variables.html#ch_variables" aria-hidden="true">#</a></h2>

<hr class="scene-break">

<ul>
  <li>9.1. <a href="ch_variables.html#sec_overview-variables">Overview</a>
    <ul>
      <li>9.1.1. <code>let</code>
</li>
      <li>9.1.2. <code>const</code>
</li>
      <li>9.1.3. Ways of declaring variables</li>
    </ul>
  </li>
  <li>9.2. <a href="ch_variables.html#sec_let-const">Block scoping via <code>let</code> and <code>const</code></a>
</li>
  <li>9.3. <a href="ch_variables.html#sec_const-immutability"><code>const</code> creates immutable variables</a>
    <ul>
      <li>9.3.1. Pitfall: <code>const</code> does not make the value immutable</li>
      <li>9.3.2. <code>const</code> in loop bodies</li>
    </ul>
  </li>
  <li>9.4. <a href="ch_variables.html#sec_temporal-dead-zone">The temporal dead zone</a>
    <ul>
      <li>9.4.1. The life cycle of <code>var</code>-declared variables</li>
      <li>9.4.2. The life cycle of <code>let</code>-declared variables</li>
      <li>9.4.3. Examples</li>
      <li>9.4.4. <code>typeof</code> throws a <code>ReferenceError</code> for a variable in the TDZ</li>
      <li>9.4.5. Why is there a temporal dead zone?</li>
      <li>9.4.6. Further reading</li>
    </ul>
  </li>
  <li>9.5. <a href="ch_variables.html#sec_let-const-loop-heads"><code>let</code> and <code>const</code> in loop heads</a>
    <ul>
      <li>9.5.1. <code>for</code> loop</li>
      <li>9.5.2. <code>for-of</code> loop and <code>for-in</code> loop</li>
      <li>9.5.3. Why are per-iteration bindings useful?</li>
    </ul>
  </li>
  <li>9.6. <a href="ch_variables.html#sec_parameters-as-variables">Parameters as variables</a>
    <ul>
      <li>9.6.1. Parameters versus local variables</li>
      <li>9.6.2. Parameter default values and the temporal dead zone</li>
      <li>9.6.3. Parameter default values don&#x2019;t see the scope of the body</li>
    </ul>
  </li>
  <li>9.7. <a href="ch_variables.html#sect_global-object">The global object</a>
</li>
  <li>9.8. <a href="ch_variables.html#sec_func-decl-class-decl">Function declarations and class declarations</a>
</li>
  <li>9.9. <a href="ch_variables.html#const-vs-let-vs-var">Coding style: <code>const</code> versus <code>let</code> versus <code>var</code></a>
    <ul>
      <li>9.9.1. An alternative approach</li>
    </ul>
  </li>
</ul>

<hr class="scene-break">


<h3 id="sec_overview-variables">
<span class="section-number">9.1 </span>Overview <a class="header-anchor" href="ch_variables.html#sec_overview-variables" aria-hidden="true">#</a></h3>

<p>ES6 provides two new ways of declaring variables: <code>let</code> and <code>const</code>, which mostly replace the ES5 way of declaring variables, <code>var</code>.</p>

<h4 id="_let">
<span class="section-number">9.1.1 </span><code>let</code>
 <a class="header-anchor" href="ch_variables.html#_let" aria-hidden="true">#</a></h4>

<p><code>let</code> works similarly to <code>var</code>, but the variable it declares is <em>block-scoped</em>,  it only exists within the current block. <code>var</code> is <em>function-scoped</em>.</p>

<p>In the following code, you can see that the <code>let</code>-declared variable <code>tmp</code> only exists inside the block that starts in line A:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">order</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// (A)</code>
        <code class="kd">let</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>
        <code class="nx">x</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>
        <code class="nx">y</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="o">===</code><code class="nx">x</code><code class="p">);</code> <code class="c1">// ReferenceError: tmp is not defined</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">];</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_const">
<span class="section-number">9.1.2 </span><code>const</code>
 <a class="header-anchor" href="ch_variables.html#_const" aria-hidden="true">#</a></h4>

<p><code>const</code> works like <code>let</code>, but the variable you declare must be immediately initialized, with a value that can&#x2019;t be changed afterwards.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foo</code><code class="p">;</code>
    <code class="c1">// SyntaxError: missing = in const declaration</code>

<code class="kr">const</code> <code class="nx">bar</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="nx">bar</code> <code class="o">=</code> <code class="mi">456</code><code class="p">;</code>
    <code class="c1">// TypeError: `bar` is read-only</code>
</pre></div>

</figure>

<p>Since <code>for-of</code> creates one <em>binding</em> (storage space for a variable) per loop iteration, it is OK to <code>const</code>-declare the loop variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="p">[</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">])</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// a</code>
<code class="c1">// b</code>
</pre></div>

</figure>

<h4 id="_ways-of-declaring-variables">
<span class="section-number">9.1.3 </span>Ways of declaring variables <a class="header-anchor" href="ch_variables.html#_ways-of-declaring-variables" aria-hidden="true">#</a></h4>

<p>The following table gives an overview of six ways in which variables can be declared in ES6 (inspired by <a href="https://twitter.com/kangax/status/567330097603284992">a table by kangax</a>):</p>

<table>
  <thead>
    <tr>
      <th>&#xA0;</th>
      <th>Hoisting</th>
      <th>Scope</th>
      <th>Creates global properties</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>var</code></td>
      <td>Declaration</td>
      <td>Function</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><code>let</code></td>
      <td>Temporal dead zone</td>
      <td>Block</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>const</code></td>
      <td>Temporal dead zone</td>
      <td>Block</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>function</code></td>
      <td>Complete</td>
      <td>Block</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td><code>class</code></td>
      <td>No</td>
      <td>Block</td>
      <td>No</td>
    </tr>
    <tr>
      <td><code>import</code></td>
      <td>Complete</td>
      <td>Module-global</td>
      <td>No</td>
    </tr>
  </tbody>

</table>


<h3 id="sec_let-const">
<span class="section-number">9.2 </span>Block scoping via <code>let</code> and <code>const</code>
 <a class="header-anchor" href="ch_variables.html#sec_let-const" aria-hidden="true">#</a></h3>

<p>Both <code>let</code> and <code>const</code> create variables that are <em>block-scoped</em> &#x2013; they only exist within the innermost block that surrounds them. The following code demonstrates that the <code>const</code>-declared variable <code>tmp</code> only exists inside the block of the <code>if</code> statement:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// ReferenceError: tmp is not defined</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In contrast, <code>var</code>-declared variables are function-scoped:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// 123</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Block scoping means that you can shadow variables within a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="err">&#xB7;&#xB7;&#xB7;</code><code class="p">)</code> <code class="p">{</code>
     <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code> <code class="c1">// shadows outer `foo`</code>
     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// 10</code>
  <code class="p">}</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// 5</code>
<code class="p">}</code>
</pre></div>

</figure>


<h3 id="sec_const-immutability">
<span class="section-number">9.3 </span><code>const</code> creates immutable variables <a class="header-anchor" href="ch_variables.html#sec_const-immutability" aria-hidden="true">#</a></h3>

<p>Variables created by <code>let</code> are mutable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;abc&apos;</code><code class="p">;</code>
<code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;def&apos;</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// def</code>
</pre></div>

</figure>

<p>Constants, variables created by <code>const</code>, are immutable &#x2013; you can&#x2019;t assign different values to them:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;abc&apos;</code><code class="p">;</code>
<code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;def&apos;</code><code class="p">;</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<aside class="generic_inbar blurb gears icon-gears">
    <h3 id="_spec-detail-changing-a-const-variable-always-throws-a-typeerror">Spec detail: changing a <code>const</code> variable always throws a <code>TypeError</code>
 <a class="header-anchor" href="ch_variables.html#_spec-detail-changing-a-const-variable-always-throws-a-typeerror" aria-hidden="true">#</a></h3>

  <p>Normally, changing an immutable binding only causes an exception in strict mode, as per <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-declarative-environment-records-setmutablebinding-n-v-s"><code>SetMutableBinding()</code></a>. But <code>const</code>-declared variables always produce strict bindings &#x2013; see <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-functiondeclarationinstantiation"><code>FunctionDeclarationInstantiation(func, argumentsList)</code></a>, step 35.b.i.1.</p>

</aside>

<h4 id="_pitfall-const-does-not-make-the-value-immutable">
<span class="section-number">9.3.1 </span>Pitfall: <code>const</code> does not make the value immutable <a class="header-anchor" href="ch_variables.html#_pitfall-const-does-not-make-the-value-immutable" aria-hidden="true">#</a></h4>

<p><code>const</code> only means that a variable always has the same value, but it does not mean that the value itself is or becomes immutable. For example, <code>obj</code> is a constant, but the value it points to is mutable &#x2013; we can add a property to it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">prop</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">prop</code><code class="p">);</code> <code class="c1">// 123</code>
</pre></div>

</figure>

<p>We cannot, however, assign a different value to <code>obj</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<p>If you want the value of <code>obj</code> to be immutable, you have to take care of it, yourself. For example, by <a href="http://speakingjs.com/es5/ch17.html#freezing_objects">freezing it</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">freeze</code><code class="p">({});</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">prop</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// TypeError</code>
</pre></div>

</figure>

<h5 id="_pitfall-objectfreeze-is-shallow">
<span class="section-number">9.3.1.1 </span>Pitfall: <code>Object.freeze()</code> is shallow <a class="header-anchor" href="ch_variables.html#_pitfall-objectfreeze-is-shallow" aria-hidden="true">#</a></h5>

<p>Keep in mind that <code>Object.freeze()</code> is <em>shallow</em>, it only freezes the properties of its argument, not the objects stored in its properties. For example, the object <code>obj</code> is frozen:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="nt">const</code> <code class="nt">obj</code> <code class="o">=</code> <code class="nt">Object</code><code class="nc">.freeze</code><code class="o">(</code><code class="p">{</code> <code class="n">foo</code><code class="o">:</code> <code class="err">{</code><code class="p">}</code> <code class="err">}</code><code class="o">);</code>
<code class="o">&gt;</code> <code class="nt">obj</code><code class="nc">.bar</code> <code class="o">=</code> <code class="nt">123</code>
<code class="nt">TypeError</code><code class="o">:</code> <code class="nt">Can</code><code class="s1">&apos;t add property bar, object is not extensible</code>
<code class="s1">&gt; obj.foo = {}</code>
<code class="s1">TypeError: Cannot assign to read only property &apos;</code><code class="nt">foo</code><code class="err">&apos;</code> <code class="nt">of</code> <code class="err">#</code><code class="o">&lt;</code><code class="nt">Object</code><code class="o">&gt;</code>
</pre></div>

</figure>

<p>But the object <code>obj.foo</code> is not.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; obj.foo.qux = &apos;abc&apos;;
&gt; obj.foo.qux
&apos;abc&apos;
</pre></div>

</figure>

<h4 id="_const-in-loop-bodies">
<span class="section-number">9.3.2 </span><code>const</code> in loop bodies <a class="header-anchor" href="ch_variables.html#_const-in-loop-bodies" aria-hidden="true">#</a></h4>

<p>Once a <code>const</code> variable has been created, it can&#x2019;t be changed. But that doesn&#x2019;t mean that you can&#x2019;t re-enter its scope and start fresh, with a new value. For example, via a loop:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">logArgs</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="p">[</code><code class="nx">index</code><code class="p">,</code> <code class="nx">elem</code><code class="p">]</code> <code class="k">of</code> <code class="nx">args</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code> <code class="c1">// (A)</code>
        <code class="kr">const</code> <code class="nx">message</code> <code class="o">=</code> <code class="nx">index</code> <code class="o">+</code> <code class="s1">&apos;. &apos;</code> <code class="o">+</code> <code class="nx">elem</code><code class="p">;</code> <code class="c1">// (B)</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="nx">logArgs</code><code class="p">(</code><code class="s1">&apos;Hello&apos;</code><code class="p">,</code> <code class="s1">&apos;everyone&apos;</code><code class="p">);</code>

<code class="c1">// Output:</code>
<code class="c1">// 0. Hello</code>
<code class="c1">// 1. everyone</code>
</pre></div>

</figure>

<p>There are two <code>const</code> declarations in this code, in line A and in line B. And during each loop iteration, their constants have different values.</p>


<h3 id="sec_temporal-dead-zone">
<span class="section-number">9.4 </span>The temporal dead zone <a class="header-anchor" href="ch_variables.html#sec_temporal-dead-zone" aria-hidden="true">#</a></h3>

<p>A variable declared by <code>let</code> or <code>const</code> has a so-called <em>temporal dead zone</em> (TDZ): When entering its scope, it can&#x2019;t be accessed (got or set) until execution reaches the declaration. Let&#x2019;s compare the life cycles of <code>var</code>-declared variables (which don&#x2019;t have TDZs) and <code>let</code>-declared variables (which have TDZs).</p>

<h4 id="_the-life-cycle-of-var-declared-variables">
<span class="section-number">9.4.1 </span>The life cycle of <code>var</code>-declared variables <a class="header-anchor" href="ch_variables.html#_the-life-cycle-of-var-declared-variables" aria-hidden="true">#</a></h4>

<p><code>var</code> variables don&#x2019;t have temporal dead zones. Their life cycle comprises the following steps:</p>

<ul>
  <li>When the scope (its surrounding function) of a <code>var</code> variable is entered, storage space (a <em>binding</em>) is created for it. The variable is immediately initialized, by setting it to <code>undefined</code>.</li>
  <li>When the execution within the scope reaches the declaration, the variable is set to the value specified by the <em>initializer</em> (an assignment) &#x2013; if there is one. If there isn&#x2019;t, the value of the variable remains <code>undefined</code>.</li>
</ul>

<h4 id="_the-life-cycle-of-let-declared-variables">
<span class="section-number">9.4.2 </span>The life cycle of <code>let</code>-declared variables <a class="header-anchor" href="ch_variables.html#_the-life-cycle-of-let-declared-variables" aria-hidden="true">#</a></h4>

<p>Variables declared via <code>let</code> have temporal dead zones and their life cycle looks like this:</p>

<ul>
  <li>When the scope (its surrounding block) of a <code>let</code> variable is entered, storage space (a <em>binding</em>) is created for it. The variable remains uninitialized.</li>
  <li>Getting or setting an uninitialized variable causes a <code>ReferenceError</code>.</li>
  <li>When the execution within the scope reaches the declaration, the variable is set to the value specified by the <em>initializer</em> (an assignment) &#x2013; if there is one. If there isn&#x2019;t then the value of the variable is set to <code>undefined</code>.</li>
</ul>

<p><code>const</code> variables work similarly to <code>let</code> variables, but they must have an initializer (i.e., be set to a value immediately) and can&#x2019;t be changed.</p>

<h4 id="_examples">
<span class="section-number">9.4.3 </span>Examples <a class="header-anchor" href="ch_variables.html#_examples" aria-hidden="true">#</a></h4>

<p>Within a TDZ, an exception is thrown if a variable is got or set:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// enter new scope, TDZ starts</code>
    <code class="c1">// Uninitialized binding for `tmp` is created</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// ReferenceError</code>

    <code class="kd">let</code> <code class="nx">tmp</code><code class="p">;</code> <code class="c1">// TDZ ends, `tmp` is initialized with `undefined`</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// undefined</code>

    <code class="nx">tmp</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// 123</code>
<code class="p">}</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tmp</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</figure>

<p>If there is an initializer then the TDZ ends <em>after</em> the initializer was evaluated and the result was assigned to the variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">foo</code> <code class="o">=</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">);</code> <code class="c1">// ReferenceError</code>
</pre></div>

</figure>

<p>The following code demonstrates that the dead zone is really <em>temporal</em> (based on time) and not spatial (based on location):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// enter new scope, TDZ starts</code>
    <code class="kr">const</code> <code class="nx">func</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">myVar</code><code class="p">);</code> <code class="c1">// OK!</code>
    <code class="p">};</code>

    <code class="c1">// Here we are within the TDZ and</code>
    <code class="c1">// accessing `myVar` would cause a `ReferenceError`</code>

    <code class="kd">let</code> <code class="nx">myVar</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code> <code class="c1">// TDZ ends</code>
    <code class="nx">func</code><code class="p">();</code> <code class="c1">// called outside TDZ</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_typeof-throws-a-referenceerror-for-a-variable-in-the-tdz">
<span class="section-number">9.4.4 </span><code>typeof</code> throws a <code>ReferenceError</code> for a variable in the TDZ <a class="header-anchor" href="ch_variables.html#_typeof-throws-a-referenceerror-for-a-variable-in-the-tdz" aria-hidden="true">#</a></h4>

<p>If you access a variable in the temporal dead zone via <code>typeof</code>, you get an exception:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">foo</code><code class="p">);</code> <code class="c1">// ReferenceError (TDZ)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">aVariableThatDoesntExist</code><code class="p">);</code> <code class="c1">// &apos;undefined&apos;</code>
    <code class="kd">let</code> <code class="nx">foo</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Why? The rationale is as follows: <code>foo</code> is not undeclared, it is uninitialized. You should be aware of its existence, but aren&#x2019;t. Therefore, being warned seems desirable.</p>

<p>Furthermore, this kind of check is only useful for conditionally creating global variables. That is something that you don&#x2019;t need to do in normal programs.</p>

<h5 id="_conditionally-creating-variables">
<span class="section-number">9.4.4.1 </span>Conditionally creating variables <a class="header-anchor" href="ch_variables.html#_conditionally-creating-variables" aria-hidden="true">#</a></h5>

<p>When it comes to conditionally creating variables, you have two options.</p>

<p>
  <strong>Option 1 &#x2013; <code>typeof</code> and <code>var</code>:</strong>
</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">someGlobal</code> <code class="o">===</code> <code class="s1">&apos;undefined&apos;</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">someGlobal</code> <code class="o">=</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This option only works in global scope (and therefore not inside ES6 modules).</p>

<p>
  <strong>Option 2 &#x2013; <code>window</code>:</strong>
</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="s1">&apos;someGlobal&apos;</code> <code class="k">in</code> <code class="nb">window</code><code class="p">))</code> <code class="p">{</code>
    <code class="nb">window</code><code class="p">.</code><code class="nx">someGlobal</code> <code class="o">=</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_why-is-there-a-temporal-dead-zone">
<span class="section-number">9.4.5 </span>Why is there a temporal dead zone? <a class="header-anchor" href="ch_variables.html#_why-is-there-a-temporal-dead-zone" aria-hidden="true">#</a></h4>

<p>There are several reasons why <code>const</code> and <code>let</code> have temporal dead zones:</p>

<ul>
  <li>To catch programming errors: Being able to access a variable before its declaration is strange. If you do so, it is normally by accident and you should be warned about it.</li>
  <li>For <code>const</code>: Making <code>const</code> work properly is difficult. <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-September/024996.html">Quoting Allen Wirfs-Brock</a>: &#x201C;TDZs &#x2026; provide a rational semantics for <code>const</code>. There was significant technical discussion of that topic and TDZs emerged as the best solution.&#x201D; <code>let</code> also has a temporal dead zone so that switching between <code>let</code> and <code>const</code> doesn&#x2019;t change behavior in unexpected ways.</li>
  <li>Future-proofing for guards: JavaScript may eventually have <em>guards</em>, a mechanism for enforcing at runtime that a variable has the correct value (think runtime type check). If the value of a variable is <code>undefined</code> before its declaration then that value may be in conflict with the guarantee given by its guard.</li>
</ul>

<h4 id="_further-reading">
<span class="section-number">9.4.6 </span>Further reading <a class="header-anchor" href="ch_variables.html#_further-reading" aria-hidden="true">#</a></h4>

<p>Sources of this section:</p>

<ul>
  <li>&#x201C;<a href="https://esdiscuss.org/topic/performance-concern-with-let-const">Performance concern with let/const</a>&#x201D;</li>
  <li>&#x201C;<a href="https://bugs.ecmascript.org/show_bug.cgi?id=3009">Bug 3009 &#x2013; typeof on TDZ variable</a>&#x201D;</li>
</ul>


<h3 id="sec_let-const-loop-heads">
<span class="section-number">9.5 </span><code>let</code> and <code>const</code> in loop heads <a class="header-anchor" href="ch_variables.html#sec_let-const-loop-heads" aria-hidden="true">#</a></h3>

<p>The following loops allow you to declare variables in their heads:</p>

<ul>
  <li><code>for</code></li>
  <li><code>for-in</code></li>
  <li><code>for-of</code></li>
</ul>

<p>To make a declaration, you can use either <code>var</code>, <code>let</code> or <code>const</code>. Each of them has a different effect, as I&#x2019;ll explain next.</p>

<h4 id="_for-loop">
<span class="section-number">9.5.1 </span><code>for</code> loop <a class="header-anchor" href="ch_variables.html#_for-loop" aria-hidden="true">#</a></h4>

<p><code>var</code>-declaring a variable in the head of a <code>for</code> loop creates a single <em>binding</em> (storage space) for that variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">arr</code><code class="p">.</code><code class="nx">push</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">());</code> <code class="c1">// [3,3,3]</code>
</pre></div>

</figure>

<p>Every <code>i</code> in the bodies of the three arrow functions refers to the same binding, which is why they all return the same value.</p>

<p>If you <code>let</code>-declare a variable, a new binding is created for each loop iteration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">arr</code><code class="p">.</code><code class="nx">push</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">());</code> <code class="c1">// [0,1,2]</code>
</pre></div>

</figure>

<p>This time, each <code>i</code> refers to the binding of one specific iteration and preserves the value that was current at that time. Therefore, each arrow function returns a different value.</p>

<p><code>const</code> works like <code>var</code>, but you can&#x2019;t change the initial value of a <code>const</code>-declared variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code>// TypeError: Assignment to constant variable
// (due to i++)
for (const i=0; i&lt;3; i++) {
    console.log(i);
}
</pre></div>

</figure>

<p>Getting a fresh binding for each iteration may seem strange at first, but it is very useful whenever you use loops to create functions that refer to loop variables, as explained in <a href="ch_variables.html#sec_rationale-per-iteration-bindings">a later section</a>.</p>

<aside class="generic_inbar blurb gears icon-gears">
    <h3 id="_for-loop-per-iteration-bindings-in-the-spec">
<code>for</code> loop: per-iteration bindings in the spec <a class="header-anchor" href="ch_variables.html#_for-loop-per-iteration-bindings-in-the-spec" aria-hidden="true">#</a></h3>

  <p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation">The evaluation of the <code>for</code> loop</a> handles <code>var</code> as the second case and <code>let</code>/<code>const</code> as the third case. Only <code>let</code>-declared variables are added to the list <code>perIterationLets</code> (step 9), which is passed to <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-forbodyevaluation"><code>ForBodyEvaluation()</code></a> as the second-to-last parameter, <code>perIterationBindings</code>.</p>

</aside>

<h4 id="_for-of-loop-and-for-in-loop">
<span class="section-number">9.5.2 </span><code>for-of</code> loop and <code>for-in</code> loop <a class="header-anchor" href="ch_variables.html#_for-of-loop-and-for-in-loop" aria-hidden="true">#</a></h4>

<p>In a <code>for-of</code> loop, <code>var</code> creates a single binding:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="k">of</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code> <code class="p">{</code>
    <code class="nx">arr</code><code class="p">.</code><code class="nx">push</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">());</code> <code class="c1">// [2,2,2]</code>
</pre></div>

</figure>

<p><code>const</code> creates one immutable binding per iteration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code> <code class="p">{</code>
    <code class="nx">arr</code><code class="p">.</code><code class="nx">push</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">());</code> <code class="c1">// [0,1,2]</code>
</pre></div>

</figure>

<p><code>let</code> also creates one binding per iteration, but the bindings it creates are mutable.</p>

<p>The <code>for-in</code> loop works similarly to the <code>for-of</code> loop.</p>

<aside class="generic_inbar blurb gears icon-gears">
    <h3 id="_for-of-loop-per-iteration-bindings-in-the-spec">
<code>for-of</code> loop: per-iteration bindings in the spec <a class="header-anchor" href="ch_variables.html#_for-of-loop-per-iteration-bindings-in-the-spec" aria-hidden="true">#</a></h3>

  <p>Per-iteration bindings in <code>for-of</code> are handled by <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset"><code>ForIn/OfBodyEvaluation</code></a>. In step 5.b, a new environment is created and bindings are added to it via <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-runtime-semantics-bindinginstantiation"><code>BindingInstantiation</code></a> (mutable for <code>let</code>, immutable for <code>const</code>). The current iteration value is stored in the variable <code>nextValue</code> and used to initialize the bindings in either one of two ways:</p>

  <ul>
    <li>Declaration of single variable (step 5.h.i): is handled via <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-initializereferencedbinding"><code>InitializeReferencedBinding</code></a>
</li>
    <li>Destructuring (step 5.i.iii): is handled via <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization">one case of <code>BindingInitialization</code></a> (<code>ForDeclaration</code>), which invokes <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization">another case of <code>BindingInitialization</code></a> (<code>BindingPattern</code>).</li>
  </ul>

</aside>

<h4 id="sec_rationale-per-iteration-bindings">
<span class="section-number">9.5.3 </span>Why are per-iteration bindings useful? <a class="header-anchor" href="ch_variables.html#sec_rationale-per-iteration-bindings" aria-hidden="true">#</a></h4>

<p>The following is an HTML page that displays three links:</p>

<ol class="numeric">
  <li>If you click on &#x201C;yes&#x201D;, it is translated to &#x201C;ja&#x201D;.</li>
  <li>If you click on &#x201C;no&#x201D;, it is translated to &#x201C;nein&#x201D;.</li>
  <li>If you click on &#x201C;perhaps&#x201D;, it is translated to &#x201C;vielleicht&#x201D;.</li>
</ol>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&lt;!</code><code class="nx">doctype</code> <code class="nx">html</code><code class="o">&gt;</code>
<code class="o">&lt;</code><code class="nx">html</code><code class="o">&gt;</code>
<code class="o">&lt;</code><code class="nx">head</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="nx">meta</code> <code class="nx">charset</code><code class="o">=</code><code class="s2">&quot;UTF-8&quot;</code><code class="o">&gt;</code>
<code class="o">&lt;</code><code class="err">/head&gt;</code>
<code class="o">&lt;</code><code class="nx">body</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">id</code><code class="o">=</code><code class="s2">&quot;content&quot;</code><code class="o">&gt;&lt;</code><code class="err">/div&gt;</code>
    <code class="o">&lt;</code><code class="nx">script</code><code class="o">&gt;</code>
        <code class="kr">const</code> <code class="nx">entries</code> <code class="o">=</code> <code class="p">[</code>
            <code class="p">[</code><code class="s1">&apos;yes&apos;</code><code class="p">,</code> <code class="s1">&apos;ja&apos;</code><code class="p">],</code>
            <code class="p">[</code><code class="s1">&apos;no&apos;</code><code class="p">,</code> <code class="s1">&apos;nein&apos;</code><code class="p">],</code>
            <code class="p">[</code><code class="s1">&apos;perhaps&apos;</code><code class="p">,</code> <code class="s1">&apos;vielleicht&apos;</code><code class="p">],</code>
        <code class="p">];</code>
        <code class="kr">const</code> <code class="nx">content</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">&apos;content&apos;</code><code class="p">);</code>
        <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="p">[</code><code class="nx">source</code><code class="p">,</code> <code class="nx">target</code><code class="p">]</code> <code class="k">of</code> <code class="nx">entries</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// (A)</code>
            <code class="nx">content</code><code class="p">.</code><code class="nx">insertAdjacentHTML</code><code class="p">(</code><code class="s1">&apos;beforeend&apos;</code><code class="p">,</code>
                <code class="sb">`&lt;div&gt;&lt;a id=&quot;</code><code class="si">${</code><code class="nx">source</code><code class="si">}</code><code class="sb">&quot; href=&quot;&quot;&gt;</code><code class="si">${</code><code class="nx">source</code><code class="si">}</code><code class="sb">&lt;/a&gt;&lt;/div&gt;`</code><code class="p">);</code>
            <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">source</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code>
                <code class="s1">&apos;click&apos;</code><code class="p">,</code> <code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>
                    <code class="nx">alert</code><code class="p">(</code><code class="nx">target</code><code class="p">);</code> <code class="c1">// (B)</code>
                <code class="p">});</code>
        <code class="p">}</code>
    <code class="o">&lt;</code><code class="err">/script&gt;</code>
<code class="o">&lt;</code><code class="err">/body&gt;</code>
<code class="o">&lt;</code><code class="err">/html&gt;</code>
</pre></div>

</figure>

<p>What is displayed depends on the variable <code>target</code> (line B). If we had used <code>var</code> instead of <code>const</code> in line A, there would be a single binding for the whole loop and <code>target</code> would have the value <code>&apos;vielleicht&apos;</code>, afterwards. Therefore, no matter what link you click on, you would always get the translation <code>&apos;vielleicht&apos;</code>.</p>

<p>Thankfully, with <code>const</code>, we get one binding per loop iteration and the translations are displayed correctly.</p>


<h3 id="sec_parameters-as-variables">
<span class="section-number">9.6 </span>Parameters as variables <a class="header-anchor" href="ch_variables.html#sec_parameters-as-variables" aria-hidden="true">#</a></h3>

<h4 id="_parameters-versus-local-variables">
<span class="section-number">9.6.1 </span>Parameters versus local variables <a class="header-anchor" href="ch_variables.html#_parameters-versus-local-variables" aria-hidden="true">#</a></h4>

<p>If you <code>let</code>-declare a variable that has the same name as a parameter, you get a static (load-time) error:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">arg</code><code class="p">;</code> <code class="c1">// static error: duplicate declaration of `arg`</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Doing the same inside a block shadows the parameter:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">arg</code><code class="p">;</code> <code class="c1">// shadows parameter `arg`</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In contrast, <code>var</code>-declaring a variable that has the same name as a parameter does nothing, just like re-declaring a <code>var</code> variable within the same scope does nothing.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">arg</code><code class="p">;</code> <code class="c1">// does nothing</code>
<code class="p">}</code>
</pre></div>

</figure>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">func</code><code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">{</code>
        <code class="c1">// We are still in same `var` scope as `arg`</code>
        <code class="kd">var</code> <code class="nx">arg</code><code class="p">;</code> <code class="c1">// does nothing</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_parameter-default-values-and-the-temporal-dead-zone">
<span class="section-number">9.6.2 </span>Parameter default values and the temporal dead zone <a class="header-anchor" href="ch_variables.html#_parameter-default-values-and-the-temporal-dead-zone" aria-hidden="true">#</a></h4>

<p>If parameters have default values, they are treated like a sequence of <code>let</code> statements and are subject to temporal dead zones:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// OK: `y` accesses `x` after it has been declared</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">=</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">];</code>
<code class="p">}</code>
<code class="nx">foo</code><code class="p">();</code> <code class="c1">// [1,1]</code>

<code class="c1">// Exception: `x` tries to access `y` within TDZ</code>
<code class="kd">function</code> <code class="nx">bar</code><code class="p">(</code><code class="nx">x</code><code class="o">=</code><code class="nx">y</code><code class="p">,</code> <code class="nx">y</code><code class="o">=</code><code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">];</code>
<code class="p">}</code>
<code class="nx">bar</code><code class="p">();</code> <code class="c1">// ReferenceError</code>
</pre></div>

</figure>

<h4 id="_parameter-default-values-dont-see-the-scope-of-the-body">
<span class="section-number">9.6.3 </span>Parameter default values don&#x2019;t see the scope of the body <a class="header-anchor" href="ch_variables.html#_parameter-default-values-dont-see-the-scope-of-the-body" aria-hidden="true">#</a></h4>

<p>The scope of parameter default values is separate from the scope of the body (the former surrounds the latter). That means that methods or functions defined &#x201C;inside&#x201D; parameter default values don&#x2019;t see the local variables of the body:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;outer&apos;</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">bar</code><code class="p">(</code><code class="nx">func</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">foo</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="s1">&apos;inner&apos;</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">func</code><code class="p">());</code> <code class="c1">// outer</code>
<code class="p">}</code>
<code class="nx">bar</code><code class="p">();</code>
</pre></div>

</figure>


<h3 id="sect_global-object">
<span class="section-number">9.7 </span>The global object <a class="header-anchor" href="ch_variables.html#sect_global-object" aria-hidden="true">#</a></h3>

<p>JavaScript&#x2019;s <a href="http://speakingjs.com/es5/ch16.html#global_object">global object</a> (<code>window</code> in web browsers, <code>global</code> in Node.js) is more a bug than a feature, especially with regard to performance. That&#x2019;s why it makes sense that ES6 introduces a distinction:</p>

<ul>
  <li>All properties of the global object are global variables. In global scope, the following declarations create such properties:
    <ul>
      <li>
<code>var</code> declarations</li>
      <li>Function declarations</li>
    </ul>
  </li>
  <li>But there are now also global variables that are not properties of the global object. In global scope, the following declarations create such variables:
    <ul>
      <li>
<code>let</code> declarations</li>
      <li>
<code>const</code> declarations</li>
      <li>Class declarations</li>
    </ul>
  </li>
</ul>

<p>Note that the bodies of modules are not executed in global scope, only scripts are. Therefore, the environments for various variables form the following chain.</p>


<figure class="image center">
  <img src="images/variables----environment_chain_150dpi.png" alt="" width="135" height="192.5">
  <figcaption></figcaption>
</figure>



<h3 id="sec_func-decl-class-decl">
<span class="section-number">9.8 </span>Function declarations and class declarations <a class="header-anchor" href="ch_variables.html#sec_func-decl-class-decl" aria-hidden="true">#</a></h3>

<p>Function declarations&#x2026;</p>

<ul>
  <li>are block-scoped, like <code>let</code>.</li>
  <li>create properties in the global object (while in global scope), like <code>var</code>.</li>
  <li>are <em>hoisted</em>: independently of where a function declaration is mentioned in its scope, it is always created at the beginning of the scope.</li>
</ul>

<p>The following code demonstrates the hoisting of function declarations:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="c1">// Enter a new scope</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">foo</code><code class="p">());</code> <code class="c1">// OK, due to hoisting</code>
    <code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s1">&apos;hello&apos;</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Class declarations&#x2026;</p>

<ul>
  <li>are block-scoped.</li>
  <li>don&#x2019;t create properties on the global object.</li>
  <li>are <em>not</em> hoisted.</li>
</ul>

<p>Classes not being hoisted may be surprising, because, under the hood, they create functions. The rationale for this behavior is that the values of their <code>extends</code> clauses are defined via expressions and those expressions have to be executed at the appropriate times.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="c1">// Enter a new scope</code>

    <code class="kr">const</code> <code class="nx">identity</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>

    <code class="c1">// Here we are in the temporal dead zone of `MyClass`</code>
    <code class="kr">const</code> <code class="nx">inst</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyClass</code><code class="p">();</code> <code class="c1">// ReferenceError</code>

    <code class="c1">// Note the expression in the `extends` clause</code>
    <code class="kr">class</code> <code class="nx">MyClass</code> <code class="kr">extends</code> <code class="nx">identity</code><code class="p">(</code><code class="nb">Object</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>


<h3 id="const-vs-let-vs-var">
<span class="section-number">9.9 </span>Coding style: <code>const</code> versus <code>let</code> versus <code>var</code>
 <a class="header-anchor" href="ch_variables.html#const-vs-let-vs-var" aria-hidden="true">#</a></h3>

<p>I recommend to always use either <code>let</code> or <code>const</code>:</p>

<ol class="numeric">
  <li>Prefer <code>const</code>. You can use it whenever a variable never changes its value. In other words: the variable should never be the left-hand side of an assignment or the operand of <code>++</code> or <code>--</code>. Changing an object that a <code>const</code> variable refers to is allowed:
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="p">{};</code>
 <code class="nx">foo</code><code class="p">.</code><code class="nx">prop</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// OK</code>
</pre></div>

    </figure>

    <p>You can even use <code>const</code> in a <code>for-of</code> loop, because one (immutable) binding is created per loop iteration:</p>

    <figure class="code">
<div class="highlight"><pre><code></code> <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="p">[</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">])</code> <code class="p">{</code>
     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
 <code class="p">}</code>
 <code class="c1">// Output:</code>
 <code class="c1">// a</code>
 <code class="c1">// b</code>
</pre></div>

    </figure>

    <p>Inside the body of the <code>for-of</code> loop, <code>x</code> can&#x2019;t be changed.</p>
  </li>
  <li>Otherwise, use <code>let</code> &#x2013; when the initial value of a variable changes later on.
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kd">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="c1">// initial value</code>
 <code class="nx">counter</code><code class="o">++</code><code class="p">;</code> <code class="c1">// change</code>

 <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code> <code class="c1">// initial value</code>
 <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">foo</code><code class="o">:</code> <code class="mi">123</code> <code class="p">};</code> <code class="c1">// change</code>
</pre></div>

    </figure>
  </li>
  <li>Avoid <code>var</code>.</li>
</ol>

<p>If you follow these rules, <code>var</code> will only appear in legacy code, as a signal that careful refactoring is required.</p>

<p><code>var</code> does one thing that <code>let</code> and <code>const</code> don&#x2019;t: variables declared via it become properties of the global object. However, that&#x2019;s generally not a good thing. You can achieve the same effect by assigning to <code>window</code> (in browsers) or <code>global</code> (in Node.js).</p>

<h4 id="_an-alternative-approach">
<span class="section-number">9.9.1 </span>An alternative approach <a class="header-anchor" href="ch_variables.html#_an-alternative-approach" aria-hidden="true">#</a></h4>

<p>An alternative to the just mentioned style rules is to use <code>const</code> only for things that are completely immutable (primitive values and frozen objects). Then we have two approaches:</p>

<ol class="numeric">
  <li>
<strong>Prefer <code>const</code>:</strong> <code>const</code> marks immutable bindings.</li>
  <li>
<strong>Prefer <code>let</code>:</strong> <code>const</code> marks immutable values.</li>
</ol>

<p>I lean slightly in favor of #1, but #2 is fine, too.</p>






<div class="next-chapter">
    Next: <a href="ch_destructuring.html">10. Destructuring</a>
</div>


</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59555947-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
