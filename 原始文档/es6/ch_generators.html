<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>22. Generators</title>
    <link href="stylesheet.css" type="text/css" rel="stylesheet" />
    <link rel="icon" href="images/favicon-128.png" sizes="128x128">
    <link rel="icon" href="images/favicon-32.png" sizes="32x32">
    <link rel="icon" href="images/favicon-16.png" sizes="16x16">
</head>
<body>

<div id="top-bar">
</div>
<div id="top-bar">
    <div id="top-bar-content">
        <b>22. Generators</b><br>
        <a href="index.html#toc_ch_generators">Table of contents</a><br>
        Please support this book:
        <a href="https://leanpub.com/exploring-es6/">buy it (PDF, EPUB, MOBI)</a>
        or
        <a href="http://www.2ality.com/p/donate.html">donate</a>
    </div>
</div>

<div id="adbox">
<div id="adbox-explain">(Ad, please donâ€™t block.)</div>

    <script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=exploringjscom" id="_carbonads_js"></script>

</div>

<div id="page-content">


<h2 id="ch_generators">
<span class="section-number">22. </span>Generators <a class="header-anchor" href="ch_generators.html#ch_generators" aria-hidden="true">#</a></h2>

<hr class="scene-break">

<ul>
  <li>22.1. <a href="ch_generators.html#sec_overview-generators">Overview</a>
    <ul>
      <li>22.1.1. What are generators?</li>
      <li>22.1.2. Kinds of generators</li>
      <li>22.1.3. Use case: implementing iterables</li>
      <li>22.1.4. Use case: simpler asynchronous code</li>
      <li>22.1.5. Use case: receiving asynchronous data</li>
    </ul>
  </li>
  <li>22.2. <a href="ch_generators.html#sec_what-are-generators">What are generators?</a>
    <ul>
      <li>22.2.1. Roles played by generators</li>
    </ul>
  </li>
  <li>22.3. <a href="ch_generators.html#sec_generators-as-iterators">Generators as iterators (data production)</a>
    <ul>
      <li>22.3.1. Ways of iterating over a generator</li>
      <li>22.3.2. Returning from a generator</li>
      <li>22.3.3. Throwing an exception from a generator</li>
      <li>22.3.4. Example: iterating over properties</li>
      <li>22.3.5. You can only <code>yield</code> in generators</li>
      <li>22.3.6. Recursion via <code>yield*</code>
</li>
    </ul>
  </li>
  <li>22.4. <a href="ch_generators.html#sec_generators-as-observers">Generators as observers (data consumption)</a>
    <ul>
      <li>22.4.1. Sending values via <code>next()</code>
</li>
      <li>22.4.2. <code>yield</code> binds loosely</li>
      <li>22.4.3. <code>return()</code> and <code>throw()</code>
</li>
      <li>22.4.4. <code>return()</code> terminates the generator</li>
      <li>22.4.5. <code>throw()</code> signals an error</li>
      <li>22.4.6. Example: processing asynchronously pushed data</li>
      <li>22.4.7. <code>yield*</code>: the full story</li>
    </ul>
  </li>
  <li>22.5. <a href="ch_generators.html#sec_generators-as-coroutines">Generators as coroutines (cooperative multitasking)</a>
    <ul>
      <li>22.5.1. The full generator interface</li>
      <li>22.5.2. Cooperative multitasking</li>
      <li>22.5.3. The limitations of cooperative multitasking via generators</li>
    </ul>
  </li>
  <li>22.6. <a href="ch_generators.html#sec_examples-of-generators">Examples of generators</a>
    <ul>
      <li>22.6.1. Implementing iterables via generators</li>
      <li>22.6.2. Generators for lazy evaluation</li>
      <li>22.6.3. Cooperative multi-tasking via generators</li>
    </ul>
  </li>
  <li>22.7. <a href="ch_generators.html#sec_iteration-api-inheritance">Inheritance within the iteration API (including generators)</a>
    <ul>
      <li>22.7.1. <code>IteratorPrototype</code>
</li>
      <li>22.7.2. The value of <code>this</code> in generators</li>
    </ul>
  </li>
  <li>22.8. <a href="ch_generators.html#sec_formating-generators">Style consideration: whitespace before and after the asterisk</a>
    <ul>
      <li>22.8.1. Generator function declarations and expressions</li>
      <li>22.8.2. Generator method definitions</li>
      <li>22.8.3. Formatting recursive <code>yield</code>
</li>
      <li>22.8.4. Documenting generator functions and methods</li>
    </ul>
  </li>
  <li>22.9. <a href="ch_generators.html#sec_faq-generators">FAQ: generators</a>
    <ul>
      <li>22.9.1. Why use the keyword <code>function*</code> for generators and not <code>generator</code>?</li>
      <li>22.9.2. Is <code>yield</code> a keyword?</li>
    </ul>
  </li>
  <li>22.10. <a href="ch_generators.html#sec_conclusion-generators">Conclusion</a>
</li>
  <li>22.11. <a href="ch_generators.html#sec_further-reading-generators">Further reading</a>
</li>
</ul>

<hr class="scene-break">

<aside class="generic_inbar blurb github-alt icon-github-alt">
    <p>The following GitHub repository contains the example code: <a href="https://github.com/rauschma/generator-examples"><code>generator-examples</code></a></p>

</aside>


<h3 id="sec_overview-generators">
<span class="section-number">22.1 </span>Overview <a class="header-anchor" href="ch_generators.html#sec_overview-generators" aria-hidden="true">#</a></h3>

<h4 id="_what-are-generators">
<span class="section-number">22.1.1 </span>What are generators? <a class="header-anchor" href="ch_generators.html#_what-are-generators" aria-hidden="true">#</a></h4>

<p>You can think of generators as processes (pieces of code) that you can pause and resume:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// (A)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;First&apos;</code><code class="p">);</code>
    <code class="k">yield</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Second&apos;</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Note the new syntax: <code>function*</code> is a new &#x201C;keyword&#x201D; for <em>generator functions</em> (there are also <em>generator methods</em>). <code>yield</code> is an operator with which a generator can pause itself. Additionally, generators can also receive input and send output via <code>yield</code>.</p>

<p>When you call a generator function <code>genFunc()</code>, you get a <em>generator object</em> <code>genObj</code> that you can use to control the process:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">genFunc</code><code class="p">();</code>
</pre></div>

</figure>

<p>The process is initially paused in line A. <code>genObj.next()</code> resumes execution, a <code>yield</code> inside <code>genFunc()</code> pauses execution:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
<code class="c1">// Output: First</code>
<code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
<code class="c1">// output: Second</code>
</pre></div>

</figure>

<h4 id="_kinds-of-generators">
<span class="section-number">22.1.2 </span>Kinds of generators <a class="header-anchor" href="ch_generators.html#_kinds-of-generators" aria-hidden="true">#</a></h4>

<p>There are four kinds of generators:</p>

<ol class="numeric">
  <li>Generator function declarations:
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">}</code>
 <code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">genFunc</code><code class="p">();</code>
</pre></div>

    </figure>
  </li>
  <li>Generator function expressions:
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">const</code> <code class="nx">genFunc</code> <code class="o">=</code> <code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code> <code class="err">&#xB7;&#xB7;&#xB7;</code> <code class="p">};</code>
 <code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">genFunc</code><code class="p">();</code>
</pre></div>

    </figure>
  </li>
  <li>Generator method definitions in object literals:
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
     <code class="o">*</code> <code class="nx">generatorMethod</code><code class="p">()</code> <code class="p">{</code>
         <code class="err">&#xB7;&#xB7;&#xB7;</code>
     <code class="p">}</code>
 <code class="p">};</code>
 <code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">generatorMethod</code><code class="p">();</code>
</pre></div>

    </figure>
  </li>
  <li>Generator method definitions in class definitions (class declarations or class expressions):
    <figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{</code>
     <code class="o">*</code> <code class="nx">generatorMethod</code><code class="p">()</code> <code class="p">{</code>
         <code class="err">&#xB7;&#xB7;&#xB7;</code>
     <code class="p">}</code>
 <code class="p">}</code>
 <code class="kr">const</code> <code class="nx">myInst</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyClass</code><code class="p">();</code>
 <code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">myInst</code><code class="p">.</code><code class="nx">generatorMethod</code><code class="p">();</code>
</pre></div>

    </figure>
  </li>
</ol>

<h4 id="_use-case-implementing-iterables">
<span class="section-number">22.1.3 </span>Use case: implementing iterables <a class="header-anchor" href="ch_generators.html#_use-case-implementing-iterables" aria-hidden="true">#</a></h4>

<p>The objects returned by generators are iterable; each <code>yield</code> contributes to the sequence of iterated values. Therefore, you can use generators to implement iterables, which can be consumed by various ES6 language mechanisms: <code>for-of</code> loop, spread operator (<code>...</code>), etc.</p>

<p>The following function returns an iterable over the properties of an object, one [key, value] pair per property:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">objectEntries</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">propKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>

    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">propKey</code> <code class="k">of</code> <code class="nx">propKeys</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// `yield` returns a value and then pauses</code>
        <code class="c1">// the generator. Later, execution continues</code>
        <code class="c1">// where it was previously paused.</code>
        <code class="k">yield</code> <code class="p">[</code><code class="nx">propKey</code><code class="p">,</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">propKey</code><code class="p">]];</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>objectEntries()</code> is used like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">jane</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="s1">&apos;Jane&apos;</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s1">&apos;Doe&apos;</code> <code class="p">};</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="p">[</code><code class="nx">key</code><code class="p">,</code><code class="nx">value</code><code class="p">]</code> <code class="k">of</code> <code class="nx">objectEntries</code><code class="p">(</code><code class="nx">jane</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// first: Jane</code>
<code class="c1">// last: Doe</code>
</pre></div>

</figure>

<p>How exactly <code>objectEntries()</code> works is explained in <a href="ch_generators.html#objectEntries_generator">a dedicated section</a>. Implementing the same functionality without generators is much more work.</p>

<h4 id="_use-case-simpler-asynchronous-code">
<span class="section-number">22.1.4 </span>Use case: simpler asynchronous code <a class="header-anchor" href="ch_generators.html#_use-case-simpler-asynchronous-code" aria-hidden="true">#</a></h4>

<p>You can use generators to tremendously simplify working with Promises. Let&#x2019;s look at a Promise-based function <code>fetchJson()</code> and how it can be improved via generators.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">fetchJson</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">request</code> <code class="o">=&gt;</code> <code class="nx">request</code><code class="p">.</code><code class="nx">text</code><code class="p">())</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">text</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`ERROR: </code><code class="si">${</code><code class="nx">error</code><code class="p">.</code><code class="nx">stack</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>With <a href="https://github.com/tj/co">the library co</a> and a generator, this asynchronous code looks synchronous:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fetchJson</code> <code class="o">=</code> <code class="nx">co</code><code class="p">.</code><code class="nx">wrap</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">request</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">request</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
        <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`ERROR: </code><code class="si">${</code><code class="nx">error</code><code class="p">.</code><code class="nx">stack</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>ECMAScript 2017 will have async functions which are internally based on generators. With them, the code looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">async</code> <code class="kd">function</code> <code class="nx">fetchJson</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">request</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">request</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
        <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`ERROR: </code><code class="si">${</code><code class="nx">error</code><code class="p">.</code><code class="nx">stack</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>All versions can be invoked like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">fetchJson</code><code class="p">(</code><code class="s1">&apos;http://example.com/some_file.json&apos;</code><code class="p">)</code>
<code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">obj</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">));</code>
</pre></div>

</figure>

<h4 id="_use-case-receiving-asynchronous-data">
<span class="section-number">22.1.5 </span>Use case: receiving asynchronous data <a class="header-anchor" href="ch_generators.html#_use-case-receiving-asynchronous-data" aria-hidden="true">#</a></h4>

<p>Generators can receive input from <code>next()</code> via <code>yield</code>. That means that you can wake up a generator whenever new data arrives asynchronously and to the generator it feels like it receives the data synchronously.</p>


<h3 id="sec_what-are-generators">
<span class="section-number">22.2 </span>What are generators? <a class="header-anchor" href="ch_generators.html#sec_what-are-generators" aria-hidden="true">#</a></h3>

<p><em>Generators</em> are functions that can be paused and resumed (think cooperative multitasking or coroutines), which enables a variety of applications.</p>

<p>As a first example, consider the following generator function whose name is <code>genFunc</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// (A)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;First&apos;</code><code class="p">);</code>
    <code class="k">yield</code><code class="p">;</code> <code class="c1">// (B)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Second&apos;</code><code class="p">);</code> <code class="c1">// (C)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Two things distinguish <code>genFunc</code> from a normal function declaration:</p>

<ul>
  <li>It starts with the &#x201C;keyword&#x201D; <code>function*</code>.</li>
  <li>It can pause itself, via <code>yield</code> (line B).</li>
</ul>

<p>Calling <code>genFunc</code> does not execute its body. Instead, you get a so-called <em>generator object</em>, with which you can control the execution of the body:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj = genFunc();
</pre></div>

</figure>

<p><code>genFunc()</code> is initially suspended before the body (line A). The method call <code>genObj.next()</code> continues execution until the next <code>yield</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; genObj.next()
First
{ value: undefined, done: false }
</pre></div>

</figure>

<p>As you can see in the last line, <code>genObj.next()</code> also returns an object. Let&#x2019;s ignore that for now. It will matter later.</p>

<p><code>genFunc</code> is now paused in line B. If we call <code>next()</code> again, execution resumes and line C is executed:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; genObj.next()
Second
{ value: undefined, done: true }
</pre></div>

</figure>

<p>Afterwards, the function is finished, execution has left the body and further calls of <code>genObj.next()</code> have no effect.</p>

<h4 id="_roles-played-by-generators">
<span class="section-number">22.2.1 </span>Roles played by generators <a class="header-anchor" href="ch_generators.html#_roles-played-by-generators" aria-hidden="true">#</a></h4>

<p>Generators can play three roles:</p>

<ol class="numeric">
  <li>Iterators (data producers): Each <code>yield</code> can return a value via <code>next()</code>, which means that generators can produce sequences of values via loops and recursion. Due to generator objects implementing the interface <code>Iterable</code> (which is explained in <a href="ch_iteration.html#ch_iteration">the chapter on iteration</a>), these sequences can be processed by any ECMAScript 6 construct that supports iterables. Two examples are: <code>for-of</code> loops and the spread operator (<code>...</code>).</li>
  <li>Observers (data consumers): <code>yield</code> can also receive a value from <code>next()</code> (via a parameter). That means that generators become data consumers that pause until a new value is pushed into them via <code>next()</code>.</li>
  <li>Coroutines (data producers and consumers): Given that generators are pausable and can be both data producers and data consumers, not much work is needed to turn them into coroutines (cooperatively multitasked tasks).</li>
</ol>

<p>The next sections provide deeper explanations of these roles.</p>


<h3 id="sec_generators-as-iterators">
<span class="section-number">22.3 </span>Generators as iterators (data production) <a class="header-anchor" href="ch_generators.html#sec_generators-as-iterators" aria-hidden="true">#</a></h3>

<aside class="generic_inbar blurb eye icon-eye">
    <p>For this section, you should be familiar with ES6 iteration. <a href="ch_iteration.html#ch_iteration">The previous chapter</a> has more information.</p>

</aside>

<p>As explained before, generator objects can be data producers, data consumers or both. This section looks at them as data producers, where they implement both the interfaces <code>Iterable</code> and <code>Iterator</code> (shown below). That means that the result of a generator function is both an iterable and an iterator. The full interface of generator objects will be shown later.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">interface</code> <code class="nx">Iterable</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="o">:</code> <code class="nx">Iterator</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">interface</code> <code class="nx">Iterator</code> <code class="p">{</code>
    <code class="nx">next</code><code class="p">()</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">interface</code> <code class="nx">IteratorResult</code> <code class="p">{</code>
    <code class="nx">value</code> <code class="o">:</code> <code class="nx">any</code><code class="p">;</code>
    <code class="nx">done</code> <code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>I have omitted method <code>return()</code> of interface <code>Iterable</code>, because it is not relevant in this section.</p>

<p>A generator function produces a sequence of values via <code>yield</code>, a data consumer consumes thoses values via the iterator method <code>next()</code>. For example, the following generator function produces the values <code>&apos;a&apos;</code> and <code>&apos;b&apos;</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code>
    <code class="k">yield</code> <code class="s1">&apos;b&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This interaction shows how to retrieve the yielded values via the generator object <code>genObj</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj = genFunc();
&gt; genObj.next()
{ value: &apos;a&apos;, done: false }
&gt; genObj.next()
{ value: &apos;b&apos;, done: false }
&gt; genObj.next() // done: true =&gt; end of sequence
{ value: undefined, done: true }
</pre></div>

</figure>

<h4 id="_ways-of-iterating-over-a-generator">
<span class="section-number">22.3.1 </span>Ways of iterating over a generator <a class="header-anchor" href="ch_generators.html#_ways-of-iterating-over-a-generator" aria-hidden="true">#</a></h4>

<p>As generator objects are iterable, ES6 language constructs that support iterables can be applied to them. The following three ones are especially important.</p>

<p>First, the <code>for-of</code> loop:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">genFunc</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// a</code>
<code class="c1">// b</code>
</pre></div>

</figure>

<p>Second, the spread operator (<code>...</code>), which turns iterated sequences into elements of an array (consult <a href="ch_parameter-handling.html#sec_spread-operator">the chapter on parameter handling</a> for more information on this operator):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">genFunc</code><code class="p">()];</code> <code class="c1">// [&apos;a&apos;, &apos;b&apos;]</code>
</pre></div>

</figure>

<p>Third, destructuring:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const [x, y] = genFunc();
&gt; x
&apos;a&apos;
&gt; y
&apos;b&apos;
</pre></div>

</figure>

<h4 id="_returning-from-a-generator">
<span class="section-number">22.3.2 </span>Returning from a generator <a class="header-anchor" href="ch_generators.html#_returning-from-a-generator" aria-hidden="true">#</a></h4>

<p>The previous generator function did not contain an explicit <code>return</code>. An implicit <code>return</code> is equivalent to returning <code>undefined</code>. Let&#x2019;s examine a generator with an explicit <code>return</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFuncWithReturn</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code>
    <code class="k">yield</code> <code class="s1">&apos;b&apos;</code><code class="p">;</code>
    <code class="k">return</code> <code class="s1">&apos;result&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The returned value shows up in the last object returned by <code>next()</code>, whose property <code>done</code> is <code>true</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObjWithReturn = genFuncWithReturn();
&gt; genObjWithReturn.next()
{ value: &apos;a&apos;, done: false }
&gt; genObjWithReturn.next()
{ value: &apos;b&apos;, done: false }
&gt; genObjWithReturn.next()
{ value: &apos;result&apos;, done: true }
</pre></div>

</figure>

<p>However, most constructs that work with iterables ignore the value inside the <code>done</code> object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">genFuncWithReturn</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// a</code>
<code class="c1">// b</code>

<code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">genFuncWithReturn</code><code class="p">()];</code> <code class="c1">// [&apos;a&apos;, &apos;b&apos;]</code>
</pre></div>

</figure>

<p><code>yield*</code>, an operator for making recursive generator calls, does consider values inside <code>done</code> objects. It is explained later.</p>

<h4 id="_throwing-an-exception-from-a-generator">
<span class="section-number">22.3.3 </span>Throwing an exception from a generator <a class="header-anchor" href="ch_generators.html#_throwing-an-exception-from-a-generator" aria-hidden="true">#</a></h4>

<p>If an exception leaves the body of a generator then <code>next()</code> throws it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">&apos;Problem!&apos;</code><code class="p">);</code>
<code class="p">}</code>
<code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">genFunc</code><code class="p">();</code>
<code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code> <code class="c1">// Error: Problem!</code>
</pre></div>

</figure>

<p>That means that <code>next()</code> can produce three different &#x201C;results&#x201D;:</p>

<ul>
  <li>For an item <code>x</code> in an iteration sequence, it returns <code>{ value: x, done: false }</code>
</li>
  <li>For the end of an iteration sequence with a return value <code>z</code>, it returns <code>{ value: z, done: true }</code>
</li>
  <li>For an exception that leaves the generator body, it throws that exception.</li>
</ul>

<h4 id="objectEntries_generator">
<span class="section-number">22.3.4 </span>Example: iterating over properties <a class="header-anchor" href="ch_generators.html#objectEntries_generator" aria-hidden="true">#</a></h4>

<p>Let&#x2019;s look at an example that demonstrates how convenient generators are for implementing iterables. The following function, <code>objectEntries()</code>, returns an iterable over the properties of an object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">objectEntries</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// In ES6, you can use strings or symbols as property keys,</code>
    <code class="c1">// Reflect.ownKeys() retrieves both</code>
    <code class="kr">const</code> <code class="nx">propKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>

    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">propKey</code> <code class="k">of</code> <code class="nx">propKeys</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="p">[</code><code class="nx">propKey</code><code class="p">,</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">propKey</code><code class="p">]];</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This function enables you to iterate over the properties of an object <code>jane</code> via the <code>for-of</code> loop:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">jane</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="s1">&apos;Jane&apos;</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s1">&apos;Doe&apos;</code> <code class="p">};</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="p">[</code><code class="nx">key</code><code class="p">,</code><code class="nx">value</code><code class="p">]</code> <code class="k">of</code> <code class="nx">objectEntries</code><code class="p">(</code><code class="nx">jane</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// first: Jane</code>
<code class="c1">// last: Doe</code>
</pre></div>

</figure>

<p>For comparison &#x2013; an implementation of <code>objectEntries()</code> that doesn&#x2019;t use generators is much more complicated:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">objectEntries</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">index</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="kd">let</code> <code class="nx">propKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>

    <code class="k">return</code> <code class="p">{</code>
        <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="nx">propKeys</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">propKeys</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
                <code class="nx">index</code><code class="o">++</code><code class="p">;</code>
                <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="p">[</code><code class="nx">key</code><code class="p">,</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">key</code><code class="p">]]</code> <code class="p">};</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_you-can-only-yield-in-generators">
<span class="section-number">22.3.5 </span>You can only <code>yield</code> in generators <a class="header-anchor" href="ch_generators.html#_you-can-only-yield-in-generators" aria-hidden="true">#</a></h4>

<p>A significant limitation of generators is that you can only yield while you are (statically) inside a generator function. That is, yielding in callbacks doesn&#x2019;t work:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="p">[</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">].</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">);</code> <code class="c1">// SyntaxError</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>yield</code> is not allowed inside non-generator functions, which is why the previous code causes a syntax error. In this case, it is easy to rewrite the code so that it doesn&#x2019;t use callbacks (as shown below). But unfortunately that isn&#x2019;t always possible.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="p">[</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">])</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code> <code class="c1">// OK</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The upside of this limitation is <a href="ch_generators.html#sec_generators-are-shallow">explained later</a>: it makes generators easier to implement and compatible with event loops.</p>

<h4 id="_recursion-via-yield">
<span class="section-number">22.3.6 </span>Recursion via <code>yield*</code>
 <a class="header-anchor" href="ch_generators.html#_recursion-via-yield" aria-hidden="true">#</a></h4>

<p>You can only use <code>yield</code> within a generator function. Therefore, if you want to implement a recursive algorithm with generator, you need a way to call one generator from another one. This section shows that that is more complicated than it sounds, which is why ES6 has a special operator, <code>yield*</code>, for this. For now, I only explain how <code>yield*</code> works if both generators produce output, I&#x2019;ll later explain how things work if input is involved.</p>

<p>How can one generator recursively call another generator? Let&#x2019;s assume you have written a generator function <code>foo</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code>
    <code class="k">yield</code> <code class="s1">&apos;b&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>How would you call <code>foo</code> from another generator function <code>bar</code>? The following approach does not work!</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;x&apos;</code><code class="p">;</code>
    <code class="nx">foo</code><code class="p">();</code> <code class="c1">// does nothing!</code>
    <code class="k">yield</code> <code class="s1">&apos;y&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Calling <code>foo()</code> returns an object, but does not actually execute <code>foo()</code>. That&#x2019;s why ECMAScript 6 has the operator <code>yield*</code> for making recursive generator calls:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;x&apos;</code><code class="p">;</code>
    <code class="k">yield</code><code class="o">*</code> <code class="nx">foo</code><code class="p">();</code>
    <code class="k">yield</code> <code class="s1">&apos;y&apos;</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Collect all values yielded by bar() in an array</code>
<code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">bar</code><code class="p">()];</code>
    <code class="c1">// [&apos;x&apos;, &apos;a&apos;, &apos;b&apos;, &apos;y&apos;]</code>
</pre></div>

</figure>

<p>Internally, <code>yield*</code> works roughly as follows:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;x&apos;</code><code class="p">;</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">value</code> <code class="k">of</code> <code class="nx">foo</code><code class="p">())</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">yield</code> <code class="s1">&apos;y&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The operand of <code>yield*</code> does not have to be a generator object, it can be any iterable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">bla</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;sequence&apos;</code><code class="p">;</code>
    <code class="k">yield</code><code class="o">*</code> <code class="p">[</code><code class="s1">&apos;of&apos;</code><code class="p">,</code> <code class="s1">&apos;yielded&apos;</code><code class="p">];</code>
    <code class="k">yield</code> <code class="s1">&apos;values&apos;</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">bla</code><code class="p">()];</code>
    <code class="c1">// [&apos;sequence&apos;, &apos;of&apos;, &apos;yielded&apos;, &apos;values&apos;]</code>
</pre></div>

</figure>

<h5 id="_yield-considers-end-of-iteration-values">
<span class="section-number">22.3.6.1 </span><code>yield*</code> considers end-of-iteration values <a class="header-anchor" href="ch_generators.html#_yield-considers-end-of-iteration-values" aria-hidden="true">#</a></h5>

<p>Most constructs that support iterables ignore the value included in the end-of-iteration object (whose property <code>done</code> is <code>true</code>). Generators provide that value via <code>return</code>. The result of <code>yield*</code> is the end-of-iteration value:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFuncWithReturn</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s1">&apos;a&apos;</code><code class="p">;</code>
    <code class="k">yield</code> <code class="s1">&apos;b&apos;</code><code class="p">;</code>
    <code class="k">return</code> <code class="s1">&apos;The result&apos;</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">logReturned</code><code class="p">(</code><code class="nx">genObj</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="k">yield</code><code class="o">*</code> <code class="nx">genObj</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code> <code class="c1">// (A)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>If we want to get to line A, we first must iterate over all values yielded by <code>logReturned()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [...logReturned(genFuncWithReturn())]
The result
[ &apos;a&apos;, &apos;b&apos; ]
</pre></div>

</figure>

<h5 id="_iterating-over-trees">
<span class="section-number">22.3.6.2 </span>Iterating over trees <a class="header-anchor" href="ch_generators.html#_iterating-over-trees" aria-hidden="true">#</a></h5>

<p>Iterating over a tree with recursion is simple, writing an iterator for a tree with traditional means is complicated. That&#x2019;s why generators shine here: they let you implement an iterator via recursion. As an example, consider the following data structure for binary trees. It is iterable, because it has a method whose key is <code>Symbol.iterator</code>. That method is a generator method and returns an iterator when called.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">BinaryTree</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">left</code><code class="o">=</code><code class="kc">null</code><code class="p">,</code> <code class="nx">right</code><code class="o">=</code><code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">left</code> <code class="o">=</code> <code class="nx">left</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">right</code> <code class="o">=</code> <code class="nx">right</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="cm">/** Prefix iteration */</code>
    <code class="o">*</code> <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="k">this</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">left</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code><code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">left</code><code class="p">;</code>
            <code class="c1">// Short for: yield* this.left[Symbol.iterator]()</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">right</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code><code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">right</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The following code creates a binary tree and iterates over it via <code>for-of</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">tree</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">BinaryTree</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">,</code>
    <code class="k">new</code> <code class="nx">BinaryTree</code><code class="p">(</code><code class="s1">&apos;b&apos;</code><code class="p">,</code>
        <code class="k">new</code> <code class="nx">BinaryTree</code><code class="p">(</code><code class="s1">&apos;c&apos;</code><code class="p">),</code>
        <code class="k">new</code> <code class="nx">BinaryTree</code><code class="p">(</code><code class="s1">&apos;d&apos;</code><code class="p">)),</code>
    <code class="k">new</code> <code class="nx">BinaryTree</code><code class="p">(</code><code class="s1">&apos;e&apos;</code><code class="p">));</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">tree</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// a</code>
<code class="c1">// b</code>
<code class="c1">// c</code>
<code class="c1">// d</code>
<code class="c1">// e</code>
</pre></div>

</figure>


<h3 id="sec_generators-as-observers">
<span class="section-number">22.4 </span>Generators as observers (data consumption) <a class="header-anchor" href="ch_generators.html#sec_generators-as-observers" aria-hidden="true">#</a></h3>

<p>As consumers of data, generator objects conform to the second half of the generator interface, <code>Observer</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">interface</code> <code class="nx">Observer</code> <code class="p">{</code>
    <code class="nx">next</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
    <code class="k">return</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
    <code class="k">throw</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>As an observer, a generator pauses until it receives input. There are three kinds of input, transmitted via the methods specified by the interface:</p>

<ul>
  <li>
<code>next()</code> sends normal input.</li>
  <li>
<code>return()</code> terminates the generator.</li>
  <li>
<code>throw()</code> signals an error.</li>
</ul>


<h4 id="_sending-values-via-next">
<span class="section-number">22.4.1 </span>Sending values via <code>next()</code>
 <a class="header-anchor" href="ch_generators.html#_sending-values-via-next" aria-hidden="true">#</a></h4>

<p>If you use a generator as an observer, you send values to it via <code>next()</code> and it receives those values via <code>yield</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">dataConsumer</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Started&apos;</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`1. </code><code class="si">${</code><code class="k">yield</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code> <code class="c1">// (A)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`2. </code><code class="si">${</code><code class="k">yield</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="s1">&apos;result&apos;</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Let&#x2019;s use this generator interactively. First, we create a generator object:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj = dataConsumer();
</pre></div>

</figure>

<p>We now call <code>genObj.next()</code>, which starts the generator. Execution continues until the first <code>yield</code>, which is where the generator pauses. The result of <code>next()</code> is the value yielded in line A (<code>undefined</code>, because <code>yield</code> doesn&#x2019;t have an operand). In this section, we are not interested in what <code>next()</code> returns, because we only use it to send values, not to retrieve values.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
<code class="nx">Started</code>
<code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code>
</pre></div>

</figure>

<p>We call <code>next()</code> two more times, in order to send the value <code>&apos;a&apos;</code> to the first <code>yield</code> and the value <code>&apos;b&apos;</code> to the second <code>yield</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">)</code>
<code class="mi">1</code><code class="p">.</code> <code class="nx">a</code>
<code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code>

<code class="o">&gt;</code> <code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="s1">&apos;b&apos;</code><code class="p">)</code>
<code class="mi">2</code><code class="p">.</code> <code class="nx">b</code>
<code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="s1">&apos;result&apos;</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
</pre></div>

</figure>

<p>The result of the last <code>next()</code> is the value returned from <code>dataConsumer()</code>. <code>done</code> being <code>true</code> indicates that the generator is finished.</p>

<p>Unfortunately, <code>next()</code> is asymmetric, but that can&#x2019;t be helped: It always sends a value to the currently suspended <code>yield</code>, but returns the operand of the following <code>yield</code>.</p>

<h5 id="function_coroutine">
<span class="section-number">22.4.1.1 </span>The first <code>next()</code>
 <a class="header-anchor" href="ch_generators.html#function_coroutine" aria-hidden="true">#</a></h5>

<p>When using a generator as an observer, it is important to note that the only purpose of the first invocation of <code>next()</code> is to start the observer. It is only ready for input afterwards, because this first invocation advances execution to the first <code>yield</code>. Therefore, any input you send via the first <code>next()</code> is ignored:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">gen</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// (A)</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">input</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code> <code class="c1">// (B)</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nx">gen</code><code class="p">();</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="s1">&apos;a&apos;</code><code class="p">);</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="s1">&apos;b&apos;</code><code class="p">);</code>

<code class="c1">// Output:</code>
<code class="c1">// b</code>
</pre></div>

</figure>

<p>Initially, execution is paused in line A. The first invocation of <code>next()</code>:</p>

<ul>
  <li>Feeds the argument <code>&apos;a&apos;</code> of <code>next()</code> to the generator, which has no way to receive it (as there is no <code>yield</code>). That&#x2019;s why it is ignored.</li>
  <li>Advances to the <code>yield</code> in line B and pauses execution.</li>
  <li>Returns <code>yield</code>&#x2019;s operand (<code>undefined</code>, because it doesn&#x2019;t have an operand).</li>
</ul>

<p>The second invocation of <code>next()</code>:</p>

<ul>
  <li>Feeds the argument <code>&apos;b&apos;</code> of <code>next()</code> to the generator, which receives it via the <code>yield</code> in line B and assigns it to the variable <code>input</code>.</li>
  <li>Then execution continues until the next loop iteration, where it is paused again, in line B.</li>
  <li>Then <code>next()</code> returns with that <code>yield</code>&#x2019;s operand (<code>undefined</code>).</li>
</ul>

<p>The following utility function fixes this issue:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Returns a function that, when called,</code>
<code class="cm"> * returns a generator object that is immediately</code>
<code class="cm"> * ready for input via `next()`</code>
<code class="cm"> */</code>
<code class="kd">function</code> <code class="nx">coroutine</code><code class="p">(</code><code class="nx">generatorFunction</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">generatorObject</code> <code class="o">=</code> <code class="nx">generatorFunction</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
        <code class="nx">generatorObject</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
        <code class="k">return</code> <code class="nx">generatorObject</code><code class="p">;</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To see how <code>coroutine()</code> works, let&#x2019;s compare a wrapped generator with a normal one:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapped</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`First input: </code><code class="si">${</code><code class="k">yield</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="s1">&apos;DONE&apos;</code><code class="p">;</code>
<code class="p">});</code>
<code class="kr">const</code> <code class="nx">normal</code> <code class="o">=</code> <code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`First input: </code><code class="si">${</code><code class="k">yield</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="s1">&apos;DONE&apos;</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The wrapped generator is immediately ready for input:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; wrapped().next(&apos;hello!&apos;)
First input: hello!
</pre></div>

</figure>

<p>The normal generator needs an extra <code>next()</code> until it is ready for input:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj = normal();
&gt; genObj.next()
{ value: undefined, done: false }
&gt; genObj.next(&apos;hello!&apos;)
First input: hello!
{ value: &apos;DONE&apos;, done: true }
</pre></div>

</figure>


<h4 id="_yield-binds-loosely">
<span class="section-number">22.4.2 </span><code>yield</code> binds loosely <a class="header-anchor" href="ch_generators.html#_yield-binds-loosely" aria-hidden="true">#</a></h4>

<p><code>yield</code> binds very loosely, so that we don&#x2019;t have to put its operand in parentheses:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">yield</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
</pre></div>

</figure>

<p>This is treated as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">yield</code> <code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">);</code>
</pre></div>

</figure>

<p>Not as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="k">yield</code> <code class="nx">a</code><code class="p">)</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
</pre></div>

</figure>

<p>As a consequence, many operators bind more tightly than <code>yield</code> and you have to put <code>yield</code> in parentheses if you want to use it as an operand. For example, you get a SyntaxError if you make an unparenthesized <code>yield</code> an operand of plus:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Hello&apos;</code> <code class="o">+</code> <code class="k">yield</code><code class="p">);</code> <code class="c1">// SyntaxError</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Hello&apos;</code> <code class="o">+</code> <code class="k">yield</code> <code class="mi">123</code><code class="p">);</code> <code class="c1">// SyntaxError</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Hello&apos;</code> <code class="o">+</code> <code class="p">(</code><code class="k">yield</code><code class="p">));</code> <code class="c1">// OK</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Hello&apos;</code> <code class="o">+</code> <code class="p">(</code><code class="k">yield</code> <code class="mi">123</code><code class="p">));</code> <code class="c1">// OK</code>
</pre></div>

</figure>

<p>You do not need parens if <code>yield</code> is a direct argument in a function or method call:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">foo</code><code class="p">(</code><code class="k">yield</code> <code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="k">yield</code> <code class="s1">&apos;b&apos;</code><code class="p">);</code>
</pre></div>

</figure>

<p>You also don&#x2019;t need parens if you use <code>yield</code> on the right-hand side of an assignment:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">input</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
</pre></div>

</figure>

<h5 id="_yield-in-the-es6-grammar">
<span class="section-number">22.4.2.1 </span><code>yield</code> in the ES6 grammar <a class="header-anchor" href="ch_generators.html#_yield-in-the-es6-grammar" aria-hidden="true">#</a></h5>

<p>The need for parens around <code>yield</code> can be seen in the following grammar rules in the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-expressions">ECMAScript 6 specification</a>. These rules describe how expressions are parsed. I list them here from general (loose binding, lower precedence) to specific (tight binding, higher precedence). Wherever a certain kind of expression is demanded, you can also use more specific ones. The opposite is not true. The hierarchy ends with <code>ParenthesizedExpression</code>, which means that you can mention any expression anywhere, if you put it in parentheses.</p>

<figure class="code">
<div class="highlight"><pre><code></code>Expression :
    AssignmentExpression
    Expression , AssignmentExpression
AssignmentExpression :
    ConditionalExpression
    YieldExpression
    ArrowFunction
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression

&#xB7;&#xB7;&#xB7;

AdditiveExpression :
    MultiplicativeExpression
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
MultiplicativeExpression :
    UnaryExpression
    MultiplicativeExpression MultiplicativeOperator UnaryExpression

&#xB7;&#xB7;&#xB7;

PrimaryExpression :
    this
    IdentifierReference
    Literal
    ArrayLiteral
    ObjectLiteral
    FunctionExpression
    ClassExpression
    GeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral
    ParenthesizedExpression
ParenthesizedExpression :
    ( Expression )
</pre></div>

</figure>

<p>The operands of an <code>AdditiveExpression</code> are an <code>AdditiveExpression</code> and a <code>MultiplicativeExpression</code>. Therefore, using a (more specific) <code>ParenthesizedExpression</code> as an operand is OK, but using a (more general) <code>YieldExpression</code> isn&#x2019;t.</p>


<h4 id="_return-and-throw">
<span class="section-number">22.4.3 </span><code>return()</code> and <code>throw()</code>
 <a class="header-anchor" href="ch_generators.html#_return-and-throw" aria-hidden="true">#</a></h4>

<p>Generator objects have two additional methods, <code>return()</code> and <code>throw()</code>, that are similar to <code>next()</code>.</p>

<p>Let&#x2019;s recap how <code>next(x)</code> works (after the first invocation):</p>

<ol class="numeric">
  <li>The generator is currently suspended at a <code>yield</code> operator.</li>
  <li>Send the value <code>x</code> to that <code>yield</code>, which means that it evaluates to <code>x</code>.</li>
  <li>Proceed to the next <code>yield</code>, <code>return</code> or <code>throw</code>:
    <ul>
      <li>
<code>yield x</code> leads to <code>next()</code> returning with <code>{ value: x, done: false }</code>
</li>
      <li>
<code>return x</code> leads to <code>next()</code> returning with <code>{ value: x, done: true }</code>
</li>
      <li>
<code>throw err</code> (not caught inside the generator) leads to <code>next()</code> throwing <code>err</code>.</li>
    </ul>
  </li>
</ol>

<p><code>return()</code> and <code>throw()</code> work similarly to <code>next()</code>, but they do something different in step 2:</p>

<ul>
  <li>
<code>return(x)</code> executes <code>return x</code> at the location of <code>yield</code>.</li>
  <li>
<code>throw(x)</code> executes <code>throw x</code> at the location of <code>yield</code>.</li>
</ul>


<h4 id="_return-terminates-the-generator">
<span class="section-number">22.4.4 </span><code>return()</code> terminates the generator <a class="header-anchor" href="ch_generators.html#_return-terminates-the-generator" aria-hidden="true">#</a></h4>

<p><code>return()</code> performs a <code>return</code> at the location of the <code>yield</code> that led to the last suspension of the generator. Let&#x2019;s use the following generator function to see how that works.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc1</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Started&apos;</code><code class="p">);</code>
        <code class="k">yield</code><code class="p">;</code> <code class="c1">// (A)</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Exiting&apos;</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In the following interaction, we first use <code>next()</code> to start the generator and to proceed until the <code>yield</code> in line A. Then we return from that location via <code>return()</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj1 = genFunc1();
&gt; genObj1.next()
Started
{ value: undefined, done: false }
&gt; genObj1.return(&apos;Result&apos;)
Exiting
{ value: &apos;Result&apos;, done: true }
</pre></div>

</figure>

<h5 id="_preventing-termination">
<span class="section-number">22.4.4.1 </span>Preventing termination <a class="header-anchor" href="ch_generators.html#_preventing-termination" aria-hidden="true">#</a></h5>

<p>You can prevent <code>return()</code> from terminating the generator if you yield inside the <code>finally</code> clause (using a <code>return</code> statement in that clause is also possible):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc2</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Started&apos;</code><code class="p">);</code>
        <code class="k">yield</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="s1">&apos;Not done, yet!&apos;</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This time, <code>return()</code> does not exit the generator function. Accordingly, the property <code>done</code> of the object it returns is <code>false</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const genObj2 = genFunc2();

&gt; genObj2.next()
Started
{ value: undefined, done: false }

&gt; genObj2.return(&apos;Result&apos;)
{ value: &apos;Not done, yet!&apos;, done: false }
</pre></div>

</figure>

<p>You can invoke <code>next()</code> one more time. Similarly to non-generator functions, the return value of the generator function is the value that was queued prior to entering the <code>finally</code> clause.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; genObj2.next()
{ value: &apos;Result&apos;, done: true }
</pre></div>

</figure>

<h5 id="_returning-from-a-newborn-generator">
<span class="section-number">22.4.4.2 </span>Returning from a newborn generator <a class="header-anchor" href="ch_generators.html#_returning-from-a-newborn-generator" aria-hidden="true">#</a></h5>

<p>Returning a value from a <em>newborn</em> generator (that hasn&#x2019;t started yet) is allowed:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; function* genFunc() {}
&gt; genFunc().return(&apos;yes&apos;)
{ value: &apos;yes&apos;, done: true }
</pre></div>

</figure>

<aside class="generic_inbar blurb eye icon-eye">
    <h3 id="_further-reading-2">Further reading <a class="header-anchor" href="ch_generators.html#_further-reading-2" aria-hidden="true">#</a></h3>

  <p><code>return()</code> is also used to close iterators. The chapter on iteration has <a href="ch_iteration.html#sec_closing-iterators">a detailed section on that</a>.</p>

</aside>


<h4 id="_throw-signals-an-error">
<span class="section-number">22.4.5 </span><code>throw()</code> signals an error <a class="header-anchor" href="ch_generators.html#_throw-signals-an-error" aria-hidden="true">#</a></h4>

<p><code>throw()</code> throws an exception at the location of the <code>yield</code> that led to the last suspension of the generator. Let&#x2019;s examine how that works via the following generator function.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">genFunc1</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Started&apos;</code><code class="p">);</code>
        <code class="k">yield</code><code class="p">;</code> <code class="c1">// (A)</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Caught: &apos;</code> <code class="o">+</code> <code class="nx">error</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In the following interaction, we first use <code>next()</code> to start the generator and proceed until the <code>yield</code> in line A. Then we throw an exception from that location.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="kr">const</code> <code class="nx">genObj1</code> <code class="o">=</code> <code class="nx">genFunc1</code><code class="p">();</code>

<code class="o">&gt;</code> <code class="nx">genObj1</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
<code class="nx">Started</code>
<code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code>

<code class="o">&gt;</code> <code class="nx">genObj1</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">&apos;Problem!&apos;</code><code class="p">))</code>
<code class="nx">Caught</code><code class="o">:</code> <code class="nb">Error</code><code class="o">:</code> <code class="nx">Problem</code><code class="o">!</code>
<code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
</pre></div>

</figure>

<p>The result of <code>throw()</code> (shown in the last line) stems from us leaving the function with an implicit <code>return</code>.</p>

<h5 id="_throwing-from-a-newborn-generator">
<span class="section-number">22.4.5.1 </span>Throwing from a newborn generator <a class="header-anchor" href="ch_generators.html#_throwing-from-a-newborn-generator" aria-hidden="true">#</a></h5>

<p>Throwing an exception in a <em>newborn</em> generator (that hasn&#x2019;t started yet) is allowed:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; function* genFunc() {}
&gt; genFunc().throw(new Error(&apos;Problem!&apos;))
Error: Problem!
</pre></div>

</figure>


<h4 id="_example-processing-asynchronously-pushed-data">
<span class="section-number">22.4.6 </span>Example: processing asynchronously pushed data <a class="header-anchor" href="ch_generators.html#_example-processing-asynchronously-pushed-data" aria-hidden="true">#</a></h4>

<p>The fact that generators-as-observers pause while they wait for input makes them perfect for on-demand processing of data that is received asynchronously. The pattern for setting up a chain of generators for processing is as follows:</p>

<ul>
  <li>Each member of the chain of generators (except the last one) has a parameter <code>target</code>. It receives data via <code>yield</code> and sends data via <code>target.next()</code>.</li>
  <li>The last member of the chain of generators has no parameter <code>target</code> and only receives data.</li>
</ul>

<p>The whole chain is prefixed by a non-generator function that makes an asynchronous request and pushes the results into the chain of generators via <code>next()</code>.</p>

<p>As an example, let&#x2019;s chain generators to process a file that is read asynchronously.</p>

<aside class="generic_inbar blurb github-alt icon-github-alt">
    <p>The code of this example is in the file <a href="https://github.com/rauschma/generator-examples/blob/gh-pages/node/readlines.js"><code>generator-examples/node/readlines.js</code></a>. It must be executed via <code>babel-node</code>.</p>

</aside>

<p>The following code sets up the chain: it contains the generators <code>splitLines</code>, <code>numberLines</code> and <code>printLines</code>. Data is pushed into the chain via the non-generator function <code>readFile</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">readFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">,</code> <code class="nx">splitLines</code><code class="p">(</code><code class="nx">numberLines</code><code class="p">(</code><code class="nx">printLines</code><code class="p">())));</code>
</pre></div>

</figure>

<p>I&#x2019;ll explain what these functions do when I show their code.</p>

<p>As previously explained, if generators receive input via <code>yield</code>, the first invocation of <code>next()</code> on the generator object doesn&#x2019;t do anything. That&#x2019;s why I use <a href="ch_generators.html#function_coroutine">the previously shown helper function <code>coroutine()</code></a> to create coroutines here. It executes the first <code>next()</code> for us.</p>

<p><code>readFile()</code> is the non-generator function that starts everything:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="p">{</code><code class="nx">createReadStream</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;fs&apos;</code><code class="p">;</code>

<code class="cm">/**</code>
<code class="cm"> * Creates an asynchronous ReadStream for the file whose name</code>
<code class="cm"> * is `fileName` and feeds it to the generator object `target`.</code>
<code class="cm"> *</code>
<code class="cm"> * @see ReadStream https://nodejs.org/api/fs.html#fs_class_fs_readstream</code>
<code class="cm"> */</code>
<code class="kd">function</code> <code class="nx">readFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">,</code> <code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">readStream</code> <code class="o">=</code> <code class="nx">createReadStream</code><code class="p">(</code><code class="nx">fileName</code><code class="p">,</code>
        <code class="p">{</code> <code class="nx">encoding</code><code class="o">:</code> <code class="s1">&apos;utf8&apos;</code><code class="p">,</code> <code class="nx">bufferSize</code><code class="o">:</code> <code class="mi">1024</code> <code class="p">});</code>
    <code class="nx">readStream</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">&apos;data&apos;</code><code class="p">,</code> <code class="nx">buffer</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="nx">buffer</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="s1">&apos;utf8&apos;</code><code class="p">);</code>
        <code class="nx">target</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">str</code><code class="p">);</code>
    <code class="p">});</code>
    <code class="nx">readStream</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">&apos;end&apos;</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// Signal end of output sequence</code>
        <code class="nx">target</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The chain of generators starts with <code>splitLines</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Turns a sequence of text chunks into a sequence of lines</code>
<code class="cm"> * (where lines are separated by newlines)</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">splitLines</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">previous</code> <code class="o">=</code> <code class="s1">&apos;&apos;</code><code class="p">;</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">previous</code> <code class="o">+=</code> <code class="k">yield</code><code class="p">;</code>
            <code class="kd">let</code> <code class="nx">eolIndex</code><code class="p">;</code>
            <code class="k">while</code> <code class="p">((</code><code class="nx">eolIndex</code> <code class="o">=</code> <code class="nx">previous</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="s1">&apos;\n&apos;</code><code class="p">))</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">const</code> <code class="nx">line</code> <code class="o">=</code> <code class="nx">previous</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nx">eolIndex</code><code class="p">);</code>
                <code class="nx">target</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
                <code class="nx">previous</code> <code class="o">=</code> <code class="nx">previous</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="nx">eolIndex</code><code class="o">+</code><code class="mi">1</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="c1">// Handle the end of the input sequence</code>
        <code class="c1">// (signaled via `return()`)</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">previous</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">target</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">previous</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// Signal end of output sequence</code>
        <code class="nx">target</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Note an important pattern:</p>

<ul>
  <li>
<code>readFile</code> uses the generator object method <code>return()</code> to signal the end of the sequence of chunks that it sends.</li>
  <li>
<code>readFile</code> sends that signal while <code>splitLines</code> is waiting for input via <code>yield</code>, inside an infinite loop. <code>return()</code> breaks from that loop.</li>
  <li>
<code>splitLines</code> uses a <code>finally</code> clause to handle the end-of-sequence.</li>
</ul>

<p>The next generator is <code>numberLines</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">//**</code>
 <code class="o">*</code> <code class="nx">Prefixes</code> <code class="nx">numbers</code> <code class="nx">to</code> <code class="nx">a</code> <code class="nx">sequence</code> <code class="k">of</code> <code class="nx">lines</code>
 <code class="o">*</code><code class="err">/</code>
<code class="kr">const</code> <code class="nx">numberLines</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">lineNo</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="p">;</code> <code class="nx">lineNo</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">line</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
            <code class="nx">target</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">lineNo</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">line</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="c1">// Signal end of output sequence</code>
        <code class="nx">target</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The last generator is <code>printLines</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Receives a sequence of lines (without newlines)</code>
<code class="cm"> * and logs them (adding newlines).</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">printLines</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">line</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The neat thing about this code is that everything happens lazily (on demand): lines are split, numbered and printed as they arrive; we don&#x2019;t have to wait for all of the text before we can start printing.</p>


<h4 id="_yield-the-full-story">
<span class="section-number">22.4.7 </span><code>yield*</code>: the full story <a class="header-anchor" href="ch_generators.html#_yield-the-full-story" aria-hidden="true">#</a></h4>

<p>As a rough rule of thumb, <code>yield*</code> performs (the equivalent of) a function call from one generator (the <em>caller</em>) to another generator (the <em>callee</em>).</p>

<p>So far, we have only seen one aspect of <code>yield</code>: it propagates yielded values from the callee to the caller. Now that we are interested in generators receiving input, another aspect becomes relevant: <code>yield*</code> also forwards input received by the caller to the callee. In a way, the callee becomes the active generator and can be controlled via the caller&#x2019;s generator object.</p>

<h5 id="_example-yield-forwards-next">
<span class="section-number">22.4.7.1 </span>Example: <code>yield*</code> forwards <code>next()</code>
 <a class="header-anchor" href="ch_generators.html#_example-yield-forwards-next" aria-hidden="true">#</a></h5>

<p>The following generator function <code>caller()</code> invokes the generator function <code>callee()</code> via <code>yield*</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">callee</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;callee: &apos;</code> <code class="o">+</code> <code class="p">(</code><code class="k">yield</code><code class="p">));</code>
<code class="p">}</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">caller</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code><code class="o">*</code> <code class="nx">callee</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>callee</code> logs values received via <code>next()</code>, which allows us to check whether it receives the value <code>&apos;a&apos;</code> and <code>&apos;b&apos;</code> that we send to <code>caller</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; const callerObj = caller();

&gt; callerObj.next() // start
{ value: undefined, done: false }

&gt; callerObj.next(&apos;a&apos;)
callee: a
{ value: undefined, done: false }

&gt; callerObj.next(&apos;b&apos;)
callee: b
{ value: undefined, done: false }
</pre></div>

</figure>

<p><code>throw()</code> and <code>return()</code> are forwarded in a similar manner.</p>

<h5 id="_the-semantics-of-yield-expressed-in-javascript">
<span class="section-number">22.4.7.2 </span>The semantics of <code>yield*</code> expressed in JavaScript <a class="header-anchor" href="ch_generators.html#_the-semantics-of-yield-expressed-in-javascript" aria-hidden="true">#</a></h5>

<p>I&#x2019;ll explain the complete semantics of <code>yield*</code> by showing how you&#x2019;d implemented it in JavaScript.</p>

<p>The following statement:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">yieldStarResult</code> <code class="o">=</code> <code class="k">yield</code><code class="o">*</code> <code class="nx">calleeFunc</code><code class="p">();</code>
</pre></div>

</figure>

<p>is roughly equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">yieldStarResult</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">calleeObj</code> <code class="o">=</code> <code class="nx">calleeFunc</code><code class="p">();</code>
<code class="kd">let</code> <code class="nx">prevReceived</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
<code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="c1">// Forward input previously received</code>
        <code class="kr">const</code> <code class="p">{</code><code class="nx">value</code><code class="p">,</code><code class="nx">done</code><code class="p">}</code> <code class="o">=</code> <code class="nx">calleeObj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">prevReceived</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">yieldStarResult</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
            <code class="k">break</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="nx">prevReceived</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Pretend `return` can be caught like an exception</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">Return</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Forward input received via return()</code>
            <code class="nx">calleeObj</code><code class="p">.</code><code class="k">return</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">returnedValue</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">e</code><code class="p">.</code><code class="nx">returnedValue</code><code class="p">;</code> <code class="c1">// &#x201C;re-throw&#x201D;</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// Forward input received via throw()</code>
            <code class="nx">calleeObj</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code> <code class="c1">// may throw</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To keep things simple, several things are missing in this code:</p>

<ul>
  <li>The operand of <code>yield*</code> can be any iterable value.</li>
  <li>
<code>return()</code> and <code>throw()</code> are optional iterator methods. We should only call them if they exist.</li>
  <li>If an exception is received and <code>throw()</code> does not exist, but <code>return()</code> does then <code>return()</code> is called (before throwing an exception) to give <code>calleeObject</code> the opportunity to clean up.</li>
  <li>
<code>calleeObj</code> can refuse to close, by returning an object whose property <code>done</code> is <code>false</code>. Then the caller also has to refuse to close and <code>yield*</code> must continue to iterate.</li>
</ul>


<h3 id="sec_generators-as-coroutines">
<span class="section-number">22.5 </span>Generators as coroutines (cooperative multitasking) <a class="header-anchor" href="ch_generators.html#sec_generators-as-coroutines" aria-hidden="true">#</a></h3>

<p>We have seen generators being used as either sources or sinks of data. For many applications, it&#x2019;s good practice to strictly separate these two roles, because it keeps things simpler. This section describes the full generator interface (which combines both roles) and one use case where both roles are needed: cooperative multitasking, where tasks must be able to both send and receive information.</p>


<h4 id="_the-full-generator-interface">
<span class="section-number">22.5.1 </span>The full generator interface <a class="header-anchor" href="ch_generators.html#_the-full-generator-interface" aria-hidden="true">#</a></h4>

<p>The full interface of generator objects, <code>Generator</code>, handles both output and input:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">interface</code> <code class="nx">Generator</code> <code class="p">{</code>
    <code class="nx">next</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
    <code class="k">throw</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
    <code class="k">return</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">interface</code> <code class="nx">IteratorResult</code> <code class="p">{</code>
    <code class="nx">value</code> <code class="o">:</code> <code class="nx">any</code><code class="p">;</code>
    <code class="nx">done</code> <code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<aside class="generic_inbar blurb gears icon-gears">
    <p>This interface is described in the spec in the section &#x201C;<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-generator-prototype">Properties of Generator Prototype</a>&#x201D;.</p>

</aside>

<p>The interface <code>Generator</code> combines two interfaces that we have seen previously: <code>Iterator</code> for output and <code>Observer</code> for input.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">interface</code> <code class="nx">Iterator</code> <code class="p">{</code> <code class="c1">// data producer</code>
    <code class="nx">next</code><code class="p">()</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
    <code class="k">return</code><code class="o">?</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="nx">IteratorResult</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Observer</code> <code class="p">{</code> <code class="c1">// data consumer</code>
    <code class="nx">next</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
    <code class="k">return</code><code class="p">(</code><code class="nx">value</code><code class="o">?</code> <code class="o">:</code> <code class="nx">any</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
    <code class="k">throw</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="o">:</code> <code class="k">void</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>


<h4 id="_cooperative-multitasking">
<span class="section-number">22.5.2 </span>Cooperative multitasking <a class="header-anchor" href="ch_generators.html#_cooperative-multitasking" aria-hidden="true">#</a></h4>

<p>Cooperative multitasking is an application of generators where we need them to handle both output and input. Before we get into how that works, let&#x2019;s first review the current state of parallelism in JavaScript.</p>

<p>JavaScript runs in a single process. There are two ways in which this limitation is being abolished:</p>

<ul>
  <li>Multiprocessing: <em>Web Workers</em> let you run JavaScript in multiple processes. Shared access to data is one of the biggest pitfalls of multiprocessing. Web Workers avoid it by not sharing any data. That is, if you want a Web Worker to have a piece of data, you must send it a copy or transfer your data to it (after which you can&#x2019;t access it anymore).</li>
  <li>Cooperative multitasking: There are various patterns and libraries that experiment with cooperative multitasking. Multiple tasks are run, but only one at a time. Each task must explicitly suspend itself, giving it full control over when a task switch happens. In these experiments, data is often shared between tasks. But due to explicit suspension, there are few risks.</li>
</ul>

<p>Two use cases benefit from cooperative multitasking, because they involve control flows that are mostly sequential, anyway, with occasional pauses:</p>

<ul>
  <li>
<strong>Streams:</strong> A task sequentially processes a stream of data and pauses if there is no data available.
    <ul>
      <li>For binary streams, WHATWG is currently working on a <a href="https://streams.spec.whatwg.org/">standard proposal</a> that is based on callbacks and Promises.</li>
      <li>For streams of data, Communicating Sequential Processes (CSP) are an interesting solution. A generator-based CSP library is covered <a href="ch_generators.html#sec_csp">later in this chapter</a>.</li>
    </ul>
  </li>
  <li>
<strong>Asynchronous computations:</strong> A task blocks (pauses) until it receives the result of a long- running computation.
    <ul>
      <li>In JavaScript, <a href="ch_promises.html#ch_promises">Promises</a> have become a popular way of handling asynchronous computations. Support for them is included in ES6. The next section explains how generators can make using Promises simpler.</li>
    </ul>
  </li>
</ul>

<h5 id="sec_co-library">
<span class="section-number">22.5.2.1 </span>Simplifying asynchronous computations via generators <a class="header-anchor" href="ch_generators.html#sec_co-library" aria-hidden="true">#</a></h5>

<p>Several Promise-based libraries simplify asynchronous code via generators. Generators are ideal as clients of Promises, because they can be suspended until a result arrives.</p>

<p>The following example demonstrates what that looks like if one uses <a href="https://github.com/tj/co">the library <em>co</em></a> by T.J. Holowaychuk. We need two libraries (if we run Node.js code via <code>babel-node</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="nx">fetch</code> <code class="nx">from</code> <code class="s1">&apos;isomorphic-fetch&apos;</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">co</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">&apos;co&apos;</code><code class="p">);</code>
</pre></div>

</figure>

<p><code>co</code> is the actual library for cooperative multitasking, <code>isomorphic-fetch</code> is a polyfill for the new Promise-based <code>fetch</code> API (a replacement of <code>XMLHttpRequest</code>; read &#x201C;<a href="http://jakearchibald.com/2015/thats-so-fetch/">That&#x2019;s so fetch!</a>&#x201D; by Jake Archibald for more information). <code>fetch</code> makes it easy to write a function <code>getFile</code> that returns the text of a file at a <code>url</code> via a Promise:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">getFile</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">request</code> <code class="o">=&gt;</code> <code class="nx">request</code><code class="p">.</code><code class="nx">text</code><code class="p">());</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We now have all the ingredients to use <code>co</code>. The following task reads the texts of two files, parses the JSON inside them and logs the result.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">co</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="p">[</code><code class="nx">croftStr</code><code class="p">,</code> <code class="nx">bondStr</code><code class="p">]</code> <code class="o">=</code> <code class="k">yield</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>  <code class="c1">// (A)</code>
            <code class="nx">getFile</code><code class="p">(</code><code class="s1">&apos;http://localhost:8000/croft.json&apos;</code><code class="p">),</code>
            <code class="nx">getFile</code><code class="p">(</code><code class="s1">&apos;http://localhost:8000/bond.json&apos;</code><code class="p">),</code>
        <code class="p">]);</code>
        <code class="kr">const</code> <code class="nx">croftJson</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">croftStr</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">bondJson</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">bondStr</code><code class="p">);</code>

        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">croftJson</code><code class="p">);</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bondJson</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;Failure to read: &apos;</code> <code class="o">+</code> <code class="nx">e</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Note how nicely synchronous this code looks, even though it makes an asynchronous call in line A. A generator-as-task makes an async call by yielding a Promise to the scheduler function <code>co</code>. The yielding pauses the generator. Once the Promise returns a result, the scheduler resumes the generator by passing it the result via <code>next()</code>. A simple version of <code>co</code> looks as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">co</code><code class="p">(</code><code class="nx">genFunc</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">genObj</code> <code class="o">=</code> <code class="nx">genFunc</code><code class="p">();</code>
    <code class="nx">step</code><code class="p">(</code><code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>

    <code class="kd">function</code> <code class="nx">step</code><code class="p">({</code><code class="nx">value</code><code class="p">,</code><code class="nx">done</code><code class="p">})</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// A Promise was yielded</code>
            <code class="nx">value</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="nx">step</code><code class="p">(</code><code class="nx">genObj</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">result</code><code class="p">));</code> <code class="c1">// (A)</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="nx">step</code><code class="p">(</code><code class="nx">genObj</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">error</code><code class="p">));</code> <code class="c1">// (B)</code>
            <code class="p">});</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>I have ignored that <code>next()</code> (line A) and <code>throw()</code> (line B) may throw exceptions (whenever an exception escapes the body of the generator function).</p>


<h4 id="sec_generators-are-shallow">
<span class="section-number">22.5.3 </span>The limitations of cooperative multitasking via generators <a class="header-anchor" href="ch_generators.html#sec_generators-are-shallow" aria-hidden="true">#</a></h4>

<p><em>Coroutines</em> are cooperatively multitasked tasks that have no limitations: Inside a coroutine, any function can suspend the whole coroutine (the function activation itself, the activation of the function&#x2019;s caller, the caller&#x2019;s caller, etc.).</p>

<p>In contrast, you can only suspend a generator from directly within a generator and only the current function activation is suspended. Due to these limitations, generators are occasionally called <a href="ch_generators.html#ch_generators_ref_3"><em>shallow coroutines</em> [3]</a>.</p>

<h5 id="_the-benefits-of-the-limitations-of-generators">
<span class="section-number">22.5.3.1 </span>The benefits of the limitations of generators <a class="header-anchor" href="ch_generators.html#_the-benefits-of-the-limitations-of-generators" aria-hidden="true">#</a></h5>

<p>The limitations of generators have two main benefits:</p>

<ul>
  <li>Generators are compatible with <em>event loops</em>, which provide simple cooperative multitasking in browsers. I&#x2019;ll explain the details momentarily.</li>
  <li>Generators are relatively easy to implement, because only a single function activation needs to be suspended and because browsers can continue to use event loops.</li>
</ul>

<p>JavaScript already has a very simple style of cooperative multitasking: the event loop, which schedules the execution of tasks in a queue. Each task is started by calling a function and finished once that function is finished. Events, <code>setTimeout()</code> and other mechanisms add tasks to the queue.</p>

<aside class="information blurb">
    <p>This explanation of the event loop is a simplification that is good enough for now. If you are interested in details, consult <a href="ch_async.html#ch_async">the chapter on asynchronous programming</a>.</p>

</aside>

<p>This style of multitasking makes one important guarantee: <em>run to completion</em>; every function can rely on not being interrupted by another task until it is finished. Functions become transactions and can perform complete algorithms without anyone seeing the data they operate on in an intermediate state. Concurrent access to shared data makes multitasking complicated and is not allowed by JavaScript&#x2019;s concurrency model. That&#x2019;s why run to completion is a good thing.</p>

<p>Alas, coroutines prevent run to completion, because any function could suspend its caller. For example, the following algorithm consists of multiple steps:</p>

<figure class="code">
<div class="highlight"><pre><code></code>step1(sharedData);
step2(sharedData);
lastStep(sharedData);
</pre></div>

</figure>

<p>If <code>step2</code> was to suspend the algorithm, other tasks could run before the last step of the algorithm is performed. Those tasks could contain other parts of the application which would see <code>sharedData</code> in an unfinished state. Generators preserve run to completion, they only suspend themselves and return to their caller.</p>

<p><code>co</code> and similar libraries give you most of the power of coroutines, without their disadvantages:</p>

<ul>
  <li>They provide schedulers for tasks defined via generators.</li>
  <li>Tasks &#x201C;are&#x201D; generators and can thus be fully suspended.</li>
  <li>A recursive (generator) function call is only suspendable if it is done via <code>yield*</code>. That gives callers control over suspension.</li>
</ul>


<h3 id="sec_examples-of-generators">
<span class="section-number">22.6 </span>Examples of generators <a class="header-anchor" href="ch_generators.html#sec_examples-of-generators" aria-hidden="true">#</a></h3>

<p>This section gives several examples of what generators can be used for.</p>

<aside class="generic_inbar blurb github-alt icon-github-alt">
    <p>The following GitHub repository contains the example code: <a href="https://github.com/rauschma/generator-examples"><code>generator-examples</code></a></p>

</aside>


<h4 id="_implementing-iterables-via-generators">
<span class="section-number">22.6.1 </span>Implementing iterables via generators <a class="header-anchor" href="ch_generators.html#_implementing-iterables-via-generators" aria-hidden="true">#</a></h4>

<p>In <a href="ch_iteration.html#ch_iteration">the chapter on iteration</a>, I implemented several iterables &#x201C;by hand&#x201D;. In this section, I use generators, instead.</p>

<h5 id="_the-iterable-combinator-take">
<span class="section-number">22.6.1.1 </span>The iterable combinator <code>take()</code>
 <a class="header-anchor" href="ch_generators.html#_the-iterable-combinator-take" aria-hidden="true">#</a></h5>

<p><code>take()</code> converts a (potentially infinite) sequence of iterated values into a sequence of length <code>n</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">take</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
        <code class="nx">n</code><code class="o">--</code><code class="p">;</code>
        <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The following is an example of using it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="s1">&apos;a&apos;</code><code class="p">,</code> <code class="s1">&apos;b&apos;</code><code class="p">,</code> <code class="s1">&apos;c&apos;</code><code class="p">,</code> <code class="s1">&apos;d&apos;</code><code class="p">];</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">take</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="nx">arr</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output:</code>
<code class="c1">// a</code>
<code class="c1">// b</code>
</pre></div>

</figure>

<p>An implementation of <code>take()</code> without generators is more complicated:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">take</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">iter</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">n</code><code class="o">--</code><code class="p">;</code>
                <code class="k">return</code> <code class="nx">iter</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="nx">maybeCloseIterator</code><code class="p">(</code><code class="nx">iter</code><code class="p">);</code>
                <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
            <code class="p">}</code>
        <code class="p">},</code>
        <code class="k">return</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="nx">maybeCloseIterator</code><code class="p">(</code><code class="nx">iter</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">};</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">maybeCloseIterator</code><code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">iterator</code><code class="p">.</code><code class="k">return</code> <code class="o">===</code> <code class="s1">&apos;function&apos;</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">iterator</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Note that <a href="ch_iteration.html#sec_zip">the iterable combinator <code>zip()</code></a> does not profit much from being implemented via a generator, because multiple iterables are involved and <code>for-of</code> can&#x2019;t be used.</p>

<h5 id="_infinite-iterables-1">
<span class="section-number">22.6.1.2 </span>Infinite iterables <a class="header-anchor" href="ch_generators.html#_infinite-iterables-1" aria-hidden="true">#</a></h5>

<p><code>naturalNumbers()</code> returns an iterable over all natural numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">naturalNumbers</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">n</code><code class="o">=</code><code class="mi">0</code><code class="p">;;</code> <code class="nx">n</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">n</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This function is often used in conjunction with a combinator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">take</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="nx">naturalNumbers</code><code class="p">()))</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// Output</code>
<code class="c1">// 0</code>
<code class="c1">// 1</code>
<code class="c1">// 2</code>
</pre></div>

</figure>

<p>Here is the non-generator implementation, so you can compare:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">naturalNumbers</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code> <code class="p">};</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<h5 id="_array-inspired-iterable-combinators-map-filter">
<span class="section-number">22.6.1.3 </span>Array-inspired iterable combinators: <code>map</code>, <code>filter</code>
 <a class="header-anchor" href="ch_generators.html#_array-inspired-iterable-combinators-map-filter" aria-hidden="true">#</a></h5>

<p>Arrays can be transformed via the methods <code>map</code> and <code>filter</code>. Those methods can be generalized to have iterables as input and iterables as output.</p>

<h6 id="_a-generalized-map">
<span class="section-number">22.6.1.3.1 </span>A generalized <code>map()</code>
 <a class="header-anchor" href="ch_generators.html#_a-generalized-map" aria-hidden="true">#</a></h6>

<p>This is the generalized version of <code>map</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">map</code><code class="p">(</code><code class="nx">iterable</code><code class="p">,</code> <code class="nx">mapFunc</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">mapFunc</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>map()</code> works with infinite iterables:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [...take(4, map(naturalNumbers(), x =&gt; x * x))]
[ 0, 1, 4, 9 ]
</pre></div>

</figure>

<h6 id="_a-generalized-filter">
<span class="section-number">22.6.1.3.2 </span>A generalized <code>filter()</code>
 <a class="header-anchor" href="ch_generators.html#_a-generalized-filter" aria-hidden="true">#</a></h6>

<p>This is the generalized version of <code>filter</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">filter</code><code class="p">(</code><code class="nx">iterable</code><code class="p">,</code> <code class="nx">filterFunc</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">filterFunc</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>filter()</code> works with infinite iterables:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [...take(4, filter(naturalNumbers(), x =&gt; (x % 2) === 0))]
[ 0, 2, 4, 6 ]
</pre></div>

</figure>


<h4 id="_generators-for-lazy-evaluation">
<span class="section-number">22.6.2 </span>Generators for lazy evaluation <a class="header-anchor" href="ch_generators.html#_generators-for-lazy-evaluation" aria-hidden="true">#</a></h4>

<p>The next two examples show how generators can be used to process a stream of characters.</p>

<ul>
  <li>The input is a stream of characters.</li>
  <li>Step 1 &#x2013; tokenizing (characters &#x2192; words): The characters are grouped into <em>words</em>, strings that match the regular expression <code>/^[A-Za-z0-9]+$/</code>. Non-word characters are ignored, but they separate words. The input of this step is a stream of characters, the output a stream of words.</li>
  <li>Step 2 &#x2013; extracting numbers (words &#x2192; numbers): only keep words that match the regular expression <code>/^[0-9]+$/</code> and convert them to numbers.</li>
  <li>Step 3 &#x2013; adding numbers (numbers &#x2192; numbers): for every number received, return the total received so far.</li>
</ul>

<p>The neat thing is that everything is computed <em>lazily</em> (incrementally and on demand): computation starts as soon as the first character arrives. For example, we don&#x2019;t have to wait until we have all characters to get the first word.</p>

<h5 id="_lazy-pull-generators-as-iterators">
<span class="section-number">22.6.2.1 </span>Lazy pull (generators as iterators) <a class="header-anchor" href="ch_generators.html#_lazy-pull-generators-as-iterators" aria-hidden="true">#</a></h5>

<p>Lazy pull with generators works as follows. The three generators implementing steps 1&#x2013;3 are chained as follows:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">addNumbers</code><code class="p">(</code><code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">tokenize</code><code class="p">(</code><code class="nx">CHARS</code><code class="p">)))</code>
</pre></div>

</figure>

<p>Each of the chain members pulls data from a source and yields a sequence of items. Processing starts with <code>tokenize</code> whose source is the string <code>CHARS</code>.</p>

<h6 id="_step-1--tokenizing">
<span class="section-number">22.6.2.1.1 </span>Step 1 &#x2013; tokenizing <a class="header-anchor" href="ch_generators.html#_step-1--tokenizing" aria-hidden="true">#</a></h6>

<p>The following trick makes the code a bit simpler: the end-of-sequence iterator result (whose property <code>done</code> is <code>false</code>) is converted into the sentinel value <code>END_OF_SEQUENCE</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Returns an iterable that transforms the input sequence</code>
<code class="cm"> * of characters into an output sequence of words.</code>
<code class="cm"> */</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">tokenize</code><code class="p">(</code><code class="nx">chars</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">chars</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
    <code class="kd">let</code> <code class="nx">ch</code><code class="p">;</code>
    <code class="k">do</code> <code class="p">{</code>
        <code class="nx">ch</code> <code class="o">=</code> <code class="nx">getNextItem</code><code class="p">(</code><code class="nx">iterator</code><code class="p">);</code> <code class="c1">// (A)</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">))</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">word</code> <code class="o">=</code> <code class="s1">&apos;&apos;</code><code class="p">;</code>
            <code class="k">do</code> <code class="p">{</code>
                <code class="nx">word</code> <code class="o">+=</code> <code class="nx">ch</code><code class="p">;</code>
                <code class="nx">ch</code> <code class="o">=</code> <code class="nx">getNextItem</code><code class="p">(</code><code class="nx">iterator</code><code class="p">);</code> <code class="c1">// (B)</code>
            <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">));</code>
            <code class="k">yield</code> <code class="nx">word</code><code class="p">;</code> <code class="c1">// (C)</code>
        <code class="p">}</code>
        <code class="c1">// Ignore all other characters</code>
    <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="nx">ch</code> <code class="o">!==</code> <code class="nx">END_OF_SEQUENCE</code><code class="p">);</code>
<code class="p">}</code>
<code class="kr">const</code> <code class="nx">END_OF_SEQUENCE</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
<code class="kd">function</code> <code class="nx">getNextItem</code><code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code><code class="nx">value</code><code class="p">,</code><code class="nx">done</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">done</code> <code class="o">?</code> <code class="nx">END_OF_SEQUENCE</code> <code class="o">:</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">typeof</code> <code class="nx">ch</code> <code class="o">===</code> <code class="s1">&apos;string&apos;</code> <code class="o">&amp;&amp;</code> <code class="sr">/^[A-Za-z0-9]$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">ch</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>How is this generator lazy? When you ask it for a token via <code>next()</code>, it pulls its <code>iterator</code> (lines A and B) as often as needed to produce as token and then yields that token (line C). Then it pauses until it is again asked for a token. That means that tokenization starts as soon as the first characters are available, which is convenient for streams.</p>

<p>Let&#x2019;s try out tokenization. Note that the spaces and the dot are non-words. They are ignored, but they separate words. We use the fact that strings are iterables over characters (Unicode code points). The result of <code>tokenize()</code> is an iterable over words, which we turn into an array via the spread operator (<code>...</code>).</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [...tokenize(&apos;2 apples and 5 oranges.&apos;)]
[ &apos;2&apos;, &apos;apples&apos;, &apos;and&apos;, &apos;5&apos;, &apos;oranges&apos; ]
</pre></div>

</figure>

<h6 id="_step-2--extracting-numbers">
<span class="section-number">22.6.2.1.2 </span>Step 2 &#x2013; extracting numbers <a class="header-anchor" href="ch_generators.html#_step-2--extracting-numbers" aria-hidden="true">#</a></h6>

<p>This step is relatively simple, we only <code>yield</code> words that contain nothing but digits, after converting them to numbers via <code>Number()</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Returns an iterable that filters the input sequence</code>
<code class="cm"> * of words and only yields those that are numbers.</code>
<code class="cm"> */</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">words</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">word</code> <code class="k">of</code> <code class="nx">words</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="sr">/^[0-9]+$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">word</code><code class="p">))</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">word</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>You can again see the laziness: If you ask for a number via <code>next()</code>, you get one (via <code>yield</code>) as soon as one is encountered in <code>words</code>.</p>

<p>Let&#x2019;s extract the numbers from an Array of words:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; [...extractNumbers([&apos;hello&apos;, &apos;123&apos;, &apos;world&apos;, &apos;45&apos;])]
[ 123, 45 ]
</pre></div>

</figure>

<p>Note that strings are converted to numbers.</p>

<h6 id="_step-3--adding-numbers">
<span class="section-number">22.6.2.1.3 </span>Step 3 &#x2013; adding numbers <a class="header-anchor" href="ch_generators.html#_step-3--adding-numbers" aria-hidden="true">#</a></h6>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Returns an iterable that contains, for each number in</code>
<code class="cm"> * `numbers`, the total sum of numbers encountered so far.</code>
<code class="cm"> * For example: 7, 4, -1 --&gt; 7, 11, 10</code>
<code class="cm"> */</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">addNumbers</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">n</code> <code class="k">of</code> <code class="nx">numbers</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">n</code><code class="p">;</code>
        <code class="k">yield</code> <code class="nx">result</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Let&#x2019;s try a simple example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="p">[...</code><code class="nx">addNumbers</code><code class="p">([</code><code class="mi">5</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="mi">12</code><code class="p">])]</code>
<code class="p">[</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">15</code> <code class="p">]</code>
</pre></div>

</figure>

<h6 id="_pulling-the-output">
<span class="section-number">22.6.2.1.4 </span>Pulling the output <a class="header-anchor" href="ch_generators.html#_pulling-the-output" aria-hidden="true">#</a></h6>

<p>On its own, the chain of generator doesn&#x2019;t produce output. We need to actively pull the output via the spread operator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">CHARS</code> <code class="o">=</code> <code class="s1">&apos;2 apples and 5 oranges.&apos;</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">CHAIN</code> <code class="o">=</code> <code class="nx">addNumbers</code><code class="p">(</code><code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">tokenize</code><code class="p">(</code><code class="nx">CHARS</code><code class="p">)));</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">([...</code><code class="nx">CHAIN</code><code class="p">]);</code>
    <code class="c1">// [ 2, 7 ]</code>
</pre></div>

</figure>

<p>The helper function <code>logAndYield</code> allows us to examine whether things are indeed computed lazily:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">logAndYield</code><code class="p">(</code><code class="nx">iterable</code><code class="p">,</code> <code class="nx">prefix</code><code class="o">=</code><code class="s1">&apos;&apos;</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">item</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">prefix</code> <code class="o">+</code> <code class="nx">item</code><code class="p">);</code>
        <code class="k">yield</code> <code class="nx">item</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">CHAIN2</code> <code class="o">=</code> <code class="nx">logAndYield</code><code class="p">(</code><code class="nx">addNumbers</code><code class="p">(</code><code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">tokenize</code><code class="p">(</code><code class="nx">logAndYield</code><code class="p">(</code><code class="nx">CHA</code><code class="o">\</code>
<code class="nx">RS</code><code class="p">)))),</code> <code class="s1">&apos;-&gt; &apos;</code><code class="p">);</code>
<code class="p">[...</code><code class="nx">CHAIN2</code><code class="p">];</code>

<code class="c1">// Output:</code>
<code class="c1">// 2</code>
<code class="c1">//  </code>
<code class="c1">// -&gt; 2</code>
<code class="c1">// a</code>
<code class="c1">// p</code>
<code class="c1">// p</code>
<code class="c1">// l</code>
<code class="c1">// e</code>
<code class="c1">// s</code>
<code class="c1">//  </code>
<code class="c1">// a</code>
<code class="c1">// n</code>
<code class="c1">// d</code>
<code class="c1">//  </code>
<code class="c1">// 5</code>
<code class="c1">//  </code>
<code class="c1">// -&gt; 7</code>
<code class="c1">// o</code>
<code class="c1">// r</code>
<code class="c1">// a</code>
<code class="c1">// n</code>
<code class="c1">// g</code>
<code class="c1">// e</code>
<code class="c1">// s</code>
<code class="c1">// .</code>
</pre></div>

</figure>

<p>The output shows that <code>addNumbers</code> produces a result as soon as the characters <code>&apos;2&apos;</code> and <code>&apos; &apos;</code> are received.</p>

<h5 id="_lazy-push-generators-as-observables">
<span class="section-number">22.6.2.2 </span>Lazy push (generators as observables) <a class="header-anchor" href="ch_generators.html#_lazy-push-generators-as-observables" aria-hidden="true">#</a></h5>

<p>Not much work is needed to convert the previous pull-based algorithm into a push-based one. The steps are the same. But instead of finishing via pulling, we start via pushing.</p>

<p>As previously explained, if generators receive input via <code>yield</code>, the first invocation of <code>next()</code> on the generator object doesn&#x2019;t do anything. That&#x2019;s why I use <a href="ch_generators.html#function_coroutine">the previously shown helper function <code>coroutine()</code></a> to create coroutines here. It executes the first <code>next()</code> for us.</p>

<p>The following function <code>send()</code> does the pushing.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Pushes the items of `iterable` into `sink`, a generator.</code>
<code class="cm"> * It uses the generator method `next()` to do so.</code>
<code class="cm"> */</code>
<code class="kd">function</code> <code class="nx">send</code><code class="p">(</code><code class="nx">iterable</code><code class="p">,</code> <code class="nx">sink</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">sink</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="nx">sink</code><code class="p">.</code><code class="k">return</code><code class="p">();</code> <code class="c1">// signal end of stream</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>When a generator processes a stream, it needs to be aware of the end of the stream, so that it can clean up properly. For pull, we did this via a special end-of-stream sentinel. For push, the end-of-stream is signaled via <code>return()</code>.</p>

<p>Let&#x2019;s test <code>send()</code> via a generator that simply outputs everything it receives:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * This generator logs everything that it receives via `next()`.</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">logItems</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">item</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code> <code class="c1">// receive item via `next()`</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;DONE&apos;</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Let&#x2019;s send <code>logItems()</code> three characters via a string (which is an iterable over Unicode code points).</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; send(&apos;abc&apos;, logItems());
a
b
c
DONE
</pre></div>

</figure>

<h6 id="_step-1--tokenize">
<span class="section-number">22.6.2.2.1 </span>Step 1 &#x2013; tokenize <a class="header-anchor" href="ch_generators.html#_step-1--tokenize" aria-hidden="true">#</a></h6>

<p>Note how this generator reacts to the end of the stream (as signaled via <code>return()</code>) in two <code>finally</code> clauses. We depend on <code>return()</code> being sent to either one of the two <code>yield</code>s. Otherwise, the generator would never terminate, because the infinite loop starting in line A would never terminate.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Receives a sequence of characters (via the generator object</code>
<code class="cm"> * method `next()`), groups them into words and pushes them</code>
<code class="cm"> * into the generator `sink`.</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">tokenize</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">sink</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// (A)</code>
            <code class="kd">let</code> <code class="nx">ch</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code> <code class="c1">// (B)</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">))</code> <code class="p">{</code>
                <code class="c1">// A word has started</code>
                <code class="kd">let</code> <code class="nx">word</code> <code class="o">=</code> <code class="s1">&apos;&apos;</code><code class="p">;</code>
                <code class="k">try</code> <code class="p">{</code>
                    <code class="k">do</code> <code class="p">{</code>
                        <code class="nx">word</code> <code class="o">+=</code> <code class="nx">ch</code><code class="p">;</code>
                        <code class="nx">ch</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code> <code class="c1">// (C)</code>
                    <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">));</code>
                <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
                    <code class="c1">// The word is finished.</code>
                    <code class="c1">// We get here if</code>
                    <code class="c1">// - the loop terminates normally</code>
                    <code class="c1">// - the loop is terminated via `return()` in line C</code>
                    <code class="nx">sink</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">word</code><code class="p">);</code> <code class="c1">// (D)</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="c1">// Ignore all other characters</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="c1">// We only get here if the infinite loop is terminated</code>
        <code class="c1">// via `return()` (in line B or C).</code>
        <code class="c1">// Forward `return()` to `sink` so that it is also</code>
        <code class="c1">// aware of the end of stream.</code>
        <code class="nx">sink</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="kd">function</code> <code class="nx">isWordChar</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="sr">/^[A-Za-z0-9]$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">ch</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This time, the laziness is driven by push: as soon as the generator has received enough characters for a word (in line C), it pushes the word into <code>sink</code> (line D). That is, the generator does not wait until it has received all characters.</p>

<p><code>tokenize()</code> demonstrates that generators work well as implementations of linear state machines. In this case, the machine has two states: &#x201C;inside a word&#x201D; and &#x201C;not inside a word&#x201D;.</p>

<p>Let&#x2019;s tokenize a string:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; send(&apos;2 apples and 5 oranges.&apos;, tokenize(logItems()));
2
apples
and
5
oranges
</pre></div>

</figure>

<h6 id="_step-2--extract-numbers">
<span class="section-number">22.6.2.2.2 </span>Step 2 &#x2013; extract numbers <a class="header-anchor" href="ch_generators.html#_step-2--extract-numbers" aria-hidden="true">#</a></h6>

<p>This step is straightforward.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Receives a sequence of strings (via the generator object</code>
<code class="cm"> * method `next()`) and pushes only those strings to the generator</code>
<code class="cm"> * `sink` that are &#x201C;numbers&#x201D; (consist only of decimal digits).</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">extractNumbers</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">sink</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">word</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
            <code class="k">if</code> <code class="p">(</code><code class="sr">/^[0-9]+$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">word</code><code class="p">))</code> <code class="p">{</code>
                <code class="nx">sink</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nb">Number</code><code class="p">(</code><code class="nx">word</code><code class="p">));</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="c1">// Only reached via `return()`, forward.</code>
        <code class="nx">sink</code><code class="p">.</code><code class="k">return</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Things are again lazy: as soon as a number is encountered, it is pushed to <code>sink</code>.</p>

<p>Let&#x2019;s extract the numbers from an Array of words:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; send([&apos;hello&apos;, &apos;123&apos;, &apos;world&apos;, &apos;45&apos;], extractNumbers(logItems()));
123
45
DONE
</pre></div>

</figure>

<p>Note that the input is a sequence of strings, while the output is a sequence of numbers.</p>

<h6 id="_step-3--add-numbers">
<span class="section-number">22.6.2.2.3 </span>Step 3 &#x2013; add numbers <a class="header-anchor" href="ch_generators.html#_step-3--add-numbers" aria-hidden="true">#</a></h6>

<p>This time, we react to the end of the stream by pushing a single value and then closing the sink.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="cm">/**</code>
<code class="cm"> * Receives a sequence of numbers (via the generator object</code>
<code class="cm"> * method `next()`). For each number, it pushes the total sum</code>
<code class="cm"> * so far to the generator `sink`.</code>
<code class="cm"> */</code>
<code class="kr">const</code> <code class="nx">addNumbers</code> <code class="o">=</code> <code class="nx">coroutine</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">sink</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">sum</code> <code class="o">+=</code> <code class="k">yield</code><code class="p">;</code>
            <code class="nx">sink</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">sum</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
        <code class="c1">// We received an end-of-stream</code>
        <code class="nx">sink</code><code class="p">.</code><code class="k">return</code><code class="p">();</code> <code class="c1">// signal end of stream</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Let&#x2019;s try out this generator:</p>

<figure class="code">
<div class="highlight"><pre><code></code>&gt; send([5, -2, 12], addNumbers(logItems()));
5
3
15
DONE
</pre></div>

</figure>

<h6 id="_pushing-the-input">
<span class="section-number">22.6.2.2.4 </span>Pushing the input <a class="header-anchor" href="ch_generators.html#_pushing-the-input" aria-hidden="true">#</a></h6>

<p>The chain of generators starts with <code>tokenize</code> and ends with <code>logItems</code>, which logs everything it receives. We push a sequence of characters into the chain via <code>send</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">INPUT</code> <code class="o">=</code> <code class="s1">&apos;2 apples and 5 oranges.&apos;</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">CHAIN</code> <code class="o">=</code> <code class="nx">tokenize</code><code class="p">(</code><code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">addNumbers</code><code class="p">(</code><code class="nx">logItems</code><code class="p">())));</code>
<code class="nx">send</code><code class="p">(</code><code class="nx">INPUT</code><code class="p">,</code> <code class="nx">CHAIN</code><code class="p">);</code>

<code class="c1">// Output</code>
<code class="c1">// 2</code>
<code class="c1">// 7</code>
<code class="c1">// DONE</code>
</pre></div>

</figure>

<p>The following code proves that processing really happens lazily:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">CHAIN2</code> <code class="o">=</code> <code class="nx">tokenize</code><code class="p">(</code><code class="nx">extractNumbers</code><code class="p">(</code><code class="nx">addNumbers</code><code class="p">(</code><code class="nx">logItems</code><code class="p">({</code> <code class="nx">prefix</code><code class="o">:</code> <code class="s1">&apos;-&gt; &apos;</code> <code class="p">})</code><code class="o">\</code>
<code class="p">)));</code>
<code class="nx">send</code><code class="p">(</code><code class="nx">INPUT</code><code class="p">,</code> <code class="nx">CHAIN2</code><code class="p">,</code> <code class="p">{</code> <code class="nx">log</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code>

<code class="c1">// Output</code>
<code class="c1">// 2</code>
<code class="c1">//  </code>
<code class="c1">// -&gt; 2</code>
<code class="c1">// a</code>
<code class="c1">// p</code>
<code class="c1">// p</code>
<code class="c1">// l</code>
<code class="c1">// e</code>
<code class="c1">// s</code>
<code class="c1">//  </code>
<code class="c1">// a</code>
<code class="c1">// n</code>
<code class="c1">// d</code>
<code class="c1">//  </code>
<code class="c1">// 5</code>
<code class="c1">//  </code>
<code class="c1">// -&gt; 7</code>
<code class="c1">// o</code>
<code class="c1">// r</code>
<code class="c1">// a</code>
<code class="c1">// n</code>
<code class="c1">// g</code>
<code class="c1">// e</code>
<code class="c1">// s</code>
<code class="c1">// .</code>
<code class="c1">// DONE</code>
</pre></div>

</figure>

<p>The output shows that <code>addNumbers</code> produces a result as soon as the characters <code>&apos;2&apos;</code> and <code>&apos; &apos;</code> are pushed.</p>


<h4 id="_cooperative-multi-tasking-via-generators">
<span class="section-number">22.6.3 </span>Cooperative multi-tasking via generators <a class="header-anchor" href="ch_generators.html#_cooperative-multi-tasking-via-generators" aria-hidden="true">#</a></h4>

<h5 id="_pausing-long-running-tasks">
<span class="section-number">22.6.3.1 </span>Pausing long-running tasks <a class="header-anchor" href="ch_generators.html#_pausing-long-running-tasks" aria-hidden="true">#</a></h5>

<p>In this example, we create a counter that is displayed on a web page. We improve an initial version until we have a cooperatively multitasked version that doesn&#x2019;t block the main thread and the user interface.</p>

<p>This is the part of the web page in which the counter should be displayed:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>
    Counter: <code class="p">&lt;</code><code class="nt">span</code> <code class="na">id</code><code class="o">=</code><code class="s">&quot;counter&quot;</code><code class="p">&gt;&lt;/</code><code class="nt">span</code><code class="p">&gt;</code>
<code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>
</pre></div>

</figure>

<p>This function displays a counter that counts up forever<sup id="fnref-generators_1"><a href="leanpub-endnotes.html#fn-generators_1" rel="footnote">5</a></sup>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">countUp</code><code class="p">(</code><code class="nx">start</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">counterSpan</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">&apos;#counter&apos;</code><code class="p">);</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">counterSpan</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="nb">String</code><code class="p">(</code><code class="nx">start</code><code class="p">);</code>
        <code class="nx">start</code><code class="o">++</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>If you ran this function, it would completely block the user interface thread in which it runs and its tab would become unresponsive.</p>

<p>Let&#x2019;s implement the same functionality via a generator that periodically pauses via <code>yield</code> (a scheduling function for running this generator is shown later):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">countUp</code><code class="p">(</code><code class="nx">start</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">counterSpan</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">&apos;#counter&apos;</code><code class="p">);</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">counterSpan</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="nb">String</code><code class="p">(</code><code class="nx">start</code><code class="p">);</code>
        <code class="nx">start</code><code class="o">++</code><code class="p">;</code>
        <code class="k">yield</code><code class="p">;</code> <code class="c1">// pause</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Let&#x2019;s add one small improvement. We move the update of the user interface to another generator, <code>displayCounter</code>, which we call via <code>yield*</code>. As it is a generator, it can also take care of pausing.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">countUp</code><code class="p">(</code><code class="nx">start</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">start</code><code class="o">++</code><code class="p">;</code>
        <code class="k">yield</code><code class="o">*</code> <code class="nx">displayCounter</code><code class="p">(</code><code class="nx">start</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">displayCounter</code><code class="p">(</code><code class="nx">counter</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">counterSpan</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">&apos;#counter&apos;</code><code class="p">);</code>
    <code class="nx">counterSpan</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="nb">String</code><code class="p">(</code><code class="nx">counter</code><code class="p">);</code>
    <code class="k">yield</code><code class="p">;</code> <code class="c1">// pause</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Lastly, this is a scheduling function that we can use to run <code>countUp()</code>. Each execution step of the generator is handled by a separate task, which is created via <code>setTimeout()</code>. That means that the user interface can schedule other tasks in between and will remain responsive.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">run</code><code class="p">(</code><code class="nx">generatorObject</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">generatorObject</code><code class="p">.</code><code class="nx">next</code><code class="p">().</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Add a new task to the event queue</code>
        <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
            <code class="nx">run</code><code class="p">(</code><code class="nx">generatorObject</code><code class="p">);</code>
        <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>With the help of <code>run</code>, we get a (nearly) infinite count-up that doesn&#x2019;t block the user interface:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">run</code><code class="p">(</code><code class="nx">countUp</code><code class="p">());</code>
</pre></div>

</figure>

<aside class="generic_inbar blurb github-alt icon-github-alt">
    <p>You can <a href="https://rauschma.github.io/generator-examples/nonblocking-counter/">run this example online</a>.</p>

</aside>

<h5 id="_cooperative-multitasking-with-generators-and-nodejs-style-callbacks">
<span class="section-number">22.6.3.2 </span>Cooperative multitasking with generators and Node.js-style callbacks <a class="header-anchor" href="ch_generators.html#_cooperative-multitasking-with-generators-and-nodejs-style-callbacks" aria-hidden="true">#</a></h5>

<p>If you call a generator function (or method), it does not have access to its generator object; its <code>this</code> is the <code>this</code> it would have if it were a non-generator function. A work-around is to pass the generator object into the generator function via <code>yield</code>.</p>

<p>The following Node.js script uses this technique, but wraps the generator object in a callback (<code>next</code>, line A). It must be run via <code>babel-node</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="p">{</code><code class="nx">readFile</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">&apos;fs&apos;</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">fileNames</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>

<code class="nx">run</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">next</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">f</code> <code class="k">of</code> <code class="nx">fileNames</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">contents</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">readFile</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="p">{</code> <code class="nx">encoding</code><code class="o">:</code> <code class="s1">&apos;utf8&apos;</code> <code class="p">},</code> <code class="nx">next</code><code class="p">);</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">&apos;##### &apos;</code> <code class="o">+</code> <code class="nx">f</code><code class="p">);</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In line A, we get a callback that we can use with functions that follow Node.js callback conventions. The callback uses the generator object to wake up the generator, as you can see in the implementation of <code>run()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">run</code><code class="p">(</code><code class="nx">generatorFunction</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">generatorObject</code> <code class="o">=</code> <code class="nx">generatorFunction</code><code class="p">();</code>

    <code class="c1">// Step 1: Proceed to first `yield`</code>
    <code class="nx">generatorObject</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

    <code class="c1">// Step 2: Pass in a function that the generator can use as a callback</code>
    <code class="kd">function</code> <code class="nx">nextFunction</code><code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">generatorObject</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">generatorObject</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
    <code class="nx">generatorObject</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">nextFunction</code><code class="p">);</code>

    <code class="c1">// Subsequent invocations of `next()` are triggered by `nextFunction`</code>
<code class="p">}</code>
</pre></div>

</figure>

<h5 id="sec_csp">
<span class="section-number">22.6.3.3 </span>Communicating Sequential Processes (CSP) <a class="header-anchor" href="ch_generators.html#sec_csp" aria-hidden="true">#</a></h5>

<p>The library <a href="https://github.com/ubolonton/js-csp"><code>js-csp</code></a> brings Communicating Sequential Processes (CSP) to JavaScript, a style of cooperative multitasking that is similar to ClojureScript&#x2019;s core.async and Go&#x2019;s <em>goroutines</em>. <code>js-csp</code> has two abstractions:</p>

<ul>
  <li>Processes: are cooperatively multitasked tasks and implemented by handing a generator function to the scheduling function <code>go()</code>.</li>
  <li>Channels: are queues for communication between processes. Channels are created by calling <code>chan()</code>.</li>
</ul>

<p>As an example, let&#x2019;s use CSP to handle DOM events, in a manner reminiscent of Functional Reactive Programming. The following code uses the function <code>listen()</code> (which is shown later) to create a channel that outputs <code>mousemove</code> events. It then continuously retrieves the output via <code>take</code>, inside an infinite loop. Thanks to <code>yield</code>, the process blocks until the channel has output.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">import</code> <code class="nx">csp</code> <code class="nx">from</code> <code class="s1">&apos;js-csp&apos;</code><code class="p">;</code>

<code class="nx">csp</code><code class="p">.</code><code class="nx">go</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">element</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">&apos;#uiElement1&apos;</code><code class="p">);</code>
    <code class="kr">const</code> <code class="nx">channel</code> <code class="o">=</code> <code class="nx">listen</code><code class="p">(</code><code class="nx">element</code><code class="p">,</code> <code class="s1">&apos;mousemove&apos;</code><code class="p">);</code>
    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">event</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">csp</code><code class="p">.</code><code class="nx">take</code><code class="p">(</code><code class="nx">channel</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">event</code><code class="p">.</code><code class="nx">layerX</code> <code class="o">||</code> <code class="nx">event</code><code class="p">.</code><code class="nx">clientX</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">event</code><code class="p">.</code><code class="nx">layerY</code> <code class="o">||</code> <code class="nx">event</code><code class="p">.</code><code class="nx">clientY</code><code class="p">;</code>
        <code class="nx">element</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">y</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p><code>listen()</code> is implemented as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">listen</code><code class="p">(</code><code class="nx">element</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">channel</code> <code class="o">=</code> <code class="nx">csp</code><code class="p">.</code><code class="nx">chan</code><code class="p">();</code>
    <code class="nx">element</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="nx">type</code><code class="p">,</code>
        <code class="nx">event</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">csp</code><code class="p">.</code><code class="nx">putAsync</code><code class="p">(</code><code class="nx">channel</code><code class="p">,</code> <code class="nx">event</code><code class="p">);</code>
        <code class="p">});</code>
    <code class="k">return</code> <code class="nx">channel</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<aside class="generic_inbar blurb external-link icon-external-link">
    <p>This example is taken from the blog post &#x201C;<a href="http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript">Taming the Asynchronous Beast with CSP Channels in JavaScript</a>&#x201D; by James Long. Consult this blog post for more information on CSP.</p>

</aside>


<h3 id="sec_iteration-api-inheritance">
<span class="section-number">22.7 </span>Inheritance within the iteration API (including generators) <a class="header-anchor" href="ch_generators.html#sec_iteration-api-inheritance" aria-hidden="true">#</a></h3>

<p>This is a diagram of how various objects are connected in ECMAScript 6 (it is based on <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects">Allen Wirf-Brock&#x2019;s diagram</a> in the ECMAScript specification):</p>


<figure class="image center">
  <img src="images/generators----generator_inheritance_150dpi.png" alt="" width="598.5" height="359">
  <figcaption></figcaption>
</figure>


<p>Legend:</p>

<ul>
  <li>The white (hollow) arrows express the has-prototype relationship (inheritance) between objects. In other words: a white arrow from <code>x</code> to <code>y</code> means that <code>Object.getPrototypeOf(x) === y</code>.</li>
  <li>Parentheses indicate that an object exists, but is not accessible via a global variable.</li>
  <li>An <code>instanceof</code> arrow from <code>x</code> to <code>y</code> means that <code>x instanceof y</code>.
    <ul>
      <li>Remember that <code>o instanceof C</code> is equivalent to <code>C.prototype.isPrototypeOf(o)</code>.</li>
    </ul>
  </li>
  <li>A <code>prototype</code> arrow from <code>x</code> to <code>y</code> means that <code>x.prototype === y</code>.</li>
  <li>The right column shows an instance with its prototypes, the middle column shows a function and its prototypes, the left column shows classes for functions (metafunctions, if you will), connected via a subclass-of relationship.</li>
</ul>

<p>The diagram reveals two interesting facts:</p>

<p>First, a generator function <code>g</code> works very much like a constructor (however, you can&#x2019;t invoke it via <code>new</code>; that causes a <code>TypeError</code>): The generator objects it creates are instances of it, methods added to <code>g.prototype</code> become prototype methods, etc.:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">&gt;</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">g</code><code class="p">()</code> <code class="p">{}</code>
<code class="o">&gt;</code> <code class="nx">g</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">hello</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s1">&apos;hi!&apos;</code><code class="p">};</code>
<code class="o">&gt;</code> <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nx">g</code><code class="p">();</code>
<code class="o">&gt;</code> <code class="nx">obj</code> <code class="k">instanceof</code> <code class="nx">g</code>
<code class="kc">true</code>
<code class="o">&gt;</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">hello</code><code class="p">()</code>
<code class="s1">&apos;hi!&apos;</code>
</pre></div>

</figure>

<p>Second, if you want to make methods available for all generator objects, it&#x2019;s best to add them to <code>(Generator).prototype</code>. One way of accessing that object is as follows:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Generator</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{});</code>
<code class="nx">Generator</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">hello</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s1">&apos;hi!&apos;</code><code class="p">};</code>
<code class="kr">const</code> <code class="nx">generatorObject</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{})();</code>
<code class="nx">generatorObject</code><code class="p">.</code><code class="nx">hello</code><code class="p">();</code> <code class="c1">// &apos;hi!&apos;</code>
</pre></div>

</figure>

<h4 id="_iteratorprototype">
<span class="section-number">22.7.1 </span><code>IteratorPrototype</code>
 <a class="header-anchor" href="ch_generators.html#_iteratorprototype" aria-hidden="true">#</a></h4>

<p>There is no <code>(Iterator)</code> in the diagram, because no such object exists. But, given how <code>instanceof</code> works and because <code>(IteratorPrototype)</code> is a prototype of <code>g1()</code>, you could still say that <code>g1()</code> is an instance of <code>Iterator</code>.</p>

<p>All iterators in ES6 have <code>(IteratorPrototype)</code> in their prototype chain. That object is iterable, because it has the following method. Therefore, all ES6 iterators are iterable (as a consequence, you can apply <code>for-of</code> etc. to them).</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The specification recommends to use the following code to access <code>(IteratorPrototype)</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">proto</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nb">Object</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">IteratorPrototype</code> <code class="o">=</code> <code class="nx">proto</code><code class="p">(</code><code class="nx">proto</code><code class="p">([][</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()));</code>
</pre></div>

</figure>

<p>You could also use:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">IteratorPrototype</code> <code class="o">=</code> <code class="nx">proto</code><code class="p">(</code><code class="nx">proto</code><code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{}.</code><code class="nx">prototype</code><code class="p">));</code>
</pre></div>

</figure>

<p>Quoting the ECMAScript 6 specification:</p>

<blockquote>
  <p>ECMAScript code may also define objects that inherit from <code>IteratorPrototype</code>. The <code>IteratorPrototype</code> object provides a place where additional methods that are applicable to all iterator objects may be added.</p>
</blockquote>

<p><code>IteratorPrototype</code> will probably become directly accessible in an upcoming version of ECMAScript and contain tool methods such as <code>map()</code> and <code>filter()</code> (<a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-07/jul-30.md#47-revisit-comprehension-decision-from-last-meeting">source</a>).</p>

<h4 id="_the-value-of-this-in-generators">
<span class="section-number">22.7.2 </span>The value of <code>this</code> in generators <a class="header-anchor" href="ch_generators.html#_the-value-of-this-in-generators" aria-hidden="true">#</a></h4>

<p>A generator function combines two concerns:</p>

<ol class="numeric">
  <li>It is a function that sets up and returns a generator object.</li>
  <li>It contains the code that the generator object steps through.</li>
</ol>

<p>That&#x2019;s why it&#x2019;s not immediately obvious what the value of <code>this</code> should be inside a generator.</p>

<p>In function calls and method calls, <code>this</code> is what it would be if <code>gen()</code> wasn&#x2019;t a generator function, but a normal function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">gen</code><code class="p">()</code> <code class="p">{</code>
    <code class="s1">&apos;use strict&apos;</code><code class="p">;</code> <code class="c1">// just in case</code>
    <code class="k">yield</code> <code class="k">this</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Retrieve the yielded value via destructuring</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">functionThis</code><code class="p">]</code> <code class="o">=</code> <code class="nx">gen</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">functionThis</code><code class="p">);</code> <code class="c1">// undefined</code>

<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">method</code><code class="o">:</code> <code class="nx">gen</code> <code class="p">};</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">methodThis</code><code class="p">]</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">methodThis</code> <code class="o">===</code> <code class="nx">obj</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</figure>

<p>If you access <code>this</code> in a generator that was invoked via <code>new</code>, you get a <code>ReferenceError</code> (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-runtime-semantics-evaluatebody">source: ES6 spec</a>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">gen</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">);</code> <code class="c1">// ReferenceError</code>
<code class="p">}</code>
<code class="k">new</code> <code class="nx">gen</code><code class="p">();</code>
</pre></div>

</figure>

<p>A work-around is to wrap the generator in a normal function that hands the generator its generator object via <code>next()</code>. That means that the generator must use its first <code>yield</code> to retrieve its generator object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">generatorObject</code> <code class="o">=</code> <code class="k">yield</code><code class="p">;</code>
</pre></div>

</figure>


<h3 id="sec_formating-generators">
<span class="section-number">22.8 </span>Style consideration: whitespace before and after the asterisk <a class="header-anchor" href="ch_generators.html#sec_formating-generators" aria-hidden="true">#</a></h3>

<p>Reasonable &#x2013; and legal &#x2013; variations of formatting the asterisk are:</p>

<ul>
  <li>A space before and after it:<br>
<code>function * foo(x, y) { &#xB7;&#xB7;&#xB7; }</code>
</li>
  <li>A space before it:<br>
<code>function *foo(x, y) { &#xB7;&#xB7;&#xB7; }</code>
</li>
  <li>A space after it:<br>
<code>function* foo(x, y) { &#xB7;&#xB7;&#xB7; }</code>
</li>
  <li>No whitespace before and after it:<br>
<code>function*foo(x, y) { &#xB7;&#xB7;&#xB7; }</code>
</li>
</ul>

<p>Let&#x2019;s figure out which of these variations make sense for which constructs and why.</p>

<h4 id="_generator-function-declarations-and-expressions">
<span class="section-number">22.8.1 </span>Generator function declarations and expressions <a class="header-anchor" href="ch_generators.html#_generator-function-declarations-and-expressions" aria-hidden="true">#</a></h4>

<p>Here, the star is only used because <code>generator</code> (or something similar) isn&#x2019;t available as a keyword. If it were, then a generator function declaration would look like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">generator</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Instead of <code>generator</code>, ECMAScript 6 marks the <code>function</code> keyword with an asterisk. Thus, <code>function*</code> can be seen as a synonym for <code>generator</code>, which suggests writing generator function declarations as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Anonymous generator function expressions would be formatted like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="kd">function</code><code class="o">*</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="_generator-method-definitions-1">
<span class="section-number">22.8.2 </span>Generator method definitions <a class="header-anchor" href="ch_generators.html#_generator-method-definitions-1" aria-hidden="true">#</a></h4>

<p>When writing generator method definitions, I recommend to format the asterisk as follows.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="o">*</code> <code class="nx">generatorMethod</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
        <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>There are three arguments in favor of writing a space after the asterisk.</p>

<p>First, the asterisk shouldn&#x2019;t be part of the method name. On one hand, it isn&#x2019;t part of the name of a generator function. On the other hand, the asterisk is only mentioned when defining a generator, not when using it.</p>

<p>Second, a generator method definition is an abbreviation for the following syntax. (To make my point, I&#x2019;m redundantly giving the function expression a name, too.)</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">generatorMethod</code><code class="o">:</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">generatorMethod</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
        <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>If method definitions are about omitting the <code>function</code> keyword then the asterisk should be followed by a space.</p>

<p>Third, generator method definitions are syntactically similar to getters and setters (which are already available in ECMAScript 5):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">get</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
        <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="p">}</code>
    <code class="nx">set</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The keywords <code>get</code> and <code>set</code> can be seen as modifiers of a normal method definition. Arguably, an asterisk is also such a modifier.</p>

<h4 id="_formatting-recursive-yield">
<span class="section-number">22.8.3 </span>Formatting recursive <code>yield</code>
 <a class="header-anchor" href="ch_generators.html#_formatting-recursive-yield" aria-hidden="true">#</a></h4>

<p>The following is an example of a generator function yielding its own yielded values recursively:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
    <code class="k">yield</code><code class="o">*</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The asterisk marks a different kind of <code>yield</code> operator, which is why the above way of writing it makes sense.</p>

<h4 id="_documenting-generator-functions-and-methods">
<span class="section-number">22.8.4 </span>Documenting generator functions and methods <a class="header-anchor" href="ch_generators.html#_documenting-generator-functions-and-methods" aria-hidden="true">#</a></h4>

<p>Kyle Simpson (@getify) proposed something interesting: Given that we often append parentheses when we write about functions and methods such as <code>Math.max()</code>, wouldn&#x2019;t it make sense to prepend an asterisk when writing about generator functions and methods? For example: should we write <code>*foo()</code> to refer to the generator function in the previous subsection? Let me argue against that.</p>

<p>When it comes to writing a function that returns an iterable, a generator is only one of the several options. I think it is better to not give away this implementation detail via marked function names.</p>

<p>Furthermore, you don&#x2019;t use the asterisk when calling a generator function, but you do use parentheses.</p>

<p>Lastly, the asterisk doesn&#x2019;t provide useful information &#x2013; <code>yield*</code> can also be used with functions that return an iterable. But it may make sense to mark the names of functions and methods (including generators) that return iterables. For example, via the suffix <code>Iter</code>.</p>


<h3 id="sec_faq-generators">
<span class="section-number">22.9 </span>FAQ: generators <a class="header-anchor" href="ch_generators.html#sec_faq-generators" aria-hidden="true">#</a></h3>

<h4 id="_why-use-the-keyword-function-for-generators-and-not-generator">
<span class="section-number">22.9.1 </span>Why use the keyword <code>function*</code> for generators and not <code>generator</code>? <a class="header-anchor" href="ch_generators.html#_why-use-the-keyword-function-for-generators-and-not-generator" aria-hidden="true">#</a></h4>

<p>Due to backward compatibility, using the keyword <code>generator</code> wasn&#x2019;t an option. For example, the following code (a hypothetical ES6 anonymous generator expression) could be an ES5 function call followed by a code block.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">generator</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
    <code class="err">&#xB7;&#xB7;&#xB7;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>I find that the asterisk naming scheme extends nicely to <code>yield*</code>.</p>

<h4 id="_is-yield-a-keyword">
<span class="section-number">22.9.2 </span>Is <code>yield</code> a keyword? <a class="header-anchor" href="ch_generators.html#_is-yield-a-keyword" aria-hidden="true">#</a></h4>

<p><code>yield</code> is only a reserved word in strict mode. A trick is used to bring it to ES6 sloppy mode: it becomes a <em>contextual keyword</em>, one that is only available inside generators.</p>


<h3 id="sec_conclusion-generators">
<span class="section-number">22.10 </span>Conclusion <a class="header-anchor" href="ch_generators.html#sec_conclusion-generators" aria-hidden="true">#</a></h3>

<p>I hope that this chapter convinced you that generators are a useful and versatile tool.</p>

<p>I like that generators let you implement cooperatively multitasked tasks that block while making asynchronous function calls. In my opinion that&#x2019;s the right mental model for async calls. Hopefully, JavaScript goes further in this direction in the future.</p>


<h3 id="sec_further-reading-generators">
<span class="section-number">22.11 </span>Further reading <a class="header-anchor" href="ch_generators.html#sec_further-reading-generators" aria-hidden="true">#</a></h3>

<p>Sources of this chapter:</p>

<p id="ch_generators_ref_1">[1] &#x201C;<a href="https://github.com/jhusain/asyncgenerator">Async Generator Proposal</a>&#x201D; by Jafar Husain</p>

<p id="ch_generators_ref_2">[2] &#x201C;<a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a>&#x201D; by David Beazley</p>

<p id="ch_generators_ref_3">[3] &#x201C;<a href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">Why coroutines won&#x2019;t work on the web</a>&#x201D; by David Herman</p>






<div class="next-chapter">
    Next: <a href="pt_standard-library.html">V Standard library</a>
</div>


</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59555947-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
